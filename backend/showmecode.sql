/*
 Navicat Premium Dump SQL

 Source Server         : showmecode
 Source Server Type    : MySQL
 Source Server Version : 90500 (9.5.0)
 Source Host           : 39.102.209.191:3306
 Source Schema         : fan_code

 Target Server Type    : MySQL
 Target Server Version : 90500 (9.5.0)
 File Encoding         : 65001

 Date: 13/01/2026 02:15:34
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for role_apis
-- ----------------------------
DROP TABLE IF EXISTS `role_apis`;
CREATE TABLE `role_apis`  (
  `sys_role_id` int UNSIGNED NOT NULL,
  `sys_api_id` int UNSIGNED NOT NULL,
  PRIMARY KEY (`sys_role_id`, `sys_api_id`) USING BTREE,
  INDEX `fk_role_apis_sys_api`(`sys_api_id` ASC) USING BTREE,
  CONSTRAINT `fk_role_apis_sys_api` FOREIGN KEY (`sys_api_id`) REFERENCES `sys_apis` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `fk_role_apis_sys_role` FOREIGN KEY (`sys_role_id`) REFERENCES `sys_roles` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of role_apis
-- ----------------------------
INSERT INTO `role_apis` VALUES (1, 1);
INSERT INTO `role_apis` VALUES (2, 1);
INSERT INTO `role_apis` VALUES (3, 1);
INSERT INTO `role_apis` VALUES (1, 2);
INSERT INTO `role_apis` VALUES (2, 2);
INSERT INTO `role_apis` VALUES (3, 2);
INSERT INTO `role_apis` VALUES (1, 13);
INSERT INTO `role_apis` VALUES (2, 13);
INSERT INTO `role_apis` VALUES (3, 13);
INSERT INTO `role_apis` VALUES (1, 14);
INSERT INTO `role_apis` VALUES (2, 14);
INSERT INTO `role_apis` VALUES (3, 14);
INSERT INTO `role_apis` VALUES (1, 15);
INSERT INTO `role_apis` VALUES (2, 15);
INSERT INTO `role_apis` VALUES (3, 15);
INSERT INTO `role_apis` VALUES (1, 16);
INSERT INTO `role_apis` VALUES (2, 16);
INSERT INTO `role_apis` VALUES (3, 16);
INSERT INTO `role_apis` VALUES (1, 57);
INSERT INTO `role_apis` VALUES (2, 57);
INSERT INTO `role_apis` VALUES (3, 57);
INSERT INTO `role_apis` VALUES (1, 58);
INSERT INTO `role_apis` VALUES (2, 58);
INSERT INTO `role_apis` VALUES (3, 58);
INSERT INTO `role_apis` VALUES (1, 59);
INSERT INTO `role_apis` VALUES (2, 59);
INSERT INTO `role_apis` VALUES (3, 59);
INSERT INTO `role_apis` VALUES (1, 60);
INSERT INTO `role_apis` VALUES (2, 60);
INSERT INTO `role_apis` VALUES (3, 60);
INSERT INTO `role_apis` VALUES (1, 61);
INSERT INTO `role_apis` VALUES (2, 61);
INSERT INTO `role_apis` VALUES (3, 61);
INSERT INTO `role_apis` VALUES (1, 62);
INSERT INTO `role_apis` VALUES (2, 62);
INSERT INTO `role_apis` VALUES (3, 62);
INSERT INTO `role_apis` VALUES (1, 63);
INSERT INTO `role_apis` VALUES (2, 63);
INSERT INTO `role_apis` VALUES (3, 63);
INSERT INTO `role_apis` VALUES (1, 64);
INSERT INTO `role_apis` VALUES (2, 64);
INSERT INTO `role_apis` VALUES (3, 64);
INSERT INTO `role_apis` VALUES (1, 65);
INSERT INTO `role_apis` VALUES (1, 66);
INSERT INTO `role_apis` VALUES (2, 66);
INSERT INTO `role_apis` VALUES (3, 66);
INSERT INTO `role_apis` VALUES (1, 67);
INSERT INTO `role_apis` VALUES (1, 68);
INSERT INTO `role_apis` VALUES (1, 69);
INSERT INTO `role_apis` VALUES (1, 70);
INSERT INTO `role_apis` VALUES (1, 71);
INSERT INTO `role_apis` VALUES (1, 72);
INSERT INTO `role_apis` VALUES (1, 73);
INSERT INTO `role_apis` VALUES (1, 74);
INSERT INTO `role_apis` VALUES (1, 75);
INSERT INTO `role_apis` VALUES (1, 76);
INSERT INTO `role_apis` VALUES (1, 77);
INSERT INTO `role_apis` VALUES (1, 78);
INSERT INTO `role_apis` VALUES (1, 79);
INSERT INTO `role_apis` VALUES (1, 80);
INSERT INTO `role_apis` VALUES (1, 81);
INSERT INTO `role_apis` VALUES (1, 82);
INSERT INTO `role_apis` VALUES (1, 83);
INSERT INTO `role_apis` VALUES (1, 84);
INSERT INTO `role_apis` VALUES (1, 85);
INSERT INTO `role_apis` VALUES (1, 86);
INSERT INTO `role_apis` VALUES (1, 87);
INSERT INTO `role_apis` VALUES (1, 88);
INSERT INTO `role_apis` VALUES (1, 89);
INSERT INTO `role_apis` VALUES (1, 90);
INSERT INTO `role_apis` VALUES (1, 91);
INSERT INTO `role_apis` VALUES (1, 92);
INSERT INTO `role_apis` VALUES (1, 93);
INSERT INTO `role_apis` VALUES (1, 94);
INSERT INTO `role_apis` VALUES (1, 95);
INSERT INTO `role_apis` VALUES (1, 96);
INSERT INTO `role_apis` VALUES (1, 97);
INSERT INTO `role_apis` VALUES (1, 98);
INSERT INTO `role_apis` VALUES (1, 99);
INSERT INTO `role_apis` VALUES (1, 100);
INSERT INTO `role_apis` VALUES (1, 101);
INSERT INTO `role_apis` VALUES (1, 102);
INSERT INTO `role_apis` VALUES (1, 103);
INSERT INTO `role_apis` VALUES (1, 104);
INSERT INTO `role_apis` VALUES (1, 105);
INSERT INTO `role_apis` VALUES (1, 106);
INSERT INTO `role_apis` VALUES (1, 107);
INSERT INTO `role_apis` VALUES (1, 108);
INSERT INTO `role_apis` VALUES (1, 109);
INSERT INTO `role_apis` VALUES (1, 110);
INSERT INTO `role_apis` VALUES (1, 111);
INSERT INTO `role_apis` VALUES (1, 112);
INSERT INTO `role_apis` VALUES (1, 113);
INSERT INTO `role_apis` VALUES (1, 116);
INSERT INTO `role_apis` VALUES (2, 117);
INSERT INTO `role_apis` VALUES (3, 117);
INSERT INTO `role_apis` VALUES (2, 118);
INSERT INTO `role_apis` VALUES (3, 118);
INSERT INTO `role_apis` VALUES (2, 119);
INSERT INTO `role_apis` VALUES (3, 119);
INSERT INTO `role_apis` VALUES (1, 120);
INSERT INTO `role_apis` VALUES (2, 120);
INSERT INTO `role_apis` VALUES (3, 120);
INSERT INTO `role_apis` VALUES (1, 121);
INSERT INTO `role_apis` VALUES (2, 121);
INSERT INTO `role_apis` VALUES (3, 121);
INSERT INTO `role_apis` VALUES (1, 122);
INSERT INTO `role_apis` VALUES (2, 122);
INSERT INTO `role_apis` VALUES (3, 122);
INSERT INTO `role_apis` VALUES (1, 123);
INSERT INTO `role_apis` VALUES (2, 123);
INSERT INTO `role_apis` VALUES (3, 123);
INSERT INTO `role_apis` VALUES (2, 124);
INSERT INTO `role_apis` VALUES (3, 124);
INSERT INTO `role_apis` VALUES (2, 125);
INSERT INTO `role_apis` VALUES (3, 125);
INSERT INTO `role_apis` VALUES (2, 126);
INSERT INTO `role_apis` VALUES (3, 126);
INSERT INTO `role_apis` VALUES (2, 127);
INSERT INTO `role_apis` VALUES (3, 127);
INSERT INTO `role_apis` VALUES (2, 128);
INSERT INTO `role_apis` VALUES (3, 128);
INSERT INTO `role_apis` VALUES (2, 129);
INSERT INTO `role_apis` VALUES (3, 129);
INSERT INTO `role_apis` VALUES (2, 130);
INSERT INTO `role_apis` VALUES (3, 130);
INSERT INTO `role_apis` VALUES (2, 131);
INSERT INTO `role_apis` VALUES (3, 131);
INSERT INTO `role_apis` VALUES (2, 132);
INSERT INTO `role_apis` VALUES (3, 132);
INSERT INTO `role_apis` VALUES (1, 134);
INSERT INTO `role_apis` VALUES (1, 135);
INSERT INTO `role_apis` VALUES (1, 137);
INSERT INTO `role_apis` VALUES (1, 138);
INSERT INTO `role_apis` VALUES (1, 139);
INSERT INTO `role_apis` VALUES (1, 140);
INSERT INTO `role_apis` VALUES (1, 141);
INSERT INTO `role_apis` VALUES (1, 142);
INSERT INTO `role_apis` VALUES (1, 145);
INSERT INTO `role_apis` VALUES (2, 145);
INSERT INTO `role_apis` VALUES (3, 145);
INSERT INTO `role_apis` VALUES (1, 146);
INSERT INTO `role_apis` VALUES (2, 146);
INSERT INTO `role_apis` VALUES (3, 146);
INSERT INTO `role_apis` VALUES (1, 147);
INSERT INTO `role_apis` VALUES (2, 147);
INSERT INTO `role_apis` VALUES (3, 147);
INSERT INTO `role_apis` VALUES (1, 150);
INSERT INTO `role_apis` VALUES (2, 150);
INSERT INTO `role_apis` VALUES (3, 150);
INSERT INTO `role_apis` VALUES (1, 151);
INSERT INTO `role_apis` VALUES (2, 151);
INSERT INTO `role_apis` VALUES (3, 151);
INSERT INTO `role_apis` VALUES (1, 152);
INSERT INTO `role_apis` VALUES (2, 152);
INSERT INTO `role_apis` VALUES (3, 152);
INSERT INTO `role_apis` VALUES (1, 153);
INSERT INTO `role_apis` VALUES (2, 153);
INSERT INTO `role_apis` VALUES (3, 153);
INSERT INTO `role_apis` VALUES (1, 154);
INSERT INTO `role_apis` VALUES (2, 154);
INSERT INTO `role_apis` VALUES (3, 154);
INSERT INTO `role_apis` VALUES (1, 155);
INSERT INTO `role_apis` VALUES (2, 155);
INSERT INTO `role_apis` VALUES (3, 155);
INSERT INTO `role_apis` VALUES (1, 156);
INSERT INTO `role_apis` VALUES (2, 156);
INSERT INTO `role_apis` VALUES (3, 156);
INSERT INTO `role_apis` VALUES (1, 157);
INSERT INTO `role_apis` VALUES (2, 157);
INSERT INTO `role_apis` VALUES (3, 157);
INSERT INTO `role_apis` VALUES (1, 158);
INSERT INTO `role_apis` VALUES (2, 158);
INSERT INTO `role_apis` VALUES (3, 158);
INSERT INTO `role_apis` VALUES (1, 159);
INSERT INTO `role_apis` VALUES (2, 159);
INSERT INTO `role_apis` VALUES (3, 159);
INSERT INTO `role_apis` VALUES (1, 160);
INSERT INTO `role_apis` VALUES (2, 160);
INSERT INTO `role_apis` VALUES (3, 160);
INSERT INTO `role_apis` VALUES (1, 161);
INSERT INTO `role_apis` VALUES (2, 161);
INSERT INTO `role_apis` VALUES (3, 161);
INSERT INTO `role_apis` VALUES (1, 162);
INSERT INTO `role_apis` VALUES (2, 162);
INSERT INTO `role_apis` VALUES (3, 162);
INSERT INTO `role_apis` VALUES (1, 163);
INSERT INTO `role_apis` VALUES (2, 163);
INSERT INTO `role_apis` VALUES (3, 163);
INSERT INTO `role_apis` VALUES (1, 164);
INSERT INTO `role_apis` VALUES (2, 164);
INSERT INTO `role_apis` VALUES (3, 164);
INSERT INTO `role_apis` VALUES (1, 165);
INSERT INTO `role_apis` VALUES (2, 165);
INSERT INTO `role_apis` VALUES (3, 165);
INSERT INTO `role_apis` VALUES (1, 166);
INSERT INTO `role_apis` VALUES (2, 166);
INSERT INTO `role_apis` VALUES (3, 166);
INSERT INTO `role_apis` VALUES (1, 167);
INSERT INTO `role_apis` VALUES (2, 167);
INSERT INTO `role_apis` VALUES (3, 167);
INSERT INTO `role_apis` VALUES (1, 168);
INSERT INTO `role_apis` VALUES (2, 168);
INSERT INTO `role_apis` VALUES (3, 168);
INSERT INTO `role_apis` VALUES (1, 169);
INSERT INTO `role_apis` VALUES (2, 169);
INSERT INTO `role_apis` VALUES (3, 169);
INSERT INTO `role_apis` VALUES (1, 171);
INSERT INTO `role_apis` VALUES (2, 171);
INSERT INTO `role_apis` VALUES (3, 171);
INSERT INTO `role_apis` VALUES (1, 172);
INSERT INTO `role_apis` VALUES (2, 172);
INSERT INTO `role_apis` VALUES (3, 172);
INSERT INTO `role_apis` VALUES (1, 178);
INSERT INTO `role_apis` VALUES (2, 178);
INSERT INTO `role_apis` VALUES (3, 178);
INSERT INTO `role_apis` VALUES (2, 179);
INSERT INTO `role_apis` VALUES (3, 179);
INSERT INTO `role_apis` VALUES (1, 180);
INSERT INTO `role_apis` VALUES (1, 181);
INSERT INTO `role_apis` VALUES (1, 182);
INSERT INTO `role_apis` VALUES (1, 183);
INSERT INTO `role_apis` VALUES (1, 184);
INSERT INTO `role_apis` VALUES (1, 185);
INSERT INTO `role_apis` VALUES (1, 187);
INSERT INTO `role_apis` VALUES (1, 194);
INSERT INTO `role_apis` VALUES (1, 195);
INSERT INTO `role_apis` VALUES (2, 195);
INSERT INTO `role_apis` VALUES (3, 195);
INSERT INTO `role_apis` VALUES (1, 196);
INSERT INTO `role_apis` VALUES (2, 196);
INSERT INTO `role_apis` VALUES (3, 196);
INSERT INTO `role_apis` VALUES (1, 197);
INSERT INTO `role_apis` VALUES (2, 197);
INSERT INTO `role_apis` VALUES (3, 197);
INSERT INTO `role_apis` VALUES (2, 198);
INSERT INTO `role_apis` VALUES (3, 198);
INSERT INTO `role_apis` VALUES (1, 199);
INSERT INTO `role_apis` VALUES (1, 200);
INSERT INTO `role_apis` VALUES (1, 201);
INSERT INTO `role_apis` VALUES (1, 202);
INSERT INTO `role_apis` VALUES (1, 203);
INSERT INTO `role_apis` VALUES (1, 204);
INSERT INTO `role_apis` VALUES (1, 205);
INSERT INTO `role_apis` VALUES (2, 206);
INSERT INTO `role_apis` VALUES (3, 206);
INSERT INTO `role_apis` VALUES (2, 207);
INSERT INTO `role_apis` VALUES (3, 207);
INSERT INTO `role_apis` VALUES (2, 208);
INSERT INTO `role_apis` VALUES (3, 208);
INSERT INTO `role_apis` VALUES (2, 209);
INSERT INTO `role_apis` VALUES (3, 209);
INSERT INTO `role_apis` VALUES (3, 210);
INSERT INTO `role_apis` VALUES (3, 211);
INSERT INTO `role_apis` VALUES (3, 212);
INSERT INTO `role_apis` VALUES (3, 213);
INSERT INTO `role_apis` VALUES (3, 214);
INSERT INTO `role_apis` VALUES (3, 215);
INSERT INTO `role_apis` VALUES (2, 218);
INSERT INTO `role_apis` VALUES (3, 218);

-- ----------------------------
-- Table structure for role_menus
-- ----------------------------
DROP TABLE IF EXISTS `role_menus`;
CREATE TABLE `role_menus`  (
  `sys_role_id` int UNSIGNED NOT NULL,
  `sys_menu_id` int UNSIGNED NOT NULL,
  PRIMARY KEY (`sys_role_id`, `sys_menu_id`) USING BTREE,
  INDEX `fk_role_menus_sys_menu`(`sys_menu_id` ASC) USING BTREE,
  CONSTRAINT `fk_role_menus_sys_menu` FOREIGN KEY (`sys_menu_id`) REFERENCES `sys_menus` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `fk_role_menus_sys_role` FOREIGN KEY (`sys_role_id`) REFERENCES `sys_roles` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of role_menus
-- ----------------------------
INSERT INTO `role_menus` VALUES (1, 1);
INSERT INTO `role_menus` VALUES (8, 1);
INSERT INTO `role_menus` VALUES (8, 2);
INSERT INTO `role_menus` VALUES (8, 3);
INSERT INTO `role_menus` VALUES (1, 4);
INSERT INTO `role_menus` VALUES (8, 4);
INSERT INTO `role_menus` VALUES (1, 5);
INSERT INTO `role_menus` VALUES (8, 5);
INSERT INTO `role_menus` VALUES (1, 6);
INSERT INTO `role_menus` VALUES (8, 6);
INSERT INTO `role_menus` VALUES (1, 7);
INSERT INTO `role_menus` VALUES (8, 7);
INSERT INTO `role_menus` VALUES (1, 8);
INSERT INTO `role_menus` VALUES (8, 8);
INSERT INTO `role_menus` VALUES (8, 9);
INSERT INTO `role_menus` VALUES (1, 13);
INSERT INTO `role_menus` VALUES (1, 14);

-- ----------------------------
-- Table structure for sys_apis
-- ----------------------------
DROP TABLE IF EXISTS `sys_apis`;
CREATE TABLE `sys_apis`  (
  `id` int UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) NULL DEFAULT NULL,
  `updated_at` datetime(3) NULL DEFAULT NULL,
  `deleted_at` datetime(3) NULL DEFAULT NULL,
  `parent_api_id` bigint UNSIGNED NULL DEFAULT NULL,
  `path` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `method` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `name` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `description` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `sort` int NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_sys_apis_deleted_at`(`deleted_at` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 220 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_apis
-- ----------------------------
INSERT INTO `sys_apis` VALUES (1, NULL, '2023-07-29 22:18:56.000', NULL, 0, '/', '', '根路径', '根路径', 1);
INSERT INTO `sys_apis` VALUES (2, NULL, '2024-08-27 02:37:37.667', NULL, 1, '/auth', '', '认证相关', '认证相关', 100);
INSERT INTO `sys_apis` VALUES (3, NULL, '2023-08-04 22:26:31.000', '2023-10-02 18:29:44.530', 1, '/mamage/problem', '', '题目管理', '题目管理', 200);
INSERT INTO `sys_apis` VALUES (4, NULL, '2023-08-04 22:26:39.000', '2023-10-02 18:29:51.336', 1, '/manage/bank', '', '题库管理', '题库管理', 300);
INSERT INTO `sys_apis` VALUES (5, NULL, '2023-08-04 22:24:01.000', '2023-08-04 22:26:47.000', 1, '', '', '权限管理', '权限管理', 400);
INSERT INTO `sys_apis` VALUES (6, NULL, '2023-07-29 22:27:24.000', '2023-08-04 22:26:47.000', 5, '/permisson/api', '', '接口管理', '接口管理', 410);
INSERT INTO `sys_apis` VALUES (7, NULL, NULL, '2023-08-04 22:26:47.000', 5, '/permissions/role', '', '角色管理', '角色管理', 500);
INSERT INTO `sys_apis` VALUES (9, '2023-07-29 20:21:12.000', '2023-07-29 20:21:12.000', '2023-07-29 20:26:35.000', 4, '/bank', 'aa', 'aaa', '', NULL);
INSERT INTO `sys_apis` VALUES (10, '2023-07-29 20:23:26.000', '2023-07-29 20:23:26.000', '2023-07-29 20:26:36.000', 4, '/bank', '', 'bbb', '', NULL);
INSERT INTO `sys_apis` VALUES (11, '2023-07-29 20:23:33.000', '2023-07-29 20:23:33.000', '2023-07-29 20:26:38.000', 4, '/bank', '', 'bbbc', '', NULL);
INSERT INTO `sys_apis` VALUES (12, '2023-08-04 22:03:40.000', '2023-08-04 22:03:40.000', '2023-08-04 22:03:52.000', 1, '/auth/register', '', '用户注册', '', NULL);
INSERT INTO `sys_apis` VALUES (13, '2023-08-04 22:04:04.000', '2024-05-18 11:48:45.846', NULL, 2, '/auth/register', 'post', '用户注册', '', NULL);
INSERT INTO `sys_apis` VALUES (14, '2023-08-04 22:05:13.000', '2023-08-04 22:05:13.000', NULL, 2, '/auth/login', 'post', '用户登录', '', NULL);
INSERT INTO `sys_apis` VALUES (15, '2023-08-04 22:06:49.000', '2023-10-02 16:01:11.049', NULL, 2, '/auth/code/send', 'post', '发送验证码', '', NULL);
INSERT INTO `sys_apis` VALUES (16, '2023-08-04 22:10:15.000', '2023-08-04 22:11:03.000', NULL, 2, '/auth/get/info', 'get', '获取用户信息', '', NULL);
INSERT INTO `sys_apis` VALUES (17, '2023-08-04 22:12:10.000', '2023-08-04 22:12:10.000', '2023-10-02 18:29:43.099', 3, '/manage/problem', 'post', '添加题目', '', NULL);
INSERT INTO `sys_apis` VALUES (18, '2023-08-04 22:12:20.000', '2023-08-04 22:12:39.000', '2023-10-02 18:29:43.279', 3, '/manage/problem/:id', 'get', '获取题目', '', NULL);
INSERT INTO `sys_apis` VALUES (19, '2023-08-04 22:13:21.000', '2023-08-04 22:13:21.000', '2023-10-02 18:29:43.458', 3, '/manage/problem', 'put', '更新题目', '', NULL);
INSERT INTO `sys_apis` VALUES (20, '2023-08-04 22:13:53.000', '2023-08-04 22:13:53.000', '2023-10-02 18:29:43.632', 3, '/manage/problem/:id', 'delete', '删除题目', '', NULL);
INSERT INTO `sys_apis` VALUES (21, '2023-08-04 22:14:29.000', '2023-08-04 22:14:29.000', '2023-10-02 18:29:43.796', 3, '/manage/problem/list/:page/pageSize', 'get', '读取题目列表', '', NULL);
INSERT INTO `sys_apis` VALUES (22, '2023-08-04 22:15:31.000', '2023-08-04 22:15:31.000', '2023-10-02 18:29:43.959', 3, '/manage/problem//file/download/:id', 'get', '题目文件下载', '', NULL);
INSERT INTO `sys_apis` VALUES (23, '2023-08-04 22:15:58.000', '2023-08-04 22:15:58.000', '2023-10-02 18:29:44.122', 3, '/manage/problem/file/download/template', 'get', '题目文件模板下载', '', NULL);
INSERT INTO `sys_apis` VALUES (24, '2023-08-04 22:17:09.000', '2023-08-04 22:17:09.000', '2023-10-02 18:29:44.285', 3, '/manage/problem/code/check/:code', 'get', '判断题目编号是否已存在', '', NULL);
INSERT INTO `sys_apis` VALUES (25, '2023-08-04 22:17:46.000', '2023-08-04 22:17:46.000', '2023-10-02 18:29:44.448', 3, '/manage/problem/enable', 'post', '设置题目启用', '', NULL);
INSERT INTO `sys_apis` VALUES (26, '2023-08-04 22:27:03.000', '2023-08-04 22:27:03.000', '2023-10-02 18:29:56.022', 1, '/manage/api', '', 'api管理', '', NULL);
INSERT INTO `sys_apis` VALUES (27, '2023-08-04 22:27:26.000', '2023-08-04 22:27:26.000', '2023-10-02 18:30:00.943', 1, '/manage/menu', '', '菜单管理', '', NULL);
INSERT INTO `sys_apis` VALUES (28, '2023-08-04 22:27:45.000', '2023-08-04 22:27:45.000', '2023-10-02 18:30:05.647', 1, '/manage/role', '', '角色管理', '', NULL);
INSERT INTO `sys_apis` VALUES (29, '2023-08-04 22:28:04.000', '2023-08-04 22:28:04.000', '2023-10-02 18:30:11.346', 1, '/manage/user', '', '用户管理', '', NULL);
INSERT INTO `sys_apis` VALUES (30, '2023-08-04 22:28:46.000', '2023-08-04 22:28:46.000', '2023-10-02 18:29:55.271', 26, '/manage/api/:id', 'get', '获取api', '', NULL);
INSERT INTO `sys_apis` VALUES (31, '2023-08-04 22:29:08.000', '2023-08-04 22:29:08.000', '2023-10-02 18:29:55.439', 26, '/manage/api', 'post', '添加api', '', NULL);
INSERT INTO `sys_apis` VALUES (32, '2023-08-04 22:29:16.000', '2023-08-04 22:31:44.000', '2023-10-02 18:29:55.604', 26, '/manage/api', 'put', '修改api', '', NULL);
INSERT INTO `sys_apis` VALUES (33, '2023-08-04 22:29:36.000', '2023-08-04 22:29:36.000', '2023-10-02 18:29:55.773', 26, '/manage/api/:id', 'delete', '删除api', '', NULL);
INSERT INTO `sys_apis` VALUES (34, '2023-08-04 22:30:08.000', '2023-08-04 22:30:08.000', '2023-10-02 18:29:55.939', 26, '/manage/api/tree', 'get', '获取api树', '', NULL);
INSERT INTO `sys_apis` VALUES (35, '2023-08-04 22:30:52.000', '2023-08-04 22:30:52.000', '2023-10-02 18:30:00.165', 27, '/manage/menu/:id', 'get', '获取菜单', '', NULL);
INSERT INTO `sys_apis` VALUES (36, '2023-08-04 22:31:09.000', '2023-08-04 22:31:09.000', '2023-10-02 18:30:00.359', 27, '/manage/menu', 'post', '添加菜单', '', NULL);
INSERT INTO `sys_apis` VALUES (37, '2023-08-04 22:31:26.000', '2023-08-04 22:31:26.000', '2023-10-02 18:30:00.525', 27, '/manage/menu', 'put', '修改菜单', '', NULL);
INSERT INTO `sys_apis` VALUES (38, '2023-08-04 22:32:03.000', '2023-08-04 22:32:03.000', '2023-10-02 18:30:00.692', 27, '/manage/menu/:id', 'delete', '删除菜单', '', NULL);
INSERT INTO `sys_apis` VALUES (39, '2023-08-04 22:32:19.000', '2023-08-04 22:32:19.000', '2023-10-02 18:30:00.859', 27, '/manage/menu/tree', 'get', '获取菜单树', '', NULL);
INSERT INTO `sys_apis` VALUES (40, '2023-08-04 22:33:11.000', '2023-08-04 22:33:11.000', '2023-10-02 18:30:04.248', 28, '/manage/role/:id', 'get', '获取角色', '', NULL);
INSERT INTO `sys_apis` VALUES (41, '2023-08-04 22:33:37.000', '2023-08-04 22:33:37.000', '2023-10-02 18:30:04.413', 28, '/manage/role', 'post', '添加角色', '', NULL);
INSERT INTO `sys_apis` VALUES (42, '2023-08-04 22:33:54.000', '2023-08-04 22:33:54.000', '2023-10-02 18:30:04.578', 28, '/manage/role', 'put', '修改角色', '', NULL);
INSERT INTO `sys_apis` VALUES (43, '2023-08-04 22:34:04.000', '2023-08-04 22:34:04.000', '2023-10-02 18:30:04.742', 28, '/manage/role/:id', 'delete', '删除角色', '', NULL);
INSERT INTO `sys_apis` VALUES (44, '2023-08-04 22:34:27.000', '2023-08-04 22:34:27.000', '2023-10-02 18:30:04.905', 28, '/manage/role/list', 'get', '获取角色列表', '', NULL);
INSERT INTO `sys_apis` VALUES (45, '2023-08-04 22:34:59.000', '2023-08-04 22:34:59.000', '2023-10-02 18:30:05.071', 28, '/manage/role/api/:id', 'get', '获取角色api的id列表', '', NULL);
INSERT INTO `sys_apis` VALUES (46, '2023-08-04 22:35:20.000', '2023-08-04 22:35:20.000', '2023-10-02 18:30:05.236', 28, '/manage/role/menu/:id', 'get', '获取角色菜单的id列表', '', NULL);
INSERT INTO `sys_apis` VALUES (47, '2023-08-04 22:35:56.000', '2023-08-04 22:35:56.000', '2023-10-02 18:30:05.402', 28, '/manage/role/api', 'put', '更新角色api', '', NULL);
INSERT INTO `sys_apis` VALUES (48, '2023-08-04 22:36:15.000', '2023-08-04 22:36:15.000', '2023-10-02 18:30:05.564', 28, '/manage/role/menu', 'put', '更新角色菜单', '', NULL);
INSERT INTO `sys_apis` VALUES (49, '2023-08-04 22:37:03.000', '2023-08-04 22:37:03.000', '2023-10-02 18:30:10.069', 29, '/manage/user/:id', 'get', '获取用户', '', NULL);
INSERT INTO `sys_apis` VALUES (50, '2023-08-04 22:37:23.000', '2023-08-04 22:37:23.000', '2023-10-02 18:30:10.247', 29, '/manage/user', 'post', '添加用户', '', NULL);
INSERT INTO `sys_apis` VALUES (51, '2023-08-04 22:37:32.000', '2023-08-04 22:37:32.000', '2023-10-02 18:30:10.411', 29, '/manage/user', 'put', '更新用户', '', NULL);
INSERT INTO `sys_apis` VALUES (52, '2023-08-04 22:37:46.000', '2023-08-04 22:37:46.000', '2023-10-02 18:30:10.577', 29, '/manage/user/:id', 'delete', '删除用户', '', NULL);
INSERT INTO `sys_apis` VALUES (53, '2023-08-04 22:38:02.000', '2023-08-04 22:38:02.000', '2023-10-02 18:30:10.743', 29, '/manage/user/list', 'get', '获取用户列表', '', NULL);
INSERT INTO `sys_apis` VALUES (54, '2023-08-04 22:38:30.000', '2023-08-04 22:38:30.000', '2023-10-02 18:30:10.909', 29, '/manage/user/role/:id', 'get', '获取用户关联的角色id列表', '', NULL);
INSERT INTO `sys_apis` VALUES (55, '2023-08-04 22:38:52.000', '2023-08-04 22:38:52.000', '2023-10-02 18:30:11.080', 29, '/manage/user/role', 'put', '更新用户角色', '', NULL);
INSERT INTO `sys_apis` VALUES (56, '2023-08-04 22:39:20.000', '2023-08-04 22:39:20.000', '2023-10-02 18:30:11.259', 29, '/manage/user/simpleRole/list', 'get', '获取角色列表', '', NULL);
INSERT INTO `sys_apis` VALUES (57, '2023-10-02 17:15:07.719', '2023-10-02 17:15:07.719', NULL, 1, '/account', '', '账号相关', '', NULL);
INSERT INTO `sys_apis` VALUES (58, '2023-10-02 17:15:39.538', '2023-10-02 17:15:39.538', NULL, 57, '/account/info', 'get', '获取账号信息', '', NULL);
INSERT INTO `sys_apis` VALUES (59, '2023-10-02 17:16:19.321', '2023-10-02 17:16:19.321', NULL, 57, '/account', 'put', '修改账号信息', '', NULL);
INSERT INTO `sys_apis` VALUES (60, '2023-10-02 17:16:41.536', '2023-10-02 17:16:41.536', NULL, 57, '/account/password/reset', 'post', '重置密码', '', NULL);
INSERT INTO `sys_apis` VALUES (61, '2023-10-02 17:17:01.119', '2023-10-02 17:17:01.119', NULL, 57, '/account/password', 'post', '修改密码', '', NULL);
INSERT INTO `sys_apis` VALUES (62, '2023-10-02 17:17:24.459', '2023-10-02 17:17:24.459', NULL, 57, '/avatar', 'post', '上传头像', '', NULL);
INSERT INTO `sys_apis` VALUES (63, '2023-10-02 17:17:47.494', '2023-10-02 17:17:47.494', NULL, 57, '/avatar/user/:avatarName', 'get', '读取头像', '', NULL);
INSERT INTO `sys_apis` VALUES (64, '2023-10-02 17:18:21.100', '2023-10-02 17:18:21.100', NULL, 1, '/ping', 'get', 'ping', '', NULL);
INSERT INTO `sys_apis` VALUES (65, '2023-10-02 17:19:08.572', '2023-10-02 17:19:15.058', NULL, 1, '/manage', '', '管理员', '', NULL);
INSERT INTO `sys_apis` VALUES (66, '2023-10-02 17:19:31.498', '2023-10-02 17:19:31.498', NULL, 1, '/', '', '普通用户', '', NULL);
INSERT INTO `sys_apis` VALUES (67, '2023-10-02 17:20:07.414', '2023-10-02 17:20:07.414', NULL, 65, '/manage/api', '', '接口管理', '', NULL);
INSERT INTO `sys_apis` VALUES (68, '2023-10-02 17:20:31.203', '2023-10-02 17:20:31.203', NULL, 67, '/manage/api/:id', 'get', '读取接口', '', NULL);
INSERT INTO `sys_apis` VALUES (69, '2023-10-02 17:20:50.163', '2023-10-02 17:20:50.163', NULL, 67, '/manage/api', 'post', '添加接口', '', NULL);
INSERT INTO `sys_apis` VALUES (70, '2023-10-02 17:21:00.294', '2023-10-02 17:21:00.294', NULL, 67, '/manage/api', 'put', '修改接口', '', NULL);
INSERT INTO `sys_apis` VALUES (71, '2023-10-02 17:21:16.525', '2023-10-02 17:21:16.525', NULL, 67, '/manage/api/:id', 'delete', '删除接口', '', NULL);
INSERT INTO `sys_apis` VALUES (72, '2023-10-02 17:21:38.739', '2023-10-02 17:21:38.739', NULL, 67, '/manage/api/tree', 'get', '获取api树', '', NULL);
INSERT INTO `sys_apis` VALUES (73, '2023-10-02 17:22:04.386', '2023-10-02 17:22:04.386', NULL, 65, '/manage/menu', '', '菜单管理', '', NULL);
INSERT INTO `sys_apis` VALUES (74, '2023-10-02 17:22:19.851', '2023-10-02 17:22:19.851', NULL, 73, '/manage/menu/:id', 'get', '读取菜单', '', NULL);
INSERT INTO `sys_apis` VALUES (75, '2023-10-02 17:22:38.115', '2023-10-02 17:22:38.115', NULL, 73, '/manage/menu', 'post', '添加菜单', '', NULL);
INSERT INTO `sys_apis` VALUES (76, '2023-10-02 17:22:49.268', '2023-10-02 17:22:49.268', NULL, 73, '/manage/menu', 'put', '修改菜单', '', NULL);
INSERT INTO `sys_apis` VALUES (77, '2023-10-02 17:23:06.353', '2023-10-02 17:23:06.353', NULL, 73, '/manage/menu/:id', 'delete', '删除菜单', '', NULL);
INSERT INTO `sys_apis` VALUES (78, '2023-10-02 17:23:25.335', '2023-10-02 17:23:25.335', NULL, 73, '/manage/menu/tree', 'get', '读取菜单树', '', NULL);
INSERT INTO `sys_apis` VALUES (79, '2023-10-02 17:25:21.267', '2023-10-02 17:25:21.267', NULL, 65, '/manage/role', '', '角色管理', '', NULL);
INSERT INTO `sys_apis` VALUES (80, '2023-10-02 17:25:41.171', '2023-10-02 17:25:41.171', NULL, 79, '/manage/role/:id', 'get', '读取角色', '', NULL);
INSERT INTO `sys_apis` VALUES (81, '2023-10-02 17:25:53.763', '2023-10-02 17:25:53.763', NULL, 79, '/manage/role', 'post', '添加角色', '', NULL);
INSERT INTO `sys_apis` VALUES (82, '2023-10-02 17:26:13.795', '2023-10-02 17:26:13.795', NULL, 79, '/manage/role', 'put', '更新角色', '', NULL);
INSERT INTO `sys_apis` VALUES (83, '2023-10-02 17:26:31.113', '2023-10-02 17:26:31.113', NULL, 79, '/manage/role/:id', 'delete', '删除角色', '', NULL);
INSERT INTO `sys_apis` VALUES (84, '2023-10-02 17:26:53.589', '2023-10-02 17:26:53.589', NULL, 79, '/manage/role/list', 'get', '获取角色列表', '', NULL);
INSERT INTO `sys_apis` VALUES (85, '2023-10-02 17:27:34.653', '2023-10-02 17:29:11.994', NULL, 79, '/manage/role/api/:id', 'get', '读取角色接口id列表', '', NULL);
INSERT INTO `sys_apis` VALUES (86, '2023-10-02 17:27:55.521', '2023-10-02 17:27:55.521', NULL, 79, '/manage/role/menu/:id', 'get', '读取角色菜单id列表', '', NULL);
INSERT INTO `sys_apis` VALUES (87, '2023-10-02 17:28:20.032', '2023-10-02 17:28:20.032', NULL, 79, '/manage/role/api', 'put', '修改角色拥有的api', '', NULL);
INSERT INTO `sys_apis` VALUES (88, '2023-10-02 17:28:36.289', '2023-10-02 17:28:36.289', NULL, 79, '/manage/role/menu', 'put', '修改角色拥有的菜单', '', NULL);
INSERT INTO `sys_apis` VALUES (89, '2023-10-02 17:29:35.123', '2023-10-02 17:29:35.123', NULL, 65, '/manage/user', '', '用户管理', '', NULL);
INSERT INTO `sys_apis` VALUES (90, '2023-10-02 17:29:50.844', '2023-10-02 17:29:50.844', NULL, 89, '/manage/user/:id', 'get', '读取用户', '', NULL);
INSERT INTO `sys_apis` VALUES (91, '2023-10-02 17:30:04.772', '2023-10-02 17:30:04.772', NULL, 89, '/manage/user', 'post', '添加用户', '', NULL);
INSERT INTO `sys_apis` VALUES (92, '2023-10-02 17:30:16.885', '2023-10-02 17:30:16.885', NULL, 89, '/manage/user', 'put', '修改用户', '', NULL);
INSERT INTO `sys_apis` VALUES (93, '2023-10-02 17:30:33.782', '2023-10-02 17:30:33.782', NULL, 89, '/manage/user/:id', 'delete', '删除用户', '', NULL);
INSERT INTO `sys_apis` VALUES (94, '2023-10-02 17:30:48.740', '2023-10-02 17:30:48.740', NULL, 89, '/manage/user/list', 'get', '读取用户列表', '', NULL);
INSERT INTO `sys_apis` VALUES (95, '2023-10-02 17:31:05.096', '2023-10-02 17:31:05.096', NULL, 89, '/manage/user/role/:id', 'get', '读取用户关联的角色', '', NULL);
INSERT INTO `sys_apis` VALUES (96, '2023-10-02 17:31:38.055', '2023-10-02 17:31:52.054', NULL, 89, '/manage/user/role', 'put', '更新用户关联的角色列表', '', NULL);
INSERT INTO `sys_apis` VALUES (97, '2023-10-02 17:32:14.982', '2023-10-02 17:32:14.982', NULL, 89, '/manage/user/simpleRole/list', 'get', '读取用户的简单列表', '', NULL);
INSERT INTO `sys_apis` VALUES (98, '2023-10-02 17:32:38.843', '2023-10-02 17:32:38.843', NULL, 65, '/manage/problemBank', '', '题库管理', '', NULL);
INSERT INTO `sys_apis` VALUES (99, '2023-10-02 17:33:36.325', '2023-10-02 17:33:36.325', NULL, 98, '/manage/problemBank/:id', 'get', '读取题库', '', NULL);
INSERT INTO `sys_apis` VALUES (100, '2023-10-02 17:33:48.430', '2023-10-02 17:33:48.430', NULL, 98, '/manage/problemBank', 'post', '添加题库', '', NULL);
INSERT INTO `sys_apis` VALUES (101, '2023-10-02 17:34:03.561', '2023-10-02 17:34:03.561', NULL, 98, '/manage/problemBank', 'put', '修改题库', '', NULL);
INSERT INTO `sys_apis` VALUES (102, '2023-10-02 17:34:28.731', '2023-10-02 17:34:28.731', NULL, 98, '/manage/problemBank/:id/:forceDelete', 'delete', '删除题库', '', NULL);
INSERT INTO `sys_apis` VALUES (103, '2023-10-02 17:35:03.098', '2023-10-02 17:35:03.098', NULL, 98, '/manage/problemBank/list', 'get', '读取题库列表', '', NULL);
INSERT INTO `sys_apis` VALUES (104, '2023-10-02 17:35:19.667', '2023-10-02 17:35:19.667', NULL, 98, '/manage/problemBank/simple/list', 'get', '读取题库简单列表', '', NULL);
INSERT INTO `sys_apis` VALUES (105, '2023-10-02 17:35:45.140', '2023-10-02 17:35:45.140', NULL, 98, '/manage/problemBank/icon', 'post', '上传题库图片', '', NULL);
INSERT INTO `sys_apis` VALUES (106, '2023-10-02 17:35:58.886', '2023-10-02 17:35:58.886', NULL, 98, '/manage/problemBank/icon/:iconName', 'get', '读取题库图片', '', NULL);
INSERT INTO `sys_apis` VALUES (107, '2023-10-02 17:36:22.392', '2023-10-02 17:36:22.392', NULL, 65, '/manage/problem', '', '题目管理', '', NULL);
INSERT INTO `sys_apis` VALUES (108, '2023-10-02 17:36:49.502', '2023-10-02 17:36:49.502', NULL, 107, '/manage/problem/:id', 'get', '读取题目', '', NULL);
INSERT INTO `sys_apis` VALUES (109, '2023-10-02 17:37:06.117', '2023-10-02 17:37:06.117', NULL, 107, '/manage/problem', 'post', '添加题目', '', NULL);
INSERT INTO `sys_apis` VALUES (110, '2023-10-02 17:37:16.137', '2023-10-02 17:37:16.137', NULL, 107, '/manage/problem', 'put', '修改题目', '', NULL);
INSERT INTO `sys_apis` VALUES (111, '2023-10-02 17:37:31.042', '2023-10-02 17:37:31.042', NULL, 107, '/manage/problem/:id', 'delete', '删除题目', '', NULL);
INSERT INTO `sys_apis` VALUES (112, '2023-10-02 17:37:51.563', '2023-10-02 17:37:51.563', NULL, 107, '/manage/problem/code/check/:number', 'get', '检测题目编号是否重复', '', NULL);
INSERT INTO `sys_apis` VALUES (113, '2023-10-02 17:38:10.259', '2023-10-02 17:38:10.259', NULL, 107, '/manage/problem/list', 'get', '读取题目列表', '', NULL);
INSERT INTO `sys_apis` VALUES (114, '2023-10-02 17:38:31.397', '2023-10-02 17:38:31.397', '2023-12-24 20:35:49.644', 107, '/manage/problem/file/download/:id', 'get', '下载题目文件', '', NULL);
INSERT INTO `sys_apis` VALUES (115, '2023-10-02 17:38:45.195', '2023-10-02 17:38:45.195', '2023-12-24 20:35:38.075', 107, '/manage/problem/file/download/template', 'get', '下载题目模板文件', '', NULL);
INSERT INTO `sys_apis` VALUES (116, '2023-10-02 17:39:04.922', '2023-10-02 17:39:04.922', NULL, 107, '/manage/problem/enable', 'post', '使题目可用', '', NULL);
INSERT INTO `sys_apis` VALUES (117, '2023-10-02 18:00:09.723', '2023-10-02 18:00:09.723', NULL, 66, '/judge', '', '判题相关', '', NULL);
INSERT INTO `sys_apis` VALUES (118, '2023-10-02 18:00:24.648', '2023-10-02 18:00:24.648', NULL, 117, '/judge/submit', 'post', '提交', '', NULL);
INSERT INTO `sys_apis` VALUES (119, '2023-10-02 18:00:41.138', '2023-10-02 18:00:41.138', NULL, 117, '/judge/execute', 'post', '执行', '', NULL);
INSERT INTO `sys_apis` VALUES (120, '2023-10-02 18:00:57.941', '2023-10-02 18:00:57.941', NULL, 66, '/problem', '', '题目信息', '', NULL);
INSERT INTO `sys_apis` VALUES (121, '2023-10-02 18:01:15.228', '2023-10-02 18:01:15.228', NULL, 120, '/problem/list', 'get', '获取题目列表', '', NULL);
INSERT INTO `sys_apis` VALUES (122, '2023-10-02 18:01:27.071', '2023-10-02 18:01:27.071', NULL, 120, '/problem/:number', 'get', '获取题目信息', '', NULL);
INSERT INTO `sys_apis` VALUES (123, '2023-10-02 18:01:47.338', '2024-06-23 23:56:49.056', NULL, 120, '/problem/code/:number/:language', 'get', '获取用户代码', '', NULL);
INSERT INTO `sys_apis` VALUES (124, '2023-10-02 18:02:05.908', '2023-10-02 18:02:05.908', NULL, 66, '/submission', '', '提交信息', '', NULL);
INSERT INTO `sys_apis` VALUES (125, '2023-10-02 18:02:31.844', '2023-10-02 18:02:31.844', NULL, 124, '/submission/active/year', 'get', '获取用户有提交的年份', '', NULL);
INSERT INTO `sys_apis` VALUES (126, '2023-10-02 18:02:51.894', '2023-10-02 18:02:51.894', NULL, 124, '/submission/active/map/:year', 'get', '获取用户的活动图', '', NULL);
INSERT INTO `sys_apis` VALUES (127, '2023-10-02 18:03:07.570', '2023-10-02 18:03:07.570', NULL, 124, '/submission/list', 'get', '获取用户提交列表', '', NULL);
INSERT INTO `sys_apis` VALUES (128, '2023-10-06 23:45:20.504', '2023-10-06 23:45:20.504', NULL, 66, '/problemBank', '', '题库信息', '', NULL);
INSERT INTO `sys_apis` VALUES (129, '2023-10-06 23:45:42.231', '2023-10-06 23:45:42.231', NULL, 128, '/problemBank/all', 'get', '读取用户可见的所有题库', '', NULL);
INSERT INTO `sys_apis` VALUES (130, '2023-10-08 21:46:12.570', '2023-10-08 22:09:12.918', NULL, 128, '/problemBank/:id', 'get', '获取题库信息', '', NULL);
INSERT INTO `sys_apis` VALUES (131, '2023-10-09 08:58:58.562', '2023-10-09 08:58:58.562', NULL, 117, '/judge/code/:problemID', 'get', '获取用户代码', '', NULL);
INSERT INTO `sys_apis` VALUES (132, '2023-10-09 08:59:21.810', '2023-10-09 08:59:21.810', NULL, 117, '/judge/code', 'post', '保存用户代码', '', NULL);
INSERT INTO `sys_apis` VALUES (133, '2023-10-21 19:36:16.899', '2023-10-21 19:36:16.899', '2023-10-21 19:36:21.277', 1, '/sb', 'sb', 'sb', 'sb', NULL);
INSERT INTO `sys_apis` VALUES (134, '2023-12-24 20:38:44.780', '2023-12-24 20:38:44.780', NULL, 107, '/manage/problem/case', '', '用例管理', '', NULL);
INSERT INTO `sys_apis` VALUES (135, '2023-12-24 20:39:21.998', '2023-12-24 20:39:21.998', NULL, 134, '/manage/problem/case', 'post', '添加用例', '', NULL);
INSERT INTO `sys_apis` VALUES (136, '2023-12-24 20:39:34.286', '2023-12-24 20:39:34.286', '2023-12-24 20:39:43.316', 116, '/manage/problem/enable', 'put', '修改用例', '', NULL);
INSERT INTO `sys_apis` VALUES (137, '2023-12-24 20:39:52.822', '2023-12-24 20:39:52.822', NULL, 134, '/manage/problem/case', 'put', '修改用例', '', NULL);
INSERT INTO `sys_apis` VALUES (138, '2023-12-24 20:40:14.828', '2023-12-24 20:40:14.828', NULL, 134, '/manage/problem/case/:id', 'delete', '删除用例', '', NULL);
INSERT INTO `sys_apis` VALUES (139, '2023-12-24 20:40:33.006', '2023-12-24 20:40:33.006', NULL, 134, '/manage/problem/case/:id', 'get', '读取用例', '', NULL);
INSERT INTO `sys_apis` VALUES (140, '2023-12-24 20:40:46.676', '2023-12-24 20:40:46.676', NULL, 134, '/manage/problem/case/list', 'get', '读取用例列表', '', NULL);
INSERT INTO `sys_apis` VALUES (141, '2023-12-25 00:30:31.357', '2023-12-25 00:30:31.357', NULL, 134, '/manage/problem/case/name/new', 'get', '生成用例名称', '', NULL);
INSERT INTO `sys_apis` VALUES (142, '2023-12-25 00:30:47.626', '2023-12-25 00:30:47.626', NULL, 134, '/manage/problem/case/name/check', 'get', '检测用例名称', '', NULL);
INSERT INTO `sys_apis` VALUES (143, '2024-03-17 18:39:55.636', '2024-03-17 18:39:55.636', '2024-03-17 19:27:29.156', 1, '/ws', 'get', 'websocket', '', NULL);
INSERT INTO `sys_apis` VALUES (144, '2024-03-17 19:29:26.624', '2024-03-17 19:45:27.055', '2024-03-31 14:57:18.810', 1, '/ws/:token', 'get', 'websocket', '', NULL);
INSERT INTO `sys_apis` VALUES (145, '2024-03-31 14:57:36.788', '2024-03-31 14:57:36.788', NULL, 66, '/debug', '', '调试接口', '', NULL);
INSERT INTO `sys_apis` VALUES (146, '2024-03-31 14:58:05.419', '2024-03-31 14:58:05.419', NULL, 145, '/debug/start', 'post', '启动调试', '', NULL);
INSERT INTO `sys_apis` VALUES (147, '2024-03-31 14:58:47.262', '2024-03-31 14:58:47.262', NULL, 145, '/debug/sse/:key', 'get', '监控调试事件', '', NULL);
INSERT INTO `sys_apis` VALUES (148, '2024-03-31 14:59:03.566', '2024-03-31 14:59:03.566', '2024-04-15 00:46:15.172', 145, '/debug/next', 'post', 'next', '', NULL);
INSERT INTO `sys_apis` VALUES (149, '2024-03-31 14:59:20.008', '2024-03-31 14:59:20.008', '2024-04-15 00:46:19.323', 145, '/debug/step', 'post', 'step', '', NULL);
INSERT INTO `sys_apis` VALUES (150, '2024-03-31 14:59:36.809', '2024-03-31 14:59:36.809', NULL, 145, '/debug/continue', 'post', 'continue', '', NULL);
INSERT INTO `sys_apis` VALUES (151, '2024-03-31 15:00:14.676', '2024-03-31 15:00:14.676', NULL, 145, '/debug/sendToConsole', 'post', '输入数据到用户程序', '', NULL);
INSERT INTO `sys_apis` VALUES (152, '2024-03-31 15:00:34.929', '2024-03-31 15:00:34.929', NULL, 145, '/debug/addBreakpoints', 'post', '添加断点', '', NULL);
INSERT INTO `sys_apis` VALUES (153, '2024-03-31 15:00:48.437', '2024-03-31 15:00:48.437', NULL, 145, '/debug/removeBreakpoints', 'post', '移除断点', '', NULL);
INSERT INTO `sys_apis` VALUES (154, '2024-03-31 15:01:15.639', '2024-11-03 20:45:28.395', NULL, 145, '/debug/terminate', 'post', 'terminate', '', NULL);
INSERT INTO `sys_apis` VALUES (155, '2024-04-13 01:09:09.234', '2024-04-13 01:09:39.009', NULL, 145, '/debug/session/create', 'post', '创建debugsession', '', NULL);
INSERT INTO `sys_apis` VALUES (156, '2024-04-15 00:46:31.527', '2024-04-15 00:46:31.527', NULL, 145, '/debug/step/in', 'post', 'stepIn', '', NULL);
INSERT INTO `sys_apis` VALUES (157, '2024-04-15 00:46:44.565', '2024-04-15 00:46:44.565', NULL, 145, '/debug/step/out', 'post', 'stepOut', '', NULL);
INSERT INTO `sys_apis` VALUES (158, '2024-04-15 00:46:54.364', '2024-04-15 00:46:54.364', NULL, 145, '/debug/step/over', 'post', 'stepOver', '', NULL);
INSERT INTO `sys_apis` VALUES (159, '2024-06-09 18:42:09.932', '2024-06-09 18:42:09.932', NULL, 145, '/debug/stackTrace', 'post', '获取栈帧', '', NULL);
INSERT INTO `sys_apis` VALUES (160, '2024-06-09 18:42:48.834', '2024-06-09 18:42:48.834', NULL, 145, '/debug/frame/variables', 'post', '获取栈帧中的局部变量', '', NULL);
INSERT INTO `sys_apis` VALUES (161, '2024-06-09 18:43:16.695', '2024-06-09 18:43:16.695', NULL, 145, '/debug/variables', 'post', '根据引用获取局部变量', '', NULL);
INSERT INTO `sys_apis` VALUES (162, '2024-06-23 23:57:11.621', '2024-11-29 01:50:15.572', NULL, 120, '/problem/code/template/:language', 'get', '获取题目模板', '', NULL);
INSERT INTO `sys_apis` VALUES (163, '2024-06-23 23:57:30.246', '2024-06-23 23:57:30.246', NULL, 120, '/problem/code/save', 'post', '保存用户代码', '', NULL);
INSERT INTO `sys_apis` VALUES (164, '2024-06-24 00:36:36.439', '2024-06-24 00:36:36.439', NULL, 120, '/problem/code/:number', 'get', '根据题目id获取用户代码', '', NULL);
INSERT INTO `sys_apis` VALUES (165, '2024-08-08 02:06:07.521', '2024-10-27 17:01:49.419', NULL, 66, '/visual', '', '可视化接口', '', NULL);
INSERT INTO `sys_apis` VALUES (166, '2024-08-08 02:06:51.248', '2024-10-27 17:02:03.716', NULL, 165, '/visual/debug/struct', 'post', '结构体导向可视化数据', '', NULL);
INSERT INTO `sys_apis` VALUES (167, '2024-08-08 02:07:32.249', '2024-10-27 17:02:08.811', NULL, 165, '/visual/template/:type', 'get', '获取可视化描述模板', '', NULL);
INSERT INTO `sys_apis` VALUES (168, '2024-08-08 02:07:58.772', '2024-10-27 17:02:16.378', NULL, 165, '/visual/template/list', 'get', '获取可视化模板列表', '', NULL);
INSERT INTO `sys_apis` VALUES (169, '2024-08-25 03:00:55.781', '2024-10-27 17:02:23.378', NULL, 165, '/visual/debug/variable', 'post', '变量导向可视化数据结构', '', NULL);
INSERT INTO `sys_apis` VALUES (170, '2024-08-27 02:27:07.515', '2024-08-27 02:27:07.515', '2024-08-27 02:27:12.346', 1, '/', '', '测试1', '', NULL);
INSERT INTO `sys_apis` VALUES (171, '2024-09-15 01:53:55.108', '2024-09-15 01:53:55.108', NULL, 1, '/common', '', 'common', '', NULL);
INSERT INTO `sys_apis` VALUES (172, '2024-09-15 01:54:11.288', '2024-09-15 01:54:11.288', NULL, 171, '/common/getURL', 'get', '获取资源URL', '', NULL);
INSERT INTO `sys_apis` VALUES (173, '2024-10-21 01:33:12.443', '2024-10-21 01:33:12.443', '2024-10-21 01:38:45.515', 171, '/common/program/language', 'get', '获取编程语言', '', NULL);
INSERT INTO `sys_apis` VALUES (174, '2024-10-27 16:50:29.510', '2024-10-27 16:50:29.510', '2025-01-04 20:39:24.972', 165, '/visual/setting', '', '可视化设置', '', NULL);
INSERT INTO `sys_apis` VALUES (175, '2024-10-27 16:50:29.959', '2024-10-27 16:50:29.959', '2024-10-27 16:50:49.443', 165, '/visual/setting', '', '可视化设置', '', NULL);
INSERT INTO `sys_apis` VALUES (176, '2024-10-27 16:51:27.773', '2024-10-27 16:52:00.439', '2025-01-04 20:39:24.738', 174, '/visual/setting/save', 'post', '保存可视化设置', '', NULL);
INSERT INTO `sys_apis` VALUES (177, '2024-10-27 16:51:53.004', '2024-10-27 17:59:35.754', '2025-01-04 20:39:24.853', 174, '/visual/setting/:problemID/:language', 'get', '读取可视化设置', '', NULL);
INSERT INTO `sys_apis` VALUES (178, '2024-11-29 01:50:56.769', '2024-11-29 01:50:56.769', NULL, 165, '/visual/document', 'get', '获取可视化说明文档', '', NULL);
INSERT INTO `sys_apis` VALUES (179, '2024-12-23 01:35:34.412', '2024-12-23 01:35:54.112', NULL, 124, '/submission/add/remark', 'post', '添加备注', '添加备注', NULL);
INSERT INTO `sys_apis` VALUES (180, '2025-01-04 20:40:08.917', '2025-01-04 20:40:24.809', NULL, 65, '/manage/visual/document', '', '可视化教程文档管理', '', NULL);
INSERT INTO `sys_apis` VALUES (181, '2025-01-04 20:46:32.286', '2025-01-04 20:46:32.286', NULL, 180, '/manage/visual/document/directory', 'get', '获取可视化文档目录', '', NULL);
INSERT INTO `sys_apis` VALUES (182, '2025-01-04 20:47:10.295', '2025-01-04 20:47:24.049', NULL, 180, '/manage/visual/document/:id', 'get', '获取可视化文档', '', NULL);
INSERT INTO `sys_apis` VALUES (183, '2025-01-04 20:47:51.423', '2025-01-04 20:47:51.423', NULL, 180, '/manage/visual/document', 'post', '添加可视化文档', '', NULL);
INSERT INTO `sys_apis` VALUES (184, '2025-01-04 20:48:16.816', '2025-01-04 20:48:16.816', NULL, 180, '/manage/visual/document', 'put', '更新可视化文档', '', NULL);
INSERT INTO `sys_apis` VALUES (185, '2025-01-04 20:48:35.891', '2025-01-04 20:48:35.891', NULL, 180, '/manage/visual/document/:id', 'delete', '删除可视化文档', '', NULL);
INSERT INTO `sys_apis` VALUES (186, '2025-01-04 20:49:02.596', '2025-01-04 20:49:02.596', '2025-01-08 22:21:56.895', 180, '/manage/visual/document/code/languages/:documentID', 'get', '获取可视化文档支持的语言', '', NULL);
INSERT INTO `sys_apis` VALUES (187, '2025-01-04 20:49:27.155', '2025-01-18 17:43:04.390', NULL, 180, '/manage/visual/document/directory', 'post', '更新可视化文档的目录', '', NULL);
INSERT INTO `sys_apis` VALUES (188, '2025-01-04 20:50:04.074', '2025-01-04 20:50:04.074', '2025-01-08 22:21:50.820', 180, '/manage/visual/document/code/:documentID/:language', 'get', '获取可视化文档中某个语言的代码配置', '', NULL);
INSERT INTO `sys_apis` VALUES (189, '2025-01-04 20:50:34.999', '2025-01-04 20:50:34.999', '2025-01-08 22:21:47.296', 180, '/manage/visual/document/code', 'post', '添加可视化文档的代码', '', NULL);
INSERT INTO `sys_apis` VALUES (190, '2025-01-04 20:50:54.564', '2025-01-04 20:50:54.564', '2025-01-08 22:21:43.526', 180, '/manage/visual/document/code', 'put', '更新可视化文档的代码', '', NULL);
INSERT INTO `sys_apis` VALUES (191, '2025-01-04 20:51:22.678', '2025-01-04 20:51:22.678', '2025-01-08 22:22:06.538', 180, '/manage/visual/document/:id', 'delete', '删除可视化文档的代码', '', NULL);
INSERT INTO `sys_apis` VALUES (192, '2025-01-07 23:31:57.790', '2025-01-07 23:31:57.790', '2025-01-08 22:21:34.416', 180, '/manage/visual/document/title', 'put', '更新可视化标题', '', NULL);
INSERT INTO `sys_apis` VALUES (193, '2025-01-07 23:32:24.310', '2025-01-07 23:32:24.310', '2025-01-08 22:21:31.187', 180, '/manage/visual/document/enable', 'put', '设置可视化文档可用状态', '', NULL);
INSERT INTO `sys_apis` VALUES (194, '2025-01-18 20:36:16.912', '2025-01-18 20:36:16.912', NULL, 107, '/manage/problem/file/upload', 'post', '文件上传', '', NULL);
INSERT INTO `sys_apis` VALUES (195, '2025-01-19 01:24:28.847', '2025-01-19 01:24:28.847', NULL, 66, '/learn/visual/document', '', '可视化教学', '', NULL);
INSERT INTO `sys_apis` VALUES (196, '2025-01-19 01:24:52.120', '2025-01-19 01:24:52.120', NULL, 195, '/learn/visual/document/directory', 'get', '获取文档目录', '', NULL);
INSERT INTO `sys_apis` VALUES (197, '2025-01-19 01:25:15.088', '2025-01-19 01:25:15.088', NULL, 195, '/learn/visual/document/:id', 'get', '获取可视化文档', '', NULL);
INSERT INTO `sys_apis` VALUES (198, '2025-02-26 01:46:27.094', '2025-02-26 01:46:27.094', NULL, 145, '/debug/setBreakpoints', 'post', '设置断点', '设置断点', NULL);
INSERT INTO `sys_apis` VALUES (199, '2025-04-01 23:20:12.699', '2025-04-02 00:11:32.220', NULL, 180, '/manage/visual/document/directory/:bankID', 'get', '获取可视化文档目录（新）', '', NULL);
INSERT INTO `sys_apis` VALUES (200, '2025-04-01 23:22:53.276', '2025-04-01 23:22:53.276', NULL, 65, '/manage/visual/document/bank', '', '可视化教程文档库管理', '', NULL);
INSERT INTO `sys_apis` VALUES (201, '2025-04-01 23:23:19.535', '2025-04-01 23:23:19.535', NULL, 200, '/manage/visual/document/bank', 'post', '添加知识库', '', NULL);
INSERT INTO `sys_apis` VALUES (202, '2025-04-01 23:23:36.600', '2025-04-01 23:23:36.600', NULL, 200, '/manage/visual/document/bank', 'put', '更新知识库', '', NULL);
INSERT INTO `sys_apis` VALUES (203, '2025-04-01 23:23:55.773', '2025-04-01 23:23:55.773', NULL, 200, '/manage/visual/document/bank/:id', 'delete', '删除知识库', '', NULL);
INSERT INTO `sys_apis` VALUES (204, '2025-04-01 23:24:07.184', '2025-04-01 23:24:07.184', NULL, 200, '/manage/visual/document/bank/all', 'get', '获取所有知识库', '', NULL);
INSERT INTO `sys_apis` VALUES (205, '2025-04-01 23:24:28.243', '2025-04-01 23:24:28.243', NULL, 200, '/manage/visual/document/bank/:id', 'get', '读取知识库信息', '', NULL);
INSERT INTO `sys_apis` VALUES (206, '2025-04-02 23:48:13.459', '2025-04-02 23:48:13.459', NULL, 195, '/learn/visual/document/directory/:bankID', 'get', '获取文档目录（新）', '', NULL);
INSERT INTO `sys_apis` VALUES (207, '2025-04-02 23:50:44.993', '2025-04-02 23:50:44.993', NULL, 195, '/learn/visual/document/bank/all', 'get', '获取所有可视化文档库', '', NULL);
INSERT INTO `sys_apis` VALUES (208, '2025-04-03 00:47:06.432', '2025-04-03 00:47:06.432', NULL, 195, '/learn/visual/document/bank/:bankID', 'get', '获取可视化文档库', '', NULL);
INSERT INTO `sys_apis` VALUES (209, '2025-07-03 02:10:25.541', '2025-07-03 02:10:25.541', NULL, 165, '/visual/debug/description/:id', 'get', '获取可视化配置', '', NULL);
INSERT INTO `sys_apis` VALUES (210, '2025-07-31 00:55:46.910', '2025-07-31 00:55:52.629', NULL, 66, '/user/savedCode', '', '保存用户代码', '', NULL);
INSERT INTO `sys_apis` VALUES (211, '2025-07-31 00:56:10.147', '2025-07-31 00:56:22.473', NULL, 210, '/user/savedCode', 'post', '创建用户代码存储', '', NULL);
INSERT INTO `sys_apis` VALUES (212, '2025-07-31 00:56:37.382', '2025-07-31 00:56:37.382', NULL, 210, '/user/savedCode', 'put', '更新用户保存代码', '', NULL);
INSERT INTO `sys_apis` VALUES (213, '2025-07-31 00:56:49.965', '2025-07-31 00:57:30.307', NULL, 210, '/user/savedCode/list', 'get', '获取用户保存的代码列表', '', NULL);
INSERT INTO `sys_apis` VALUES (214, '2025-07-31 00:57:52.541', '2025-07-31 00:57:52.541', NULL, 210, '/user/savedCode/:id', 'get', '根据ID获取用户保存的代码详情', '', NULL);
INSERT INTO `sys_apis` VALUES (215, '2025-07-31 00:58:15.605', '2025-07-31 00:58:15.605', NULL, 210, '/user/savedCode/:id', 'delete', '删除用户保存的代码', '', NULL);
INSERT INTO `sys_apis` VALUES (216, '2025-07-31 00:58:52.157', '2025-07-31 00:58:52.157', '2025-08-03 16:42:08.191', 210, '/user/savedCode/sort', 'put', '更新单个代码的排序顺序', '', NULL);
INSERT INTO `sys_apis` VALUES (217, '2025-07-31 00:59:12.742', '2025-07-31 00:59:12.742', '2025-08-03 16:42:04.798', 210, '/user/savedCode/batch-sort', 'put', '批量更新排序顺序', '', NULL);
INSERT INTO `sys_apis` VALUES (218, '2026-01-10 02:14:20.697', '2026-01-10 02:14:32.933', NULL, 165, '/visual/debug/array', 'post', '数组可视化', '', NULL);
INSERT INTO `sys_apis` VALUES (219, '2026-01-10 02:18:33.836', '2026-01-10 02:18:33.836', NULL, 165, '/visual/debug/array2d', 'post', '二位数组可视化', '', NULL);

-- ----------------------------
-- Table structure for sys_menus
-- ----------------------------
DROP TABLE IF EXISTS `sys_menus`;
CREATE TABLE `sys_menus`  (
  `id` int UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) NULL DEFAULT NULL,
  `updated_at` datetime(3) NULL DEFAULT NULL,
  `deleted_at` datetime(3) NULL DEFAULT NULL,
  `parent_Menu_id` bigint UNSIGNED NULL DEFAULT NULL,
  `name` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `code` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `description` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_sys_menus_deleted_at`(`deleted_at` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 15 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_menus
-- ----------------------------
INSERT INTO `sys_menus` VALUES (1, NULL, '2023-07-29 22:27:32.000', NULL, 0, '全部数据', 'manage', NULL);
INSERT INTO `sys_menus` VALUES (2, '2023-07-29 22:06:53.000', '2023-10-21 19:36:53.202', NULL, 1, '题目管理', 'problem', '题目管理');
INSERT INTO `sys_menus` VALUES (3, '2023-08-21 23:00:47.848', '2023-08-21 23:00:47.848', NULL, 1, '题库管理', 'bank', '题库管理');
INSERT INTO `sys_menus` VALUES (4, '2023-08-21 23:01:13.459', '2023-08-21 23:01:13.459', NULL, 1, '权限管理', 'permissions', '权限管理');
INSERT INTO `sys_menus` VALUES (5, '2023-08-21 23:01:29.982', '2024-05-18 11:49:13.446', NULL, 4, '接口管理', 'api', '接口管理');
INSERT INTO `sys_menus` VALUES (6, '2023-08-21 23:01:46.512', '2023-08-21 23:01:46.512', NULL, 4, '菜单管理', 'menu', '菜单管理');
INSERT INTO `sys_menus` VALUES (7, '2023-08-21 23:02:04.506', '2023-08-21 23:02:04.506', NULL, 4, '角色管理', 'role', '角色管理');
INSERT INTO `sys_menus` VALUES (8, '2023-08-22 10:22:17.100', '2024-08-27 02:39:27.225', NULL, 4, '用户管理', 'user', '用户管理');
INSERT INTO `sys_menus` VALUES (9, '2023-09-29 11:16:59.709', '2023-09-29 11:16:59.709', NULL, 3, '管理题库中的题目', 'bank-problem', '用于管理题库中的题目');
INSERT INTO `sys_menus` VALUES (10, '2023-09-29 11:56:20.099', '2023-09-29 11:56:20.099', '2023-09-29 12:01:23.181', 3, '题库管理主页面', 'bank-default', '');
INSERT INTO `sys_menus` VALUES (11, '2023-09-29 15:27:50.382', '2023-09-29 15:27:50.382', '2023-09-29 15:27:52.995', 3, 'aaa', 'aaa', '');
INSERT INTO `sys_menus` VALUES (12, '2023-10-21 19:37:00.453', '2023-10-21 19:37:00.453', '2023-10-21 19:37:03.585', 1, 'sb', 'sb', 'sb');
INSERT INTO `sys_menus` VALUES (13, '2025-01-04 22:02:42.685', '2025-04-01 23:27:06.707', NULL, 1, '可视化教程管理', 'visual-document-bank', '');
INSERT INTO `sys_menus` VALUES (14, '2025-04-01 23:27:29.803', '2025-04-01 23:27:29.803', NULL, 13, '可视化教程文档编辑', 'visual-document', '');

-- ----------------------------
-- Table structure for sys_roles
-- ----------------------------
DROP TABLE IF EXISTS `sys_roles`;
CREATE TABLE `sys_roles`  (
  `id` int UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) NULL DEFAULT NULL,
  `updated_at` datetime(3) NULL DEFAULT NULL,
  `deleted_at` datetime(3) NULL DEFAULT NULL,
  `name` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `alias` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `description` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_sys_roles_deleted_at`(`deleted_at` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_roles
-- ----------------------------
INSERT INTO `sys_roles` VALUES (1, '2023-07-30 09:51:45.000', '2025-04-01 23:28:04.883', NULL, 'admin', NULL, '超级管理员');
INSERT INTO `sys_roles` VALUES (2, '2023-10-01 10:39:48.000', '2026-01-10 02:15:23.763', NULL, '游客用户', NULL, '游客用户');
INSERT INTO `sys_roles` VALUES (3, '2023-10-02 18:10:54.000', '2026-01-10 02:15:44.209', NULL, '普通用户', NULL, '普通用户');
INSERT INTO `sys_roles` VALUES (4, '2023-07-30 11:18:28.000', '2023-07-30 11:18:32.000', '2023-10-02 18:03:28.243', '用户管理员', NULL, '用户管理员');
INSERT INTO `sys_roles` VALUES (5, '2023-07-30 11:19:48.000', '2023-07-30 11:19:52.000', '2023-10-02 18:03:21.902', '接口管理员', NULL, '接口管理员');
INSERT INTO `sys_roles` VALUES (6, '2023-07-30 11:20:11.000', '2023-07-30 11:20:15.000', '2023-10-02 18:03:24.603', '角色管理员', NULL, '角色管理员');
INSERT INTO `sys_roles` VALUES (7, '2023-07-30 11:20:34.000', '2023-07-30 11:20:37.000', '2023-10-02 18:11:14.075', '普通用户', NULL, '普通用户');
INSERT INTO `sys_roles` VALUES (8, '2023-07-30 11:21:40.000', '2023-09-30 17:44:27.736', '2023-10-02 18:03:32.724', '游客用户', NULL, '游客用户');
INSERT INTO `sys_roles` VALUES (15, '2023-10-21 19:37:27.508', '2023-10-21 19:37:27.508', '2023-10-21 19:37:32.090', '11', NULL, '11');
INSERT INTO `sys_roles` VALUES (16, '2024-05-18 11:48:02.555', '2024-05-18 11:48:09.036', '2024-05-18 11:48:12.255', 'test111', NULL, 'test');

-- ----------------------------
-- Table structure for sys_users
-- ----------------------------
DROP TABLE IF EXISTS `sys_users`;
CREATE TABLE `sys_users`  (
  `id` int UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) NULL DEFAULT NULL,
  `updated_at` datetime(3) NULL DEFAULT NULL,
  `deleted_at` datetime(3) NULL DEFAULT NULL,
  `login_name` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `password` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `username` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `email` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `phone` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `avatar` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `remark` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `enable` tinyint(1) NULL DEFAULT NULL,
  `introduction` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `sex` bigint NULL DEFAULT NULL,
  `birth_day` datetime(3) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_sys_users_deleted_at`(`deleted_at` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 52 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_users
-- ----------------------------
INSERT INTO `sys_users` VALUES (1, NULL, '2024-09-16 15:56:03.237', NULL, 'niliu', '$2a$10$wiKV1OekhawSNP.VaRogk.SAzVsG3WzBhp8Kv0V23sV28ztX98/5O', 'niliu', '3210477146@qq.com', '18122587239', '/avatar/user/1db8407a-7401-11ef-8b0d-0242ac110002.cefba86f49b48f3740b0ce3a50b7660d_1.jpg', NULL, NULL, '111', 1, '1901-01-24 08:00:00.000');

-- ----------------------------
-- Table structure for user_codes
-- ----------------------------
DROP TABLE IF EXISTS `user_codes`;
CREATE TABLE `user_codes`  (
  `id` bigint UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) NULL DEFAULT NULL,
  `updated_at` datetime(3) NULL DEFAULT NULL,
  `deleted_at` datetime(3) NULL DEFAULT NULL,
  `problem_id` bigint UNSIGNED NULL DEFAULT NULL,
  `user_id` bigint UNSIGNED NULL DEFAULT NULL,
  `language` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `code` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `visual_setting` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_user_codes_deleted_at`(`deleted_at` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 102 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;


-- ----------------------------
-- Table structure for user_roles
-- ----------------------------
DROP TABLE IF EXISTS `user_roles`;
CREATE TABLE `user_roles`  (
  `sys_user_id` int UNSIGNED NOT NULL,
  `sys_role_id` int UNSIGNED NOT NULL,
  PRIMARY KEY (`sys_user_id`, `sys_role_id`) USING BTREE,
  INDEX `fk_user_roles_sys_role`(`sys_role_id` ASC) USING BTREE,
  CONSTRAINT `fk_user_roles_sys_role` FOREIGN KEY (`sys_role_id`) REFERENCES `sys_roles` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `fk_user_roles_sys_user` FOREIGN KEY (`sys_user_id`) REFERENCES `sys_users` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of user_roles
-- ----------------------------
INSERT INTO `user_roles` VALUES (1, 1);
INSERT INTO `user_roles` VALUES (1, 3);

-- ----------------------------
-- Table structure for user_saved_codes
-- ----------------------------
DROP TABLE IF EXISTS `user_saved_codes`;
CREATE TABLE `user_saved_codes`  (
  `id` bigint UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) NULL DEFAULT NULL,
  `updated_at` datetime(3) NULL DEFAULT NULL,
  `deleted_at` datetime(3) NULL DEFAULT NULL,
  `user_id` bigint UNSIGNED NOT NULL,
  `document_id` bigint UNSIGNED NULL DEFAULT NULL,
  `language` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `code` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `remark` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `sort_order` bigint NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_user_saved_codes_deleted_at`(`deleted_at` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 14 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;


-- ----------------------------
-- Table structure for visual_document_banks
-- ----------------------------
DROP TABLE IF EXISTS `visual_document_banks`;
CREATE TABLE `visual_document_banks`  (
  `id` bigint UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) NULL DEFAULT NULL,
  `updated_at` datetime(3) NULL DEFAULT NULL,
  `deleted_at` datetime(3) NULL DEFAULT NULL,
  `name` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `description` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `creator_id` bigint UNSIGNED NULL DEFAULT NULL,
  `enable` tinyint(1) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_visual_document_banks_deleted_at`(`deleted_at` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of visual_document_banks
-- ----------------------------
INSERT INTO `visual_document_banks` VALUES (1, '2025-04-01 23:48:38.499', '2025-04-10 23:55:27.082', NULL, 'C语言教学', '', 1, 1);
INSERT INTO `visual_document_banks` VALUES (2, '2025-04-02 00:06:24.572', '2025-04-02 00:06:24.572', '2025-04-02 00:06:27.789', '', '', 1, 0);
INSERT INTO `visual_document_banks` VALUES (3, '2025-04-02 23:32:09.133', '2025-04-02 23:32:09.133', NULL, '算法', '', 1, 0);
INSERT INTO `visual_document_banks` VALUES (4, '2025-04-10 23:55:42.707', '2025-08-24 18:25:35.835', NULL, '数据结构与算法', '', 1, 1);

-- ----------------------------
-- Table structure for visual_document_codes
-- ----------------------------
DROP TABLE IF EXISTS `visual_document_codes`;
CREATE TABLE `visual_document_codes`  (
  `id` bigint UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) NULL DEFAULT NULL,
  `updated_at` datetime(3) NULL DEFAULT NULL,
  `deleted_at` datetime(3) NULL DEFAULT NULL,
  `document_id` bigint UNSIGNED NULL DEFAULT NULL,
  `code` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `language` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `breakpoints` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `visual_setting` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_visual_document_codes_deleted_at`(`deleted_at` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 298 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of visual_document_codes
-- ----------------------------
INSERT INTO `visual_document_codes` VALUES (1, '2025-01-17 02:18:39.247', '2025-01-17 02:18:39.247', '2025-01-17 02:28:26.209', 3, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '');
INSERT INTO `visual_document_codes` VALUES (2, '2025-01-17 02:28:26.271', '2025-01-17 02:28:26.271', '2025-01-17 02:28:38.933', 3, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '\"\"');
INSERT INTO `visual_document_codes` VALUES (3, '2025-01-17 02:28:38.994', '2025-01-17 02:28:38.994', '2025-01-17 02:29:32.990', 3, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '\"\"');
INSERT INTO `visual_document_codes` VALUES (4, '2025-01-17 02:29:33.053', '2025-01-17 02:29:33.053', '2025-01-17 02:30:00.774', 3, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '\"\"');
INSERT INTO `visual_document_codes` VALUES (5, '2025-01-17 02:30:00.837', '2025-01-17 02:30:00.837', '2025-01-17 02:36:41.497', 3, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '\"\"');
INSERT INTO `visual_document_codes` VALUES (6, '2025-01-17 02:30:00.899', '2025-01-17 02:30:00.899', '2025-01-17 02:36:41.497', 3, 'import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNextInt()) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(a + b);\n        }\n    }\n}', 'java', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (7, '2025-01-17 02:36:41.560', '2025-01-17 02:36:41.560', '2025-01-17 02:36:47.306', 3, 'import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNextInt()) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(a + b);\n        }\n    }\n}', 'java', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (8, '2025-01-17 02:36:41.622', '2025-01-17 02:36:41.622', '2025-01-17 02:36:47.306', 3, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (9, '2025-01-17 02:36:41.687', '2025-01-17 02:36:41.687', '2025-01-17 02:36:47.306', 3, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (10, '2025-01-17 02:36:47.368', '2025-01-17 02:36:47.368', '2025-01-17 02:38:01.290', 3, 'import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNextInt()) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(a + b);\n        }\n    }\n}', 'java', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (11, '2025-01-17 02:36:47.430', '2025-01-17 02:36:47.430', '2025-01-17 02:38:01.290', 3, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (12, '2025-01-17 02:36:47.572', '2025-01-17 02:36:47.572', '2025-01-17 02:38:01.290', 3, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (13, '2025-01-17 02:38:01.356', '2025-01-17 02:38:01.356', '2025-01-17 02:41:15.079', 3, 'import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNextInt()) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(a + b);\n        }\n    }\n}', 'java', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (14, '2025-01-17 02:38:01.420', '2025-01-17 02:38:01.420', '2025-01-17 02:41:15.079', 3, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (15, '2025-01-17 02:38:01.483', '2025-01-17 02:38:01.483', '2025-01-17 02:41:15.079', 3, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (16, '2025-01-17 02:41:15.140', '2025-01-17 02:41:15.140', '2025-01-18 02:07:06.180', 3, 'import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNextInt()) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(a + b);\n        }\n    }\n}', 'java', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (17, '2025-01-17 02:41:15.202', '2025-01-17 02:41:15.202', '2025-01-18 02:07:06.180', 3, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (18, '2025-01-17 02:41:15.263', '2025-01-17 02:41:15.263', '2025-01-18 02:07:06.180', 3, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (19, '2025-01-19 18:33:27.219', '2025-01-19 18:33:27.219', '2025-01-19 18:33:29.176', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (20, '2025-01-19 18:33:29.240', '2025-01-19 18:33:29.240', '2025-01-19 18:34:20.553', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (21, '2025-01-19 18:34:20.830', '2025-01-19 18:34:20.830', '2025-01-19 20:25:58.287', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (22, '2025-01-19 20:25:58.354', '2025-01-19 20:25:58.354', '2025-01-19 20:29:44.967', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (23, '2025-01-19 20:25:58.423', '2025-01-19 20:25:58.423', '2025-01-19 20:29:44.967', 33, 'import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNextInt()) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(a + b);\n        }\n    }\n}', 'java', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (24, '2025-01-19 20:29:45.030', '2025-01-19 20:29:45.030', '2025-01-19 23:16:59.352', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (25, '2025-01-19 20:29:45.091', '2025-01-19 20:29:45.091', '2025-01-19 23:16:59.352', 33, 'import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNextInt()) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(a + b);\n        }\n    }\n}', 'java', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr234\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (26, '2025-01-19 23:16:59.470', '2025-01-19 23:16:59.470', '2025-01-19 23:23:52.970', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (27, '2025-01-19 23:16:59.570', '2025-01-19 23:16:59.570', '2025-01-19 23:23:52.970', 33, 'import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNextInt()) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(a + b);\n        }\n    }\n}', 'java', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr234\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (28, '2025-01-19 23:23:53.037', '2025-01-19 23:23:53.037', '2025-01-19 23:33:53.499', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (29, '2025-01-19 23:23:53.109', '2025-01-19 23:23:53.109', '2025-01-19 23:33:53.499', 33, 'import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNextInt()) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(a + b);\n        }\n    }\n}', 'java', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr234\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (30, '2025-01-19 23:33:53.564', '2025-01-19 23:33:53.564', '2025-01-19 23:37:37.593', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (31, '2025-01-19 23:33:53.628', '2025-01-19 23:33:53.628', '2025-01-19 23:37:37.593', 33, 'import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNextInt()) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(a + b);\n        }\n    }\n}', 'java', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr234\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (32, '2025-01-19 23:37:37.659', '2025-01-19 23:37:37.659', '2025-01-19 23:40:32.030', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (33, '2025-01-19 23:37:37.724', '2025-01-19 23:37:37.724', '2025-01-19 23:40:32.030', 33, 'import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNextInt()) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(a + b);\n        }\n    }\n}', 'java', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr234\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (34, '2025-01-19 23:40:32.094', '2025-01-19 23:40:32.094', '2025-01-20 01:57:27.961', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (35, '2025-01-19 23:40:32.157', '2025-01-19 23:40:32.157', '2025-01-20 01:57:27.961', 33, 'import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNextInt()) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(a + b);\n        }\n    }\n}', 'java', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr234\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (36, '2025-01-20 01:57:28.027', '2025-01-20 01:57:28.027', '2025-01-20 02:08:19.487', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (37, '2025-01-20 02:08:19.551', '2025-01-20 02:08:19.551', '2025-01-20 02:13:16.284', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (38, '2025-01-20 02:13:16.352', '2025-01-20 02:13:16.352', '2025-01-20 02:31:45.879', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (39, '2025-01-20 02:31:45.941', '2025-01-20 02:31:45.941', '2025-01-20 02:41:38.576', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (40, '2025-01-20 02:41:38.638', '2025-01-20 02:41:38.638', '2025-01-20 02:51:38.729', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (41, '2025-01-20 02:51:38.791', '2025-01-20 02:51:38.791', '2025-01-20 02:54:21.592', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (42, '2025-01-20 02:54:21.655', '2025-01-20 02:54:21.655', '2025-01-21 00:55:15.189', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (43, '2025-01-21 00:55:15.343', '2025-01-21 00:55:15.343', '2025-01-21 00:58:45.864', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (44, '2025-01-21 00:58:45.956', '2025-01-21 00:58:45.956', '2025-01-21 01:38:32.070', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (45, '2025-01-21 01:38:32.151', '2025-01-21 01:38:32.151', '2025-01-21 01:40:50.618', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (46, '2025-01-21 01:40:50.773', '2025-01-21 01:40:50.773', '2025-01-21 01:58:03.800', 33, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (47, '2025-01-21 01:58:03.878', '2025-01-21 01:58:03.878', '2025-01-21 01:58:11.912', 33, 'package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 定义一个数组\n    var arr [3]int\n    arr[0] = 1\n    arr[1] = 2\n    arr[2] = 3\n    fmt.Println(\"Array:\", arr)\n\n    // 定义一个切片, len = 3, cap = 6\n    slice := make([]int, 3, 6)\n    fmt.Println(\"Slice:\", slice)\n    fmt.Printf(\"Slice 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n\n    // 向切片添加元素，触发扩容\n    slice = append(slice, 4)\n	slice = append(slice, 5)\n	slice = append(slice, 6)\n	fmt.Printf(\"Slice容量已满 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n	slice = append(slice, 7)\n	fmt.Printf(\"Slice扩容 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n}', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (48, '2025-01-21 01:58:11.990', '2025-01-21 01:58:11.990', '2025-02-11 00:34:14.184', 33, 'package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 定义一个数组\n    var arr [3]int\n    arr[0] = 1\n    arr[1] = 2\n    arr[2] = 3\n    fmt.Println(\"Array:\", arr)\n\n    // 定义一个切片, len = 3, cap = 6\n    slice := make([]int, 3, 6)\n    fmt.Println(\"Slice:\", slice)\n    fmt.Printf(\"Slice 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n\n    // 向切片添加元素，触发扩容\n    slice = append(slice, 4)\n	slice = append(slice, 5)\n	slice = append(slice, 6)\n	fmt.Printf(\"Slice容量已满 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n	slice = append(slice, 7)\n	fmt.Printf(\"Slice扩容 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n}', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"\"]}}');
INSERT INTO `visual_document_codes` VALUES (49, '2025-01-21 02:24:46.922', '2025-01-21 02:24:46.922', '2025-01-21 02:55:34.914', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (50, '2025-01-21 02:55:34.975', '2025-01-21 02:55:34.975', '2025-01-21 02:57:02.297', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (51, '2025-01-21 02:57:02.358', '2025-01-21 02:57:02.358', '2025-01-23 01:16:37.769', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (52, '2025-01-23 01:16:37.826', '2025-01-23 01:16:37.826', '2025-01-23 01:29:09.277', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (53, '2025-01-23 01:29:09.335', '2025-01-23 01:29:09.335', '2025-01-23 01:31:05.417', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (54, '2025-01-23 01:31:05.473', '2025-01-23 01:31:05.473', '2025-01-23 01:57:42.711', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (55, '2025-01-23 01:57:42.766', '2025-01-23 01:57:42.766', '2025-01-24 01:38:18.180', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (56, '2025-01-24 01:38:18.244', '2025-01-24 01:38:18.244', '2025-01-24 01:38:52.571', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (57, '2025-01-24 01:38:52.636', '2025-01-24 01:38:52.636', '2025-01-24 01:39:27.564', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (58, '2025-01-24 01:39:27.629', '2025-01-24 01:39:27.629', '2025-01-24 01:39:49.562', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\n\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left <= right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid - 1\n		} else {\n			return mid\n		}\n	}\n	return -1\n}', 'go', '[14,18,20,22]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (59, '2025-01-24 01:39:49.628', '2025-01-24 01:39:49.628', '2025-01-24 01:42:08.680', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\n\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left <= right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid - 1\n		} else {\n			return mid\n		}\n	}\n	return -1\n}', 'go', '[14,18,20,22]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (60, '2025-01-24 01:42:08.745', '2025-01-24 01:42:08.745', '2025-01-25 23:49:09.371', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\n\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left <= right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid - 1\n		} else {\n			return mid\n		}\n	}\n	return -1\n}', 'go', '[14,18,20,22]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"nums\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (61, '2025-01-25 23:49:10.227', '2025-01-25 23:49:10.227', '2025-01-25 23:54:44.615', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\n\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left <= right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid - 1\n		} else {\n			return mid\n		}\n	}\n	return -1\n}', 'go', '[14,18,20,22]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"nums\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (62, '2025-01-25 23:54:45.445', '2025-01-25 23:54:45.445', '2025-01-26 00:10:11.454', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\n\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left <= right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid - 1\n		} else {\n			return mid\n		}\n	}\n	return -1\n}', 'go', '[14,18,20,22]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"nums\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (63, '2025-01-26 00:10:11.512', '2025-01-26 00:10:11.512', '2025-01-27 00:17:21.330', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\n\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left <= right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid - 1\n		} else {\n			return mid\n		}\n	}\n	return -1\n}', 'go', '[14,18,20,22]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"nums\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (64, '2025-01-27 00:17:21.391', '2025-01-27 00:17:21.391', '2025-02-11 00:36:26.044', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\n\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left <= right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid - 1\n		} else {\n			return mid\n		}\n	}\n	return -1\n}', 'go', '[14,18,20,22]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"nums\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (65, '2025-01-27 00:49:22.532', '2025-01-27 00:49:22.532', '2025-01-27 01:04:24.455', 40, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (66, '2025-01-27 00:49:29.794', '2025-01-27 00:49:29.794', NULL, 41, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (67, '2025-01-27 01:04:24.517', '2025-01-27 01:04:24.517', '2025-02-11 00:36:06.708', 40, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (68, '2025-02-09 23:59:21.460', '2025-02-09 23:59:21.460', '2025-02-10 00:05:29.083', 39, 'package main\nimport (\n	\"fmt\"\n)\n\ntype LinkNode struct {\n	Val int\n	Next *LinkNode\n}\n\nfunc main() {\n	header := BuildLinkList([]int{1, 2, 4, 6, 9})\n    // 删除1节点和6节点\n    Delete(header, 1)\n    Delete(header, 6)\n    // 在4节点后插入5节点\n    Insert(header, 4, 5)\n    // 打印\n    Print(header)\n}\n\n// 构建链表\nfunc BuildLinkList(arr []int) *LinkNode{\n    var header *LinkNode\n    var tail *LinkNode\n    for _, v := range arr {\n        node := &LinkNode {\n            Val: v,\n        }\n        if header == nil {\n            header = node\n            tail = node\n        } else {\n            tail.Next = node\n            tail = tail.Next\n        }\n    }\n    return header\n}\n\n// 删除节点\nfunc Delete(header *LinkNode, target int) *LinkNode {\n    var prev *LinkNode\n    node := header\n    for node != nil {\n        prev = node\n        node = node.Next\n    }\n    if node != nil {\n        if prev == nil {\n            header = header.Next\n        } else {\n            prev.Next = node.Next\n        }\n    }\n    return header\n}\n\n// 打印节点\nfunc Print(header *LinkNode) {\n    node := header\n    for node != nil {\n        fmt.Println(node)\n        node = node.Next\n    }\n}\n\n// 插入节点，在a节点末尾插入一个b节点\nfunc Insert(header *LinkNode, a int, b int) {\n    node := header\n    for node != nil && node.Val != a {\n        node = node.Next\n    }\n    if node != nil {\n        next := node.Next\n        node.Next = &LinkNode{\n            Val: b,\n            Next: next,\n        }\n    }\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"LinkNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (69, '2025-02-10 00:05:29.141', '2025-02-10 00:05:29.141', '2025-02-10 00:06:54.296', 39, 'package main\nimport (\n	\"fmt\"\n)\n\ntype LinkNode struct {\n	Val int\n	Next *LinkNode\n}\n\nfunc main() {\n	header := BuildLinkList([]int{1, 2, 4, 6, 9})\n    // 删除1节点和6节点\n    header = Delete(header, 1)\n    header = Delete(header, 6)\n    // 在4节点后插入5节点\n    Insert(header, 4, 5)\n    // 打印\n    Print(header)\n}\n\n// 构建链表\nfunc BuildLinkList(arr []int) *LinkNode{\n    var header *LinkNode\n    var tail *LinkNode\n    for _, v := range arr {\n        node := &LinkNode {\n            Val: v,\n        }\n        if header == nil {\n            header = node\n            tail = node\n        } else {\n            tail.Next = node\n            tail = tail.Next\n        }\n    }\n    return header\n}\n\n// 删除节点\nfunc Delete(header *LinkNode, target int) *LinkNode {\n    var prev *LinkNode\n    node := header\n    for node != nil && node.Val != target{\n        prev = node\n        node = node.Next\n    }\n    if node != nil {\n        if prev == nil {\n            header = header.Next\n        } else {\n            prev.Next = node.Next\n        }\n    }\n    return header\n}\n\n// 打印节点\nfunc Print(header *LinkNode) {\n    node := header\n    for node != nil {\n        fmt.Println(node.Val)\n        node = node.Next\n    }\n}\n\n// 插入节点，在a节点末尾插入一个b节点\nfunc Insert(header *LinkNode, a int, b int) {\n    node := header\n    for node != nil && node.Val != a {\n        node = node.Next\n    }\n    if node != nil {\n        next := node.Next\n        node.Next = &LinkNode{\n            Val: b,\n            Next: next,\n        }\n    }\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"LinkNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (70, '2025-02-10 00:06:54.354', '2025-02-10 00:06:54.354', '2025-02-10 00:51:35.777', 39, 'package main\nimport (\n	\"fmt\"\n)\n\ntype LinkNode struct {\n	Val int\n	Next *LinkNode\n}\n\nfunc main() {\n	header := BuildLinkList([]int{1, 2, 4, 6, 9})\n    // 删除1节点和6节点\n    header = Delete(header, 1)\n    header = Delete(header, 6)\n    // 在4节点后插入5节点\n    Insert(header, 4, 5)\n    // 打印\n    Print(header)\n}\n\n// 构建链表\nfunc BuildLinkList(arr []int) *LinkNode{\n    var header *LinkNode\n    var tail *LinkNode\n    for _, v := range arr {\n        node := &LinkNode {\n            Val: v,\n        }\n        if header == nil {\n            header = node\n            tail = node\n        } else {\n            tail.Next = node\n            tail = tail.Next\n        }\n    }\n    return header\n}\n\n// 删除节点\nfunc Delete(header *LinkNode, target int) *LinkNode {\n    var prev *LinkNode\n    node := header\n    for node != nil && node.Val != target{\n        prev = node\n        node = node.Next\n    }\n    if node != nil {\n        if prev == nil {\n            header = header.Next\n        } else {\n            prev.Next = node.Next\n        }\n    }\n    return header\n}\n\n// 打印节点\nfunc Print(header *LinkNode) {\n    node := header\n    for node != nil {\n        fmt.Println(node.Val)\n        node = node.Next\n    }\n}\n\n// 插入节点，在a节点末尾插入一个b节点\nfunc Insert(header *LinkNode, a int, b int) {\n    node := header\n    for node != nil && node.Val != a {\n        node = node.Next\n    }\n    if node != nil {\n        next := node.Next\n        node.Next = &LinkNode{\n            Val: b,\n            Next: next,\n        }\n    }\n}', 'go', '[12,24,32,35,49,74]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"LinkNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (71, '2025-02-10 00:51:35.849', '2025-02-10 00:51:35.849', '2025-02-10 00:51:54.735', 39, 'package main\nimport (\n	\"fmt\"\n)\n\ntype LinkNode struct {\n	Val int\n	Next *LinkNode\n}\n\nfunc main() {\n	header := BuildLinkList([]int{1, 2, 4, 6, 9})\n    // 删除1节点和6节点\n    header = Delete(header, 1)\n    header = Delete(header, 6)\n    // 在4节点后插入5节点\n    Insert(header, 4, 5)\n    // 打印\n    Print(header)\n}\n\n// 构建链表\nfunc BuildLinkList(arr []int) *LinkNode{\n    var header *LinkNode\n    var tail *LinkNode\n    for _, v := range arr {\n        node := &LinkNode {\n            Val: v,\n        }\n        if header == nil {\n            header = node\n            tail = node\n        } else {\n            tail.Next = node\n            tail = tail.Next\n        }\n    }\n    return header\n}\n\n// 删除节点\nfunc Delete(header *LinkNode, target int) *LinkNode {\n    var prev *LinkNode\n    node := header\n    for node != nil && node.Val != target{\n        prev = node\n        node = node.Next\n    }\n    if node != nil {\n        if prev == nil {\n            header = header.Next\n        } else {\n            prev.Next = node.Next\n        }\n    }\n    return header\n}\n\n// 打印节点\nfunc Print(header *LinkNode) {\n    node := header\n    for node != nil {\n        fmt.Println(node.Val)\n        node = node.Next\n    }\n}\n\n// 插入节点，在a节点末尾插入一个b节点\nfunc Insert(header *LinkNode, a int, b int) {\n    node := header\n    for node != nil && node.Val != a {\n        node = node.Next\n    }\n    if node != nil {\n        next := node.Next\n        node.Next = &LinkNode{\n            Val: b,\n            Next: next,\n        }\n    }\n}', 'go', '[12,24,32,35,49,74]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"LinkNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"Prev\"}}');
INSERT INTO `visual_document_codes` VALUES (72, '2025-02-10 00:51:54.800', '2025-02-10 00:51:54.800', '2025-02-10 00:52:01.662', 39, 'package main\nimport (\n	\"fmt\"\n)\n\ntype LinkNode struct {\n	Val int\n	Next *LinkNode\n}\n\nfunc main() {\n	header := BuildLinkList([]int{1, 2, 4, 6, 9})\n    // 删除1节点和6节点\n    header = Delete(header, 1)\n    header = Delete(header, 6)\n    // 在4节点后插入5节点\n    Insert(header, 4, 5)\n    // 打印\n    Print(header)\n}\n\n// 构建链表\nfunc BuildLinkList(arr []int) *LinkNode{\n    var header *LinkNode\n    var tail *LinkNode\n    for _, v := range arr {\n        node := &LinkNode {\n            Val: v,\n        }\n        if header == nil {\n            header = node\n            tail = node\n        } else {\n            tail.Next = node\n            tail = tail.Next\n        }\n    }\n    return header\n}\n\n// 删除节点\nfunc Delete(header *LinkNode, target int) *LinkNode {\n    var prev *LinkNode\n    node := header\n    for node != nil && node.Val != target{\n        prev = node\n        node = node.Next\n    }\n    if node != nil {\n        if prev == nil {\n            header = header.Next\n        } else {\n            prev.Next = node.Next\n        }\n    }\n    fmt.Println(header)\n    return header\n}\n\n// 打印节点\nfunc Print(header *LinkNode) {\n    node := header\n    for node != nil {\n        fmt.Println(node.Val)\n        node = node.Next\n    }\n}\n\n// 插入节点，在a节点末尾插入一个b节点\nfunc Insert(header *LinkNode, a int, b int) {\n    node := header\n    for node != nil && node.Val != a {\n        node = node.Next\n    }\n    if node != nil {\n        next := node.Next\n        node.Next = &LinkNode{\n            Val: b,\n            Next: next,\n        }\n    }\n}', 'go', '[12,24,32,35,49,74]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"LinkNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"Prev\"}}');
INSERT INTO `visual_document_codes` VALUES (73, '2025-02-10 00:52:01.726', '2025-02-10 00:52:01.726', NULL, 39, 'package main\nimport (\n	\"fmt\"\n)\n\ntype LinkNode struct {\n	Val int\n	Next *LinkNode\n}\n\nfunc main() {\n	header := BuildLinkList([]int{1, 2, 4, 6, 9})\n    // 删除1节点和6节点\n    header = Delete(header, 1)\n    header = Delete(header, 6)\n    // 在4节点后插入5节点\n    Insert(header, 4, 5)\n    // 打印\n    Print(header)\n}\n\n// 构建链表\nfunc BuildLinkList(arr []int) *LinkNode{\n    var header *LinkNode\n    var tail *LinkNode\n    for _, v := range arr {\n        node := &LinkNode {\n            Val: v,\n        }\n        if header == nil {\n            header = node\n            tail = node\n        } else {\n            tail.Next = node\n            tail = tail.Next\n        }\n    }\n    return header\n}\n\n// 删除节点\nfunc Delete(header *LinkNode, target int) *LinkNode {\n    var prev *LinkNode\n    node := header\n    for node != nil && node.Val != target{\n        prev = node\n        node = node.Next\n    }\n    if node != nil {\n        if prev == nil {\n            header = header.Next\n        } else {\n            prev.Next = node.Next\n        }\n    }\n    fmt.Println(header)\n    return header\n}\n\n// 打印节点\nfunc Print(header *LinkNode) {\n    node := header\n    for node != nil {\n        fmt.Println(node.Val)\n        node = node.Next\n    }\n}\n\n// 插入节点，在a节点末尾插入一个b节点\nfunc Insert(header *LinkNode, a int, b int) {\n    node := header\n    for node != nil && node.Val != a {\n        node = node.Next\n    }\n    if node != nil {\n        next := node.Next\n        node.Next = &LinkNode{\n            Val: b,\n            Next: next,\n        }\n    }\n}', 'go', '[12,24,32,35,49,74]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"LinkNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"Prev\"}}');
INSERT INTO `visual_document_codes` VALUES (74, '2025-02-11 00:29:52.303', '2025-02-11 00:29:52.303', '2025-02-11 00:41:44.213', 38, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	// 本节无可视化\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (75, '2025-02-11 00:34:14.244', '2025-02-11 00:34:14.244', '2025-02-11 00:35:53.531', 33, 'package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 定义一个数组\n    var arr [3]int\n    arr[0] = 1\n    arr[1] = 2\n    arr[2] = 3\n    fmt.Println(\"Array:\", arr)\n\n    // 定义一个切片, len = 3, cap = 6\n    slice := make([]int, 3, 6)\n    fmt.Println(\"Slice:\", slice)\n    fmt.Printf(\"Slice 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n\n    // 向切片添加元素，触发扩容\n    slice = append(slice, 4)\n	slice = append(slice, 5)\n	slice = append(slice, 6)\n	fmt.Printf(\"Slice容量已满 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n	slice = append(slice, 7)\n	fmt.Printf(\"Slice扩容 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n}', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"\"]}}');
INSERT INTO `visual_document_codes` VALUES (76, '2025-02-11 00:35:53.589', '2025-02-11 00:35:53.589', '2025-02-13 23:13:29.708', 33, 'package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 定义一个数组\n    var arr [3]int\n    arr[0] = 1\n    arr[1] = 2\n    arr[2] = 3\n    fmt.Println(\"Array:\", arr)\n\n    // 定义一个切片, len = 3, cap = 6\n    slice := make([]int, 3, 6)\n    fmt.Println(\"Slice:\", slice)\n    fmt.Printf(\"Slice 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n\n    // 向切片添加元素，触发扩容\n    slice = append(slice, 4)\n	slice = append(slice, 5)\n	slice = append(slice, 6)\n	fmt.Printf(\"Slice容量已满 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n	slice = append(slice, 7)\n	fmt.Printf(\"Slice扩容 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n}', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"\"]}}');
INSERT INTO `visual_document_codes` VALUES (77, '2025-02-11 00:36:06.766', '2025-02-11 00:36:06.766', NULL, 40, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (78, '2025-02-11 00:36:26.102', '2025-02-11 00:36:26.102', '2025-02-11 00:40:05.309', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\n\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left <= right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid - 1\n		} else {\n			return mid\n		}\n	}\n	return -1\n}', 'go', '[14,18,20,22]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"nums\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (79, '2025-02-11 00:40:05.367', '2025-02-11 00:40:05.367', '2025-03-02 14:37:22.909', 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\n\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left <= right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid - 1\n		} else {\n			return mid\n		}\n	}\n	return -1\n}', 'go', '[14,18,20,22]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"nums\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (80, '2025-02-11 00:41:44.271', '2025-02-11 00:41:44.271', '2025-02-11 00:42:44.595', 38, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	// 本节无可视化\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (81, '2025-02-11 00:42:44.651', '2025-02-11 00:42:44.651', NULL, 38, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	// 本节无可视化\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (82, '2025-02-13 23:13:29.762', '2025-02-13 23:13:29.762', NULL, 33, 'package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 定义一个数组\n    var arr [3]int\n    arr[0] = 1\n    arr[1] = 2\n    arr[2] = 3\n    fmt.Println(\"Array:\", arr)\n\n    // 定义一个切片, len = 3, cap = 6\n    slice := make([]int, 3, 6)\n    fmt.Println(\"Slice:\", slice)\n    fmt.Printf(\"Slice 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n\n    // 向切片添加元素，触发扩容\n    slice = append(slice, 4)\n	slice = append(slice, 5)\n	slice = append(slice, 6)\n	fmt.Printf(\"Slice容量已满 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n	slice = append(slice, 7)\n	fmt.Printf(\"Slice扩容 长度:%d，容量:%d \\n\", len(slice), cap(slice))\n}', 'go', '[7,10]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"\"]}}');
INSERT INTO `visual_document_codes` VALUES (83, '2025-03-02 14:37:22.968', '2025-03-02 14:37:22.968', NULL, 37, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\n\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left <= right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid - 1\n		} else {\n			return mid\n		}\n	}\n	return -1\n}', 'go', '[14,18,20,22]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"nums\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (84, '2025-04-03 00:36:53.964', '2025-04-03 00:36:53.964', '2025-04-05 22:36:14.284', 49, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (85, '2025-04-05 22:36:14.345', '2025-04-05 22:36:14.345', '2025-04-05 22:36:39.678', 49, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (86, '2025-04-05 22:36:39.739', '2025-04-05 22:36:39.739', '2025-04-06 15:55:45.469', 49, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (87, '2025-04-06 15:55:45.535', '2025-04-06 15:55:45.535', NULL, 49, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (88, '2025-04-06 15:56:17.138', '2025-04-06 15:56:17.138', '2025-04-06 15:56:43.461', 55, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (89, '2025-04-06 15:56:43.519', '2025-04-06 15:56:43.519', '2025-04-06 15:56:54.339', 55, '#include <stdio.h>\n\n// 冒泡排序函数\nvoid bubbleSort(int arr[], int n) {\n    int i, j, temp;\n    for (i = 0; i < n - 1; i++) {\n        for (j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换 arr[j] 和 arr[j+1]\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"排序后的数组: \\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"i\",\"j\"]}}');
INSERT INTO `visual_document_codes` VALUES (90, '2025-04-06 15:56:54.397', '2025-04-06 15:56:54.397', '2025-04-06 15:57:24.375', 55, '#include <stdio.h>\n\n// 冒泡排序函数\nvoid bubbleSort(int arr[], int n) {\n    int i, j, temp;\n    for (i = 0; i < n - 1; i++) {\n        for (j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换 arr[j] 和 arr[j+1]\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"排序后的数组: \\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"i\",\"j\"]}}');
INSERT INTO `visual_document_codes` VALUES (91, '2025-04-06 15:57:24.433', '2025-04-06 15:57:24.433', '2025-04-06 16:06:27.347', 55, '#include <stdio.h>\n\n// 冒泡排序函数\nvoid bubbleSort(int arr[], int n) {\n    int i, j, temp;\n    for (i = 0; i < n - 1; i++) {\n        for (j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换 arr[j] 和 arr[j+1]\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"排序后的数组: \\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"i\",\"j\"]}}');
INSERT INTO `visual_document_codes` VALUES (92, '2025-04-06 16:17:19.099', '2025-04-06 16:17:19.099', '2025-04-06 16:17:25.044', 55, '#include <stdio.h>\n\n// 冒泡排序函数\nvoid bubbleSort(int arr[], int n) {\n    int i, j, temp;\n    for (i = n - 1; i > 0; i--) {\n        for (j = 0; j < i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换 arr[j] 和 arr[j+1]\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"排序后的数组: \\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}', 'c', '[6,7,8]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (93, '2025-04-06 16:17:25.110', '2025-04-06 16:17:25.110', '2025-04-06 16:20:50.257', 55, '#include <stdio.h>\n\n// 冒泡排序函数\nvoid bubbleSort(int arr[], int n) {\n    int i, j, temp;\n    for (i = n - 1; i > 0; i--) {\n        for (j = 0; j < i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换 arr[j] 和 arr[j+1]\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"排序后的数组: \\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}', 'c', '[6,7,8]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"i\",\"j\"]}}');
INSERT INTO `visual_document_codes` VALUES (94, '2025-04-06 16:20:50.323', '2025-04-06 16:20:50.323', NULL, 55, '#include <stdio.h>\n\n// 冒泡排序函数\nvoid bubbleSort(int arr[], int n) {\n    int i, j, temp;\n    for (i = n - 1; i > 0; i--) {\n        for (j = 0; j < i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换 arr[j] 和 arr[j+1]\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"排序后的数组: \\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}', 'c', '[6,7,8]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"i\",\"j\"]}}');
INSERT INTO `visual_document_codes` VALUES (95, '2025-04-06 16:56:54.239', '2025-04-06 16:56:54.239', '2025-04-06 16:56:56.312', 57, '#include <stdio.h>\n\n// 选择排序函数\nvoid selectionSort(int arr[], int n) {\n    int i, j, min_idx;\n\n    // 遍历数组\n    for (i = 0; i < n - 1; i++) {\n        // 找到未排序部分的最小元素的索引\n        min_idx = i;\n        for (j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n\n        // 将找到的最小元素与未排序部分的第一个元素交换位置\n        if (min_idx != i) {\n            int temp = arr[i];\n            arr[i] = arr[min_idx];\n            arr[min_idx] = temp;\n        }\n    }\n}\n\n// 打印数组的函数\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    // 打印排序前的数组\n    printf(\"排序前的数组: \\n\");\n    printArray(arr, n);\n\n    // 调用选择排序函数\n    selectionSort(arr, n);\n\n    // 打印排序后的数组\n    printf(\"排序后的数组: \\n\");\n    printArray(arr, n);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"i\",\"j\",\"min_idx\"]}}');
INSERT INTO `visual_document_codes` VALUES (96, '2025-04-06 16:56:56.372', '2025-04-06 16:56:56.372', '2025-04-09 01:07:13.945', 57, '#include <stdio.h>\n\n// 选择排序函数\nvoid selectionSort(int arr[], int n) {\n    int i, j, min_idx;\n\n    // 遍历数组\n    for (i = 0; i < n - 1; i++) {\n        // 找到未排序部分的最小元素的索引\n        min_idx = i;\n        for (j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n\n        // 将找到的最小元素与未排序部分的第一个元素交换位置\n        if (min_idx != i) {\n            int temp = arr[i];\n            arr[i] = arr[min_idx];\n            arr[min_idx] = temp;\n        }\n    }\n}\n\n// 打印数组的函数\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    // 打印排序前的数组\n    printf(\"排序前的数组: \\n\");\n    printArray(arr, n);\n\n    // 调用选择排序函数\n    selectionSort(arr, n);\n\n    // 打印排序后的数组\n    printf(\"排序后的数组: \\n\");\n    printArray(arr, n);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"i\",\"j\",\"min_idx\"]}}');
INSERT INTO `visual_document_codes` VALUES (97, '2025-04-09 01:04:40.839', '2025-04-09 01:04:40.839', NULL, 54, '#include <stdio.h>\nint main() {\n    \n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (98, '2025-04-09 01:05:43.422', '2025-04-09 01:05:43.422', '2025-04-09 01:05:45.202', 56, '#include <stdio.h>\n\n// 插入排序函数\nvoid insertionSort(int arr[], int n) {\n    int i, key, j;\n    for (i = 1; i < n; i++) {\n        key = arr[i];\n        j = i - 1;\n\n        // 将比 key 大的元素向后移动\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n// 打印数组函数\nvoid printArray(int arr[], int n) {\n    int i;\n    for (i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\n// 主函数\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"原始数组: \\n\");\n    printArray(arr, n);\n\n    insertionSort(arr, n);\n\n    printf(\"排序后的数组: \\n\");\n    printArray(arr, n);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (99, '2025-04-09 01:05:45.258', '2025-04-09 01:05:45.258', '2025-04-09 01:06:33.861', 56, '#include <stdio.h>\n\n// 插入排序函数\nvoid insertionSort(int arr[], int n) {\n    int i, key, j;\n    for (i = 1; i < n; i++) {\n        key = arr[i];\n        j = i - 1;\n\n        // 将比 key 大的元素向后移动\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n// 打印数组函数\nvoid printArray(int arr[], int n) {\n    int i;\n    for (i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\n// 主函数\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"原始数组: \\n\");\n    printArray(arr, n);\n\n    insertionSort(arr, n);\n\n    printf(\"排序后的数组: \\n\");\n    printArray(arr, n);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (100, '2025-04-09 01:06:33.931', '2025-04-09 01:06:33.931', '2025-04-09 01:06:50.134', 56, '#include <stdio.h>\n\n// 插入排序函数\nvoid insertionSort(int arr[], int n) {\n    int i, key, j;\n    for (i = 1; i < n; i++) {\n        key = arr[i];\n        j = i - 1;\n\n        // 将比 key 大的元素向后移动\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n// 打印数组函数\nvoid printArray(int arr[], int n) {\n    int i;\n    for (i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\n// 主函数\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"原始数组: \\n\");\n    printArray(arr, n);\n\n    insertionSort(arr, n);\n\n    printf(\"排序后的数组: \\n\");\n    printArray(arr, n);\n\n    return 0;\n}', 'c', '[6,15]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (101, '2025-04-09 01:06:50.204', '2025-04-09 01:06:50.204', NULL, 56, '#include <stdio.h>\n\n// 插入排序函数\nvoid insertionSort(int arr[], int n) {\n    int i, key, j;\n    for (i = 1; i < n; i++) {\n        key = arr[i];\n        j = i - 1;\n\n        // 将比 key 大的元素向后移动\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n// 打印数组函数\nvoid printArray(int arr[], int n) {\n    int i;\n    for (i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\n// 主函数\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"原始数组: \\n\");\n    printArray(arr, n);\n\n    insertionSort(arr, n);\n\n    printf(\"排序后的数组: \\n\");\n    printArray(arr, n);\n\n    return 0;\n}', 'c', '[6,15]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"i\",\"j\"]}}');
INSERT INTO `visual_document_codes` VALUES (102, '2025-04-09 01:07:14.015', '2025-04-09 01:07:14.015', NULL, 57, '#include <stdio.h>\n\n// 选择排序函数\nvoid selectionSort(int arr[], int n) {\n    int i, j, min_idx;\n\n    // 遍历数组\n    for (i = 0; i < n - 1; i++) {\n        // 找到未排序部分的最小元素的索引\n        min_idx = i;\n        for (j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n\n        // 将找到的最小元素与未排序部分的第一个元素交换位置\n        if (min_idx != i) {\n            int temp = arr[i];\n            arr[i] = arr[min_idx];\n            arr[min_idx] = temp;\n        }\n    }\n}\n\n// 打印数组的函数\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    // 打印排序前的数组\n    printf(\"排序前的数组: \\n\");\n    printArray(arr, n);\n\n    // 调用选择排序函数\n    selectionSort(arr, n);\n\n    // 打印排序后的数组\n    printf(\"排序后的数组: \\n\");\n    printArray(arr, n);\n\n    return 0;\n}', 'c', '[8,11]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"i\",\"j\",\"min_idx\"]}}');
INSERT INTO `visual_document_codes` VALUES (103, '2025-04-09 01:40:51.745', '2025-04-09 01:40:51.745', '2025-04-09 02:05:53.091', 59, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    newNode->next = head;\n    return newNode;\n}\n\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    return head;\n}\n\n// 按位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"插入位置超出链表长度，插入失败\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    temp->next = newNode;\n    return head;\n}\n\n// 遍历链表\nvoid traverseList(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\n// 删除指定值的节点\nNode* deleteNodeByValue(Node* head, int key) {\n    // 如果链表为空，直接返回\n    if (head == NULL) {\n        printf(\"链表为空，无法删除节点\\n\");\n        return head;\n    }\n\n    Node* temp = head;\n    Node* prev = NULL;\n\n    // 如果头节点就是要删除的节点\n    if (temp->data == key) {\n        head = temp->next;\n        free(temp);\n        return head;\n    }\n\n    // 查找要删除的节点\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    // 如果找到了要删除的节点\n    if (temp != NULL) {\n        prev->next = temp->next;\n        free(temp);\n    } else {\n        printf(\"未找到要删除的节点\\n\");\n    }\n\n    return head;\n}\n\n// 按位置删除节点\nNode* deleteNodeByPosition(Node* head, int position) {\n    if (head == NULL) {\n        printf(\"链表为空，无法删除节点\\n\");\n        return head;\n    }\n    if (position == 0) {\n        Node* temp = head;\n        head = head->next;\n        free(temp);\n        return head;\n    }\n    Node* temp = head;\n    Node* prev = NULL;\n    int count = 0;\n    while (temp != NULL && count < position) {\n        prev = temp;\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"删除位置超出链表长度，删除失败\\n\");\n        return head;\n    }\n    prev->next = temp->next;\n    free(temp);\n    return head;\n}\n\nint main() {\n    Node* head = NULL;\n\n    // 插入节点\n    head = insertAtBeginning(head, 3);\n    head = insertAtEnd(head, 4);\n    head = insertAtPosition(head, 5, 1);\n\n    // 遍历链表\n    printf(\"插入节点后的链表元素: \");\n    traverseList(head);\n\n    // 删除指定值的节点\n    head = deleteNodeByValue(head, 5);\n    printf(\"删除值为 5 的节点后的链表元素: \");\n    traverseList(head);\n\n    // 按位置删除节点\n    head = deleteNodeByPosition(head, 0);\n    printf(\"删除位置为 0 的节点后的链表元素: \");\n    traverseList(head);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (104, '2025-04-09 02:05:53.165', '2025-04-09 02:05:53.165', '2025-04-10 00:39:37.699', 59, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    newNode->next = head;\n    return newNode;\n}\n\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    return head;\n}\n\n// 按位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"插入位置超出链表长度，插入失败\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    temp->next = newNode;\n    return head;\n}\n\n// 遍历链表\nvoid traverseList(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\n// 删除指定值的节点\nNode* deleteNodeByValue(Node* head, int key) {\n    // 如果链表为空，直接返回\n    if (head == NULL) {\n        printf(\"链表为空，无法删除节点\\n\");\n        return head;\n    }\n\n    Node* temp = head;\n    Node* prev = NULL;\n\n    // 如果头节点就是要删除的节点\n    if (temp->data == key) {\n        head = temp->next;\n        free(temp);\n        return head;\n    }\n\n    // 查找要删除的节点\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    // 如果找到了要删除的节点\n    if (temp != NULL) {\n        prev->next = temp->next;\n        free(temp);\n    } else {\n        printf(\"未找到要删除的节点\\n\");\n    }\n\n    return head;\n}\n\n// 按位置删除节点\nNode* deleteNodeByPosition(Node* head, int position) {\n    if (head == NULL) {\n        printf(\"链表为空，无法删除节点\\n\");\n        return head;\n    }\n    if (position == 0) {\n        Node* temp = head;\n        head = head->next;\n        free(temp);\n        return head;\n    }\n    Node* temp = head;\n    Node* prev = NULL;\n    int count = 0;\n    while (temp != NULL && count < position) {\n        prev = temp;\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"删除位置超出链表长度，删除失败\\n\");\n        return head;\n    }\n    prev->next = temp->next;\n    free(temp);\n    return head;\n}\n\nint main() {\n    Node* head = NULL;\n\n    // 插入节点\n    head = insertAtBeginning(head, 3);\n    head = insertAtEnd(head, 4);\n    head = insertAtPosition(head, 5, 1);\n\n    // 遍历链表\n    printf(\"插入节点后的链表元素: \");\n    traverseList(head);\n\n    // 删除指定值的节点\n    head = deleteNodeByValue(head, 5);\n    printf(\"删除值为 5 的节点后的链表元素: \");\n    traverseList(head);\n\n    // 按位置删除节点\n    head = deleteNodeByPosition(head, 0);\n    printf(\"删除位置为 0 的节点后的链表元素: \");\n    traverseList(head);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (105, '2025-04-10 00:39:37.763', '2025-04-10 00:39:37.763', '2025-04-10 00:41:01.821', 59, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    newNode->next = head;\n    return newNode;\n}\n\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    return head;\n}\n\n// 按位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"插入位置超出链表长度，插入失败\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    temp->next = newNode;\n    return head;\n}\n\n// 遍历链表\nvoid traverseList(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\n// 删除指定值的节点\nNode* deleteNodeByValue(Node* head, int key) {\n    // 如果链表为空，直接返回\n    if (head == NULL) {\n        printf(\"链表为空，无法删除节点\\n\");\n        return head;\n    }\n\n    Node* temp = head;\n    Node* prev = NULL;\n\n    // 如果头节点就是要删除的节点\n    if (temp->data == key) {\n        head = temp->next;\n        free(temp);\n        return head;\n    }\n\n    // 查找要删除的节点\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    // 如果找到了要删除的节点\n    if (temp != NULL) {\n        prev->next = temp->next;\n        free(temp);\n    } else {\n        printf(\"未找到要删除的节点\\n\");\n    }\n\n    return head;\n}\n\n// 按位置删除节点\nNode* deleteNodeByPosition(Node* head, int position) {\n    if (head == NULL) {\n        printf(\"链表为空，无法删除节点\\n\");\n        return head;\n    }\n    if (position == 0) {\n        Node* temp = head;\n        head = head->next;\n        free(temp);\n        return head;\n    }\n    Node* temp = head;\n    Node* prev = NULL;\n    int count = 0;\n    while (temp != NULL && count < position) {\n        prev = temp;\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"删除位置超出链表长度，删除失败\\n\");\n        return head;\n    }\n    prev->next = temp->next;\n    free(temp);\n    return head;\n}\n\nint main() {\n    Node* head = NULL;\n\n    // 插入节点\n    head = insertAtBeginning(head, 3);\n    head = insertAtEnd(head, 4);\n    head = insertAtPosition(head, 5, 1);\n\n    // 遍历链表\n    printf(\"插入节点后的链表元素: \");\n    traverseList(head);\n\n    // 删除指定值的节点\n    head = deleteNodeByValue(head, 5);\n    printf(\"删除值为 5 的节点后的链表元素: \");\n    traverseList(head);\n\n    // 按位置删除节点\n    head = deleteNodeByPosition(head, 0);\n    printf(\"删除位置为 0 的节点后的链表元素: \");\n    traverseList(head);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (106, '2025-04-10 00:41:01.885', '2025-04-10 00:41:01.885', NULL, 59, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    newNode->next = head;\n    return newNode;\n}\n\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    return head;\n}\n\n// 按位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"插入位置超出链表长度，插入失败\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    temp->next = newNode;\n    return head;\n}\n\n// 遍历链表\nvoid traverseList(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\n// 删除指定值的节点\nNode* deleteNodeByValue(Node* head, int key) {\n    // 如果链表为空，直接返回\n    if (head == NULL) {\n        printf(\"链表为空，无法删除节点\\n\");\n        return head;\n    }\n\n    Node* temp = head;\n    Node* prev = NULL;\n\n    // 如果头节点就是要删除的节点\n    if (temp->data == key) {\n        head = temp->next;\n        free(temp);\n        return head;\n    }\n\n    // 查找要删除的节点\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    // 如果找到了要删除的节点\n    if (temp != NULL) {\n        prev->next = temp->next;\n        free(temp);\n    } else {\n        printf(\"未找到要删除的节点\\n\");\n    }\n\n    return head;\n}\n\n// 按位置删除节点\nNode* deleteNodeByPosition(Node* head, int position) {\n    if (head == NULL) {\n        printf(\"链表为空，无法删除节点\\n\");\n        return head;\n    }\n    if (position == 0) {\n        Node* temp = head;\n        head = head->next;\n        free(temp);\n        return head;\n    }\n    Node* temp = head;\n    Node* prev = NULL;\n    int count = 0;\n    while (temp != NULL && count < position) {\n        prev = temp;\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"删除位置超出链表长度，删除失败\\n\");\n        return head;\n    }\n    prev->next = temp->next;\n    free(temp);\n    return head;\n}\n\nint main() {\n    Node* head = NULL;\n\n    // 插入节点\n    head = insertAtBeginning(head, 3);\n    head = insertAtEnd(head, 4);\n    head = insertAtPosition(head, 5, 1);\n\n    // 遍历链表\n    printf(\"插入节点后的链表元素: \");\n    traverseList(head);\n\n    // 删除指定值的节点\n    head = deleteNodeByValue(head, 5);\n    printf(\"删除值为 5 的节点后的链表元素: \");\n    traverseList(head);\n\n    // 按位置删除节点\n    head = deleteNodeByPosition(head, 0);\n    printf(\"删除位置为 0 的节点后的链表元素: \");\n    traverseList(head);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"Node\",\"data\":\"data\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (107, '2025-04-10 00:41:14.818', '2025-04-10 00:41:14.818', NULL, 58, '#include <stdio.h>\nint main() {\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (108, '2025-04-10 00:42:03.645', '2025-04-10 00:42:03.645', '2025-04-10 00:42:14.009', 60, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义双向链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* prev;  // 指向前一个节点的指针\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    newNode->next = head;\n    head->prev = newNode;\n    return newNode;\n}\n\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n\n// 在指定位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"位置超出链表长度\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    if (temp->next != NULL) {\n        temp->next->prev = newNode;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n\n// 从前往后遍历链表\nvoid traverseForward(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\n// 从后往前遍历链表\nvoid traverseBackward(Node* head) {\n    if (head == NULL) return;\n    Node* current = head;\n    while (current->next != NULL) {\n        current = current->next;\n    }\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->prev;\n    }\n    printf(\"\\n\");\n}\n\n// 删除头节点\nNode* deleteAtBeginning(Node* head) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    head = head->next;\n    if (head != NULL) {\n        head->prev = NULL;\n    }\n    free(temp);\n    return head;\n}\n\n// 删除尾节点\nNode* deleteAtEnd(Node* head) {\n    if (head == NULL) return NULL;\n    if (head->next == NULL) {\n        free(head);\n        return NULL;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->prev->next = NULL;\n    free(temp);\n    return head;\n}\n\n// 删除指定值的节点\nNode* deleteNode(Node* head, int key) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    if (temp->data == key) {\n        return deleteAtBeginning(head);\n    }\n    while (temp != NULL && temp->data != key) {\n        temp = temp->next;\n    }\n    if (temp == NULL) {\n        printf(\"未找到该值的节点\\n\");\n        return head;\n    }\n    if (temp->next != NULL) {\n        temp->next->prev = temp->prev;\n    }\n    temp->prev->next = temp->next;\n    free(temp);\n    return head;\n}\n\nint main() {\n    Node* head = NULL;\n\n    // 插入节点\n    head = insertAtBeginning(head, 1);\n    head = insertAtEnd(head, 3);\n    head = insertAtPosition(head, 2, 1);\n\n    // 从前往后遍历链表\n    printf(\"从前往后遍历链表: \");\n    traverseForward(head);\n\n    // 从后往前遍历链表\n    printf(\"从后往前遍历链表: \");\n    traverseBackward(head);\n\n    // 删除节点\n    head = deleteNode(head, 2);\n\n    // 再次从前往后遍历链表\n    printf(\"删除节点 2 后从前往后遍历链表: \");\n    traverseForward(head);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (109, '2025-04-10 00:42:14.073', '2025-04-10 00:42:14.073', '2025-04-10 00:42:17.067', 60, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义双向链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* prev;  // 指向前一个节点的指针\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    newNode->next = head;\n    head->prev = newNode;\n    return newNode;\n}\n\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n\n// 在指定位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"位置超出链表长度\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    if (temp->next != NULL) {\n        temp->next->prev = newNode;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n\n// 从前往后遍历链表\nvoid traverseForward(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\n// 从后往前遍历链表\nvoid traverseBackward(Node* head) {\n    if (head == NULL) return;\n    Node* current = head;\n    while (current->next != NULL) {\n        current = current->next;\n    }\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->prev;\n    }\n    printf(\"\\n\");\n}\n\n// 删除头节点\nNode* deleteAtBeginning(Node* head) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    head = head->next;\n    if (head != NULL) {\n        head->prev = NULL;\n    }\n    free(temp);\n    return head;\n}\n\n// 删除尾节点\nNode* deleteAtEnd(Node* head) {\n    if (head == NULL) return NULL;\n    if (head->next == NULL) {\n        free(head);\n        return NULL;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->prev->next = NULL;\n    free(temp);\n    return head;\n}\n\n// 删除指定值的节点\nNode* deleteNode(Node* head, int key) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    if (temp->data == key) {\n        return deleteAtBeginning(head);\n    }\n    while (temp != NULL && temp->data != key) {\n        temp = temp->next;\n    }\n    if (temp == NULL) {\n        printf(\"未找到该值的节点\\n\");\n        return head;\n    }\n    if (temp->next != NULL) {\n        temp->next->prev = temp->prev;\n    }\n    temp->prev->next = temp->next;\n    free(temp);\n    return head;\n}\n\nint main() {\n    Node* head = NULL;\n\n    // 插入节点\n    head = insertAtBeginning(head, 1);\n    head = insertAtEnd(head, 3);\n    head = insertAtPosition(head, 2, 1);\n\n    // 从前往后遍历链表\n    printf(\"从前往后遍历链表: \");\n    traverseForward(head);\n\n    // 从后往前遍历链表\n    printf(\"从后往前遍历链表: \");\n    traverseBackward(head);\n\n    // 删除节点\n    head = deleteNode(head, 2);\n\n    // 再次从前往后遍历链表\n    printf(\"删除节点 2 后从前往后遍历链表: \");\n    traverseForward(head);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"Node\",\"data\":\"data\",\"next\":\"next\",\"prev\":\"prev\"}}');
INSERT INTO `visual_document_codes` VALUES (110, '2025-04-10 00:42:17.131', '2025-04-10 00:42:17.131', '2025-04-10 00:42:35.096', 60, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义双向链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* prev;  // 指向前一个节点的指针\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    newNode->next = head;\n    head->prev = newNode;\n    return newNode;\n}\n\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n\n// 在指定位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"位置超出链表长度\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    if (temp->next != NULL) {\n        temp->next->prev = newNode;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n\n// 从前往后遍历链表\nvoid traverseForward(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\n// 从后往前遍历链表\nvoid traverseBackward(Node* head) {\n    if (head == NULL) return;\n    Node* current = head;\n    while (current->next != NULL) {\n        current = current->next;\n    }\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->prev;\n    }\n    printf(\"\\n\");\n}\n\n// 删除头节点\nNode* deleteAtBeginning(Node* head) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    head = head->next;\n    if (head != NULL) {\n        head->prev = NULL;\n    }\n    free(temp);\n    return head;\n}\n\n// 删除尾节点\nNode* deleteAtEnd(Node* head) {\n    if (head == NULL) return NULL;\n    if (head->next == NULL) {\n        free(head);\n        return NULL;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->prev->next = NULL;\n    free(temp);\n    return head;\n}\n\n// 删除指定值的节点\nNode* deleteNode(Node* head, int key) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    if (temp->data == key) {\n        return deleteAtBeginning(head);\n    }\n    while (temp != NULL && temp->data != key) {\n        temp = temp->next;\n    }\n    if (temp == NULL) {\n        printf(\"未找到该值的节点\\n\");\n        return head;\n    }\n    if (temp->next != NULL) {\n        temp->next->prev = temp->prev;\n    }\n    temp->prev->next = temp->next;\n    free(temp);\n    return head;\n}\n\nint main() {\n    Node* head = NULL;\n\n    // 插入节点\n    head = insertAtBeginning(head, 1);\n    head = insertAtEnd(head, 3);\n    head = insertAtPosition(head, 2, 1);\n\n    // 从前往后遍历链表\n    printf(\"从前往后遍历链表: \");\n    traverseForward(head);\n\n    // 从后往前遍历链表\n    printf(\"从后往前遍历链表: \");\n    traverseBackward(head);\n\n    // 删除节点\n    head = deleteNode(head, 2);\n\n    // 再次从前往后遍历链表\n    printf(\"删除节点 2 后从前往后遍历链表: \");\n    traverseForward(head);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"Node\",\"data\":\"data\",\"next\":\"next\",\"prev\":\"prev\"}}');
INSERT INTO `visual_document_codes` VALUES (111, '2025-04-10 00:42:35.160', '2025-04-10 00:42:35.160', '2025-07-06 00:53:39.559', 60, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义双向链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* prev;  // 指向前一个节点的指针\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    newNode->next = head;\n    head->prev = newNode;\n    return newNode;\n}\n\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n\n// 在指定位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"位置超出链表长度\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    if (temp->next != NULL) {\n        temp->next->prev = newNode;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n\n// 从前往后遍历链表\nvoid traverseForward(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\n// 从后往前遍历链表\nvoid traverseBackward(Node* head) {\n    if (head == NULL) return;\n    Node* current = head;\n    while (current->next != NULL) {\n        current = current->next;\n    }\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->prev;\n    }\n    printf(\"\\n\");\n}\n\n// 删除头节点\nNode* deleteAtBeginning(Node* head) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    head = head->next;\n    if (head != NULL) {\n        head->prev = NULL;\n    }\n    free(temp);\n    return head;\n}\n\n// 删除尾节点\nNode* deleteAtEnd(Node* head) {\n    if (head == NULL) return NULL;\n    if (head->next == NULL) {\n        free(head);\n        return NULL;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->prev->next = NULL;\n    free(temp);\n    return head;\n}\n\n// 删除指定值的节点\nNode* deleteNode(Node* head, int key) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    if (temp->data == key) {\n        return deleteAtBeginning(head);\n    }\n    while (temp != NULL && temp->data != key) {\n        temp = temp->next;\n    }\n    if (temp == NULL) {\n        printf(\"未找到该值的节点\\n\");\n        return head;\n    }\n    if (temp->next != NULL) {\n        temp->next->prev = temp->prev;\n    }\n    temp->prev->next = temp->next;\n    free(temp);\n    return head;\n}\n\nint main() {\n    Node* head = NULL;\n\n    // 插入节点\n    head = insertAtBeginning(head, 1);\n    head = insertAtEnd(head, 3);\n    head = insertAtPosition(head, 2, 1);\n\n    // 从前往后遍历链表\n    printf(\"从前往后遍历链表: \");\n    traverseForward(head);\n\n    // 从后往前遍历链表\n    printf(\"从后往前遍历链表: \");\n    traverseBackward(head);\n\n    // 删除节点\n    head = deleteNode(head, 2);\n\n    // 再次从前往后遍历链表\n    printf(\"删除节点 2 后从前往后遍历链表: \");\n    traverseForward(head);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"Node\",\"data\":\"data\",\"next\":\"next\",\"prev\":\"prev\"}}');
INSERT INTO `visual_document_codes` VALUES (112, '2025-04-10 01:26:30.790', '2025-04-10 01:26:30.790', '2025-04-10 01:28:09.006', 65, '#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100  // 定义顺序表的最大容量\n\n// 定义顺序表的结构体\ntypedef struct {\n    int data[MAX_SIZE];  // 存储数据元素的数组\n    int length;          // 当前顺序表中元素的数量\n} SeqList;\n\nint main() {\n    SeqList list;\n    initList(&list);\n\n    // 插入元素\n    insertElement(&list, 1, 10);\n    insertElement(&list, 2, 20);\n    insertElement(&list, 3, 30);\n\n    // 遍历顺序表\n    printf(\"插入元素后的顺序表: \");\n    traverseList(&list);\n\n    // 删除元素\n    deleteElement(&list, 2);\n\n    // 遍历顺序表\n    printf(\"删除元素后的顺序表: \");\n    traverseList(&list);\n\n    // 查找元素\n    int position = findElement(&list, 30);\n    if (position != 0) {\n        printf(\"元素 30 的位置是: %d\\n\", position);\n    } else {\n        printf(\"未找到元素 30\\n\");\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (113, '2025-04-10 01:28:09.066', '2025-04-10 01:28:09.066', '2025-04-10 01:28:15.674', 65, '#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100  // 定义顺序表的最大容量\n\n// 定义顺序表的结构体\ntypedef struct {\n    int data[MAX_SIZE];  // 存储数据元素的数组\n    int length;          // 当前顺序表中元素的数量\n} SeqList;\n\nint main() {\n    SeqList ;\n    initList(&list);\n\n    // 插入元素\n    insertElement(&list, 1, 10);\n    insertElement(&list, 2, 20);\n    insertElement(&list, 3, 30);\n\n    // 遍历顺序表\n    printf(\"插入元素后的顺序表: \");\n    traverseList(&list);\n\n    // 删除元素\n    deleteElement(&list, 2);\n\n    // 遍历顺序表\n    printf(\"删除元素后的顺序表: \");\n    traverseList(&list);\n\n    // 查找元素\n    int position = findElement(&list, 30);\n    if (position != 0) {\n        printf(\"元素 30 的位置是: %d\\n\", position);\n    } else {\n        printf(\"未找到元素 30\\n\");\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"list.data\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (114, '2025-04-10 01:28:15.733', '2025-04-10 01:28:15.733', '2025-04-10 01:28:36.462', 65, '#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100  // 定义顺序表的最大容量\n\n// 定义顺序表的结构体\ntypedef struct {\n    int data[MAX_SIZE];  // 存储数据元素的数组\n    int length;          // 当前顺序表中元素的数量\n} SeqList;\n\n// 初始化顺序表\nvoid initList(SeqList *list) {\n    list->length = 0;\n}\n\n// 在指定位置插入元素\nint insertElement(SeqList *list, int position, int element) {\n    // 检查插入位置是否合法\n    if (position < 1 || position > list->length + 1) {\n        printf(\"插入位置不合法\\n\");\n        return 0;\n    }\n    // 检查顺序表是否已满\n    if (list->length >= MAX_SIZE) {\n        printf(\"顺序表已满，无法插入\\n\");\n        return 0;\n    }\n    // 将插入位置及之后的元素后移\n    for (int i = list->length; i >= position; i--) {\n        list->data[i] = list->data[i - 1];\n    }\n    // 插入新元素\n    list->data[position - 1] = element;\n    // 顺序表长度加 1\n    list->length++;\n    return 1;\n}\n\n// 删除指定位置的元素\nint deleteElement(SeqList *list, int position) {\n    // 检查删除位置是否合法\n    if (position < 1 || position > list->length) {\n        printf(\"删除位置不合法\\n\");\n        return 0;\n    }\n    // 将删除位置之后的元素前移\n    for (int i = position; i < list->length; i++) {\n        list->data[i - 1] = list->data[i];\n    }\n    // 顺序表长度减 1\n    list->length--;\n    return 1;\n}\n\n// 查找元素的位置\nint findElement(SeqList *list, int element) {\n    for (int i = 0; i < list->length; i++) {\n        if (list->data[i] == element) {\n            return i + 1;  // 返回元素的位置（从 1 开始）\n        }\n    }\n    return 0;  // 未找到元素\n}\n\n// 遍历顺序表\nvoid traverseList(SeqList *list) {\n    for (int i = 0; i < list->length; i++) {\n        printf(\"%d \", list->data[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    SeqList list;\n    initList(&list);\n\n    // 插入元素\n    insertElement(&list, 1, 10);\n    insertElement(&list, 2, 20);\n    insertElement(&list, 3, 30);\n\n    // 遍历顺序表\n    printf(\"插入元素后的顺序表: \");\n    traverseList(&list);\n\n    // 删除元素\n    deleteElement(&list, 2);\n\n    // 遍历顺序表\n    printf(\"删除元素后的顺序表: \");\n    traverseList(&list);\n\n    // 查找元素\n    int position = findElement(&list, 30);\n    if (position != 0) {\n        printf(\"元素 30 的位置是: %d\\n\", position);\n    } else {\n        printf(\"未找到元素 30\\n\");\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"list.data\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (115, '2025-04-10 01:28:36.521', '2025-04-10 01:28:36.521', '2025-04-10 01:28:38.479', 65, '#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100  // 定义顺序表的最大容量\n\n// 定义顺序表的结构体\ntypedef struct {\n    int data[MAX_SIZE];  // 存储数据元素的数组\n    int length;          // 当前顺序表中元素的数量\n} SeqList;\n\n// 初始化顺序表\nvoid initList(SeqList *list) {\n    list->length = 0;\n}\n\n// 在指定位置插入元素\nint insertElement(SeqList *list, int position, int element) {\n    // 检查插入位置是否合法\n    if (position < 1 || position > list->length + 1) {\n        printf(\"插入位置不合法\\n\");\n        return 0;\n    }\n    // 检查顺序表是否已满\n    if (list->length >= MAX_SIZE) {\n        printf(\"顺序表已满，无法插入\\n\");\n        return 0;\n    }\n    // 将插入位置及之后的元素后移\n    for (int i = list->length; i >= position; i--) {\n        list->data[i] = list->data[i - 1];\n    }\n    // 插入新元素\n    list->data[position - 1] = element;\n    // 顺序表长度加 1\n    list->length++;\n    return 1;\n}\n\n// 删除指定位置的元素\nint deleteElement(SeqList *list, int position) {\n    // 检查删除位置是否合法\n    if (position < 1 || position > list->length) {\n        printf(\"删除位置不合法\\n\");\n        return 0;\n    }\n    // 将删除位置之后的元素前移\n    for (int i = position; i < list->length; i++) {\n        list->data[i - 1] = list->data[i];\n    }\n    // 顺序表长度减 1\n    list->length--;\n    return 1;\n}\n\n// 查找元素的位置\nint findElement(SeqList *list, int element) {\n    for (int i = 0; i < list->length; i++) {\n        if (list->data[i] == element) {\n            return i + 1;  // 返回元素的位置（从 1 开始）\n        }\n    }\n    return 0;  // 未找到元素\n}\n\n// 遍历顺序表\nvoid traverseList(SeqList *list) {\n    for (int i = 0; i < list->length; i++) {\n        printf(\"%d \", list->data[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    SeqList list;\n    initList(&list);\n\n    // 插入元素\n    insertElement(&list, 1, 10);\n    insertElement(&list, 2, 20);\n    insertElement(&list, 3, 30);\n\n    // 遍历顺序表\n    printf(\"插入元素后的顺序表: \");\n    traverseList(&list);\n\n    // 删除元素\n    deleteElement(&list, 2);\n\n    // 遍历顺序表\n    printf(\"删除元素后的顺序表: \");\n    traverseList(&list);\n\n    // 查找元素\n    int position = findElement(&list, 30);\n    if (position != 0) {\n        printf(\"元素 30 的位置是: %d\\n\", position);\n    } else {\n        printf(\"未找到元素 30\\n\");\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"list.data\",\"pointNames\":[\"i\"]}}');
INSERT INTO `visual_document_codes` VALUES (116, '2025-04-10 01:28:38.539', '2025-04-10 01:28:38.539', NULL, 65, '#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100  // 定义顺序表的最大容量\n\n// 定义顺序表的结构体\ntypedef struct {\n    int data[MAX_SIZE];  // 存储数据元素的数组\n    int length;          // 当前顺序表中元素的数量\n} SeqList;\n\n// 初始化顺序表\nvoid initList(SeqList *list) {\n    list->length = 0;\n}\n\n// 在指定位置插入元素\nint insertElement(SeqList *list, int position, int element) {\n    // 检查插入位置是否合法\n    if (position < 1 || position > list->length + 1) {\n        printf(\"插入位置不合法\\n\");\n        return 0;\n    }\n    // 检查顺序表是否已满\n    if (list->length >= MAX_SIZE) {\n        printf(\"顺序表已满，无法插入\\n\");\n        return 0;\n    }\n    // 将插入位置及之后的元素后移\n    for (int i = list->length; i >= position; i--) {\n        list->data[i] = list->data[i - 1];\n    }\n    // 插入新元素\n    list->data[position - 1] = element;\n    // 顺序表长度加 1\n    list->length++;\n    return 1;\n}\n\n// 删除指定位置的元素\nint deleteElement(SeqList *list, int position) {\n    // 检查删除位置是否合法\n    if (position < 1 || position > list->length) {\n        printf(\"删除位置不合法\\n\");\n        return 0;\n    }\n    // 将删除位置之后的元素前移\n    for (int i = position; i < list->length; i++) {\n        list->data[i - 1] = list->data[i];\n    }\n    // 顺序表长度减 1\n    list->length--;\n    return 1;\n}\n\n// 查找元素的位置\nint findElement(SeqList *list, int element) {\n    for (int i = 0; i < list->length; i++) {\n        if (list->data[i] == element) {\n            return i + 1;  // 返回元素的位置（从 1 开始）\n        }\n    }\n    return 0;  // 未找到元素\n}\n\n// 遍历顺序表\nvoid traverseList(SeqList *list) {\n    for (int i = 0; i < list->length; i++) {\n        printf(\"%d \", list->data[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    SeqList list;\n    initList(&list);\n\n    // 插入元素\n    insertElement(&list, 1, 10);\n    insertElement(&list, 2, 20);\n    insertElement(&list, 3, 30);\n\n    // 遍历顺序表\n    printf(\"插入元素后的顺序表: \");\n    traverseList(&list);\n\n    // 删除元素\n    deleteElement(&list, 2);\n\n    // 遍历顺序表\n    printf(\"删除元素后的顺序表: \");\n    traverseList(&list);\n\n    // 查找元素\n    int position = findElement(&list, 30);\n    if (position != 0) {\n        printf(\"元素 30 的位置是: %d\\n\", position);\n    } else {\n        printf(\"未找到元素 30\\n\");\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"list.data\",\"pointNames\":[\"i\"]}}');
INSERT INTO `visual_document_codes` VALUES (117, '2025-04-10 01:28:53.949', '2025-04-10 01:28:53.949', '2025-04-26 20:56:19.138', 62, '#include <stdio.h>\nint main() {\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (118, '2025-04-10 01:32:40.698', '2025-04-10 01:32:40.698', '2025-04-10 01:34:12.334', 63, '#include <stdio.h>\n\n#define MAX_SIZE 100\n\nvoid insertElement(int arr[], int *size, int pos, int value) {\n    if (*size >= MAX_SIZE) {\n        printf(\"数组已满，无法插入元素\\n\");\n        return;\n    }\n\n    if (pos < 0 || pos > *size) {\n        printf(\"插入位置不合法\\n\");\n        return;\n    }\n\n    // 将插入位置及之后的元素向后移动一位\n    for (int i = *size; i > pos; i--) {\n        arr[i] = arr[i - 1];\n    }\n\n    // 插入新元素\n    arr[pos] = value;\n    (*size)++;\n}\n\nint main() {\n    int arr[MAX_SIZE] = {1, 2, 3, 4, 5};\n    int size = 5;\n\n    // 在位置 2 插入元素 10\n    insertElement(arr, &size, 2, 10);\n\n    // 打印数组元素\n    for (int i = 0; i < size; i++) {\n        printf(\"arr[%d] = %d\\n\", i, arr[i]);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"i\"]}}');
INSERT INTO `visual_document_codes` VALUES (119, '2025-04-10 01:34:12.404', '2025-04-10 01:34:12.404', '2025-04-26 20:57:19.486', 63, '#include <stdio.h>\n\n#define MAX_SIZE 10\n\nvoid insertElement(int arr[], int *size, int pos, int value) {\n    if (*size >= MAX_SIZE) {\n        printf(\"数组已满，无法插入元素\\n\");\n        return;\n    }\n\n    if (pos < 0 || pos > *size) {\n        printf(\"插入位置不合法\\n\");\n        return;\n    }\n\n    // 将插入位置及之后的元素向后移动一位\n    for (int i = *size; i > pos; i--) {\n        arr[i] = arr[i - 1];\n    }\n\n    // 插入新元素\n    arr[pos] = value;\n    (*size)++;\n}\n\nint main() {\n    int arr[MAX_SIZE] = {1, 2, 3, 4, 5};\n    int size = 5;\n\n    // 在位置 2 插入元素 10\n    insertElement(arr, &size, 2, 10);\n\n    // 打印数组元素\n    for (int i = 0; i < size; i++) {\n        printf(\"arr[%d] = %d\\n\", i, arr[i]);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"i\"]}}');
INSERT INTO `visual_document_codes` VALUES (120, '2025-04-11 01:24:08.838', '2025-04-11 01:24:08.838', '2025-04-11 01:24:39.156', 66, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (121, '2025-04-11 01:24:08.903', '2025-04-11 01:24:08.903', '2025-04-11 01:24:39.156', 66, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (122, '2025-04-11 01:24:39.221', '2025-04-11 01:24:39.221', '2025-04-11 01:24:59.429', 66, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (123, '2025-04-11 01:24:39.286', '2025-04-11 01:24:39.286', '2025-04-11 01:24:59.429', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (124, '2025-04-11 01:24:59.494', '2025-04-11 01:24:59.494', '2025-04-11 01:25:20.504', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (125, '2025-04-11 01:24:59.558', '2025-04-11 01:24:59.558', '2025-04-11 01:25:20.504', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (126, '2025-04-11 01:25:20.566', '2025-04-11 01:25:20.566', '2025-04-11 01:25:47.596', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (127, '2025-04-11 01:25:20.628', '2025-04-11 01:25:20.628', '2025-04-11 01:25:47.596', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (128, '2025-04-11 01:25:47.658', '2025-04-11 01:25:47.658', '2025-04-11 01:30:02.824', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (129, '2025-04-11 01:25:47.720', '2025-04-11 01:25:47.720', '2025-04-11 01:30:02.824', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (130, '2025-04-11 01:30:02.889', '2025-04-11 01:30:02.889', '2025-04-11 01:30:33.693', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (131, '2025-04-11 01:30:02.958', '2025-04-11 01:30:02.958', '2025-04-11 01:30:33.693', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (132, '2025-04-11 01:30:33.755', '2025-04-11 01:30:33.755', '2025-04-11 01:31:07.351', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (133, '2025-04-11 01:30:33.817', '2025-04-11 01:30:33.817', '2025-04-11 01:31:07.351', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (134, '2025-04-11 01:31:07.413', '2025-04-11 01:31:07.413', '2025-04-11 01:38:52.852', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (135, '2025-04-11 01:31:07.475', '2025-04-11 01:31:07.475', '2025-04-11 01:38:52.852', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (136, '2025-04-11 01:38:52.914', '2025-04-11 01:38:52.914', '2025-04-11 01:40:54.479', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (137, '2025-04-11 01:38:52.976', '2025-04-11 01:38:52.976', '2025-04-11 01:40:54.479', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (138, '2025-04-11 01:40:54.541', '2025-04-11 01:40:54.541', '2025-04-11 01:41:30.478', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (139, '2025-04-11 01:40:54.603', '2025-04-11 01:40:54.603', '2025-04-11 01:41:30.478', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (140, '2025-04-11 01:41:30.540', '2025-04-11 01:41:30.540', '2025-04-11 01:41:57.629', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (141, '2025-04-11 01:41:30.602', '2025-04-11 01:41:30.602', '2025-04-11 01:41:57.629', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (142, '2025-04-11 01:41:57.691', '2025-04-11 01:41:57.691', '2025-04-11 01:43:23.800', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (143, '2025-04-11 01:41:57.753', '2025-04-11 01:41:57.753', '2025-04-11 01:43:23.800', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (144, '2025-04-11 01:43:23.862', '2025-04-11 01:43:23.862', '2025-04-11 01:44:26.322', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (145, '2025-04-11 01:43:23.924', '2025-04-11 01:43:23.924', '2025-04-11 01:44:26.322', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (146, '2025-04-11 01:44:26.385', '2025-04-11 01:44:26.385', '2025-04-11 01:44:53.243', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (147, '2025-04-11 01:44:26.446', '2025-04-11 01:44:26.446', '2025-04-11 01:44:53.243', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (148, '2025-04-11 01:44:53.305', '2025-04-11 01:44:53.305', '2025-04-11 01:46:40.974', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (149, '2025-04-11 01:44:53.366', '2025-04-11 01:44:53.366', '2025-04-11 01:46:40.974', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (150, '2025-04-11 01:46:41.036', '2025-04-11 01:46:41.036', '2025-04-11 01:46:50.075', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (151, '2025-04-11 01:46:41.097', '2025-04-11 01:46:41.097', '2025-04-11 01:46:50.075', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (152, '2025-04-11 01:46:50.137', '2025-04-11 01:46:50.137', '2025-04-11 01:46:56.547', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (153, '2025-04-11 01:46:50.199', '2025-04-11 01:46:50.199', '2025-04-11 01:46:56.547', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (154, '2025-04-11 01:46:56.610', '2025-04-11 01:46:56.610', '2025-04-12 02:16:58.498', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (155, '2025-04-11 01:46:56.671', '2025-04-11 01:46:56.671', '2025-04-12 02:16:58.498', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (156, '2025-04-12 02:16:58.568', '2025-04-12 02:16:58.568', '2025-04-12 02:17:13.975', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (157, '2025-04-12 02:16:58.638', '2025-04-12 02:16:58.638', '2025-04-12 02:17:13.975', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (158, '2025-04-12 02:17:14.045', '2025-04-12 02:17:14.045', '2025-04-12 02:17:25.080', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (159, '2025-04-12 02:17:14.115', '2025-04-12 02:17:14.115', '2025-04-12 02:17:25.080', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (160, '2025-04-12 02:17:25.150', '2025-04-12 02:17:25.150', '2025-04-12 02:17:28.738', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[12]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (161, '2025-04-12 02:17:25.219', '2025-04-12 02:17:25.219', '2025-04-12 02:17:28.738', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (162, '2025-04-12 02:17:28.808', '2025-04-12 02:17:28.808', '2025-04-12 02:17:58.169', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[12]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (163, '2025-04-12 02:17:28.877', '2025-04-12 02:17:28.877', '2025-04-12 02:17:58.169', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    ListNode  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3\n    node3 := &ListNode{Val: 3, Next: nil}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[13]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"ListNode\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (164, '2025-04-12 02:17:58.239', '2025-04-12 02:17:58.239', '2025-04-13 23:44:09.997', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[12]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (165, '2025-04-12 02:17:58.308', '2025-04-12 02:17:58.308', '2025-04-13 23:44:09.997', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    node5 := &ListNode{Val: 5, Next: nil}\n    node4 := &ListNode{Val: 4, Next: node5}\n    node3 := &ListNode{Val: 3, Next: node4}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[13]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (166, '2025-04-13 23:44:10.056', '2025-04-13 23:44:10.056', '2025-04-13 23:44:25.433', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[12]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (167, '2025-04-13 23:44:10.135', '2025-04-13 23:44:10.135', '2025-04-13 23:44:25.433', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    node5 := &ListNode{Val: 5, Next: nil}\n    node4 := &ListNode{Val: 4, Next: node5}\n    node3 := &ListNode{Val: 3, Next: node4}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[13]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (168, '2025-04-13 23:44:25.492', '2025-04-13 23:44:25.492', '2025-04-13 23:44:56.340', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *prev = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[12]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (169, '2025-04-13 23:44:25.550', '2025-04-13 23:44:25.550', '2025-04-13 23:44:56.340', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    node5 := &ListNode{Val: 5, Next: nil}\n    node4 := &ListNode{Val: 4, Next: node5}\n    node3 := &ListNode{Val: 3, Next: node4}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[13]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (170, '2025-04-13 23:44:56.399', '2025-04-13 23:44:56.399', '2025-04-13 23:45:07.146', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *newHead = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        newHead = curr;\n        curr = nextNode;\n    }\n    return newHead;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[12]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (171, '2025-04-13 23:44:56.457', '2025-04-13 23:44:56.457', '2025-04-13 23:45:07.146', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = nextNode\n    }\n    return prev\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    node5 := &ListNode{Val: 5, Next: nil}\n    node4 := &ListNode{Val: 4, Next: node5}\n    node3 := &ListNode{Val: 3, Next: node4}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[13]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (172, '2025-04-13 23:45:07.205', '2025-04-13 23:45:07.205', '2025-04-13 23:45:12.011', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *newHead = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = prev;\n        newHead = curr;\n        curr = nextNode;\n    }\n    return newHead;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[12]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (173, '2025-04-13 23:45:07.264', '2025-04-13 23:45:07.264', '2025-04-13 23:45:12.011', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = nextNode\n    }\n    return newHead\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    node5 := &ListNode{Val: 5, Next: nil}\n    node4 := &ListNode{Val: 4, Next: node5}\n    node3 := &ListNode{Val: 3, Next: node4}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[13]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (174, '2025-04-13 23:45:12.070', '2025-04-13 23:45:12.070', '2025-04-13 23:45:36.020', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *newHead = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = newHead;\n        newHead = curr;\n        curr = nextNode;\n    }\n    return newHead;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[12]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (175, '2025-04-13 23:45:12.128', '2025-04-13 23:45:12.128', '2025-04-13 23:45:36.020', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = nextNode\n    }\n    return newHead\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    node5 := &ListNode{Val: 5, Next: nil}\n    node4 := &ListNode{Val: 4, Next: node5}\n    node3 := &ListNode{Val: 3, Next: node4}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[13]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (176, '2025-04-13 23:45:36.079', '2025-04-13 23:45:36.079', '2025-04-24 01:23:41.103', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *newHead = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = newHead;\n        newHead = curr;\n        curr = nextNode;\n    }\n    return newHead;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[12]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (177, '2025-04-13 23:45:36.147', '2025-04-13 23:45:36.147', '2025-04-24 01:23:41.103', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = nextNode\n    }\n    return newHead\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    node5 := &ListNode{Val: 5, Next: nil}\n    node4 := &ListNode{Val: 4, Next: node5}\n    node3 := &ListNode{Val: 3, Next: node4}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[13]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (178, '2025-04-20 22:59:59.656', '2025-04-20 22:59:59.656', '2025-04-20 23:00:03.645', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (179, '2025-04-20 23:00:03.720', '2025-04-20 23:00:03.720', '2025-04-20 23:00:08.383', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (180, '2025-04-20 23:00:03.794', '2025-04-20 23:00:03.794', '2025-04-20 23:00:08.383', 67, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (181, '2025-04-20 23:00:08.458', '2025-04-20 23:00:08.458', '2025-04-20 23:00:29.660', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (182, '2025-04-20 23:00:08.532', '2025-04-20 23:00:08.532', '2025-04-20 23:00:29.660', 67, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (183, '2025-04-20 23:00:29.728', '2025-04-20 23:00:29.728', '2025-04-20 23:03:34.891', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (184, '2025-04-20 23:00:29.796', '2025-04-20 23:00:29.796', '2025-04-20 23:03:34.891', 67, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n    node5 := &ListNode{Val: 5, Next: nil}\n    node4 := &ListNode{Val: 4, Next: node5}\n    node3 := &ListNode{Val: 3, Next: node4}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (185, '2025-04-20 23:03:34.959', '2025-04-20 23:03:34.959', '2025-04-20 23:10:48.533', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (186, '2025-04-20 23:03:35.027', '2025-04-20 23:03:35.027', '2025-04-20 23:10:48.533', 67, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n	var head *ListNode\n	var tail *ListNode\n	for i := 0; i < 8; i++ {\n		node := &ListNode {Val: i}\n		if head == nil {\n			head = node\n			tail = node\n		} else {\n			tail.Next = node\n			tail = tail.Next\n		}\n	}\n\n    fmt.Print(\"原始链表: \")\n    printList(head)\n\n    reversedHead := reverseList(head)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (187, '2025-04-20 23:10:48.608', '2025-04-20 23:10:48.608', '2025-04-20 23:11:03.086', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (188, '2025-04-20 23:10:48.682', '2025-04-20 23:10:48.682', '2025-04-20 23:11:03.086', 67, 'package main\nimport (\n	\"fmt\"\n)\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n	var head *ListNode\n	var tail *ListNode\n	for i := 0; i < 8; i++ {\n		node := &ListNode {Val: i}\n		if head == nil {\n			head = node\n			tail = node\n		} else {\n			tail.Next = node\n			tail = tail.Next\n		}\n	}\n\n    fmt.Print(\"原始链表: \")\n    printList(head)\n\n    reversedHead := reverseBetween(head, 1, 4)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}\n\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (189, '2025-04-20 23:11:03.160', '2025-04-20 23:11:03.160', '2025-04-20 23:11:05.147', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (190, '2025-04-20 23:11:03.234', '2025-04-20 23:11:03.234', '2025-04-20 23:11:05.147', 67, 'package main\nimport (\n	\"fmt\"\n)\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n	var head *ListNode\n	var tail *ListNode\n	for i := 0; i < 8; i++ {\n		node := &ListNode {Val: i}\n		if head == nil {\n			head = node\n			tail = node\n		} else {\n			tail.Next = node\n			tail = tail.Next\n		}\n	}\n\n    fmt.Print(\"原始链表: \")\n    printList(head)\n\n    reversedHead := reverseBetween(head, 1, 4)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}\n\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (191, '2025-04-20 23:11:05.222', '2025-04-20 23:11:05.222', '2025-04-20 23:12:10.978', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (192, '2025-04-20 23:11:05.296', '2025-04-20 23:11:05.296', '2025-04-20 23:12:10.978', 67, 'package main\nimport (\n	\"fmt\"\n)\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n	var head *ListNode\n	var tail *ListNode\n	for i := 0; i < 8; i++ {\n		node := &ListNode {Val: i}\n		if head == nil {\n			head = node\n			tail = node\n		} else {\n			tail.Next = node\n			tail = tail.Next\n		}\n	}\n\n    fmt.Print(\"原始链表: \")\n    printList(head)\n\n    reversedHead := reverseBetween(head, 1, 4)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}\n\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (193, '2025-04-20 23:12:11.047', '2025-04-20 23:12:11.047', '2025-04-24 01:23:23.668', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (194, '2025-04-20 23:12:11.117', '2025-04-20 23:12:11.117', '2025-04-24 01:23:23.668', 67, 'package main\nimport (\n	\"fmt\"\n)\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n	var head *ListNode\n	var tail *ListNode\n	for i := 0; i < 8; i++ {\n		node := &ListNode {Val: i}\n		if head == nil {\n			head = node\n			tail = node\n		} else {\n			tail.Next = node\n			tail = tail.Next\n		}\n	}\n\n    fmt.Print(\"原始链表: \")\n    printList(head)\n\n    reversedHead := reverseBetween(head, 1, 4)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (195, '2025-04-24 01:23:23.759', '2025-04-24 01:23:23.759', '2025-04-24 01:23:55.091', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (196, '2025-04-24 01:23:23.819', '2025-04-24 01:23:23.819', '2025-04-24 01:23:55.091', 67, 'package main\nimport (\n	\"fmt\"\n)\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n	var head *ListNode\n	var tail *ListNode\n	for i := 0; i < 8; i++ {\n		node := &ListNode {Val: i}\n		if head == nil {\n			head = node\n			tail = node\n		} else {\n			tail.Next = node\n			tail = tail.Next\n		}\n	}\n\n    fmt.Print(\"原始链表: \")\n    printList(head)\n\n    reversedHead := reverseBetween(head, 1, 4)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (197, '2025-04-24 01:23:41.164', '2025-04-24 01:23:41.164', '2025-05-14 01:18:07.835', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *newHead = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = newHead;\n        newHead = curr;\n        curr = nextNode;\n    }\n    return newHead;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[12]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (198, '2025-04-24 01:23:41.225', '2025-04-24 01:23:41.225', '2025-05-14 01:18:07.835', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = nextNode\n    }\n    return newHead\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    node5 := &ListNode{Val: 5, Next: nil}\n    node4 := &ListNode{Val: 4, Next: node5}\n    node3 := &ListNode{Val: 3, Next: node4}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[13]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (199, '2025-04-24 01:23:55.152', '2025-04-24 01:23:55.152', '2025-04-24 01:25:59.901', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (200, '2025-04-24 01:23:55.213', '2025-04-24 01:23:55.213', '2025-04-24 01:25:59.901', 67, 'package main\nimport (\n	\"fmt\"\n)\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n	var head *ListNode\n	var tail *ListNode\n	for i := 0; i < 8; i++ {\n		node := &ListNode {Val: i}\n		if head == nil {\n			head = node\n			tail = node\n		} else {\n			tail.Next = node\n			tail = tail.Next\n		}\n	}\n\n    fmt.Print(\"原始链表: \")\n    printList(head)\n\n    reversedHead := reverseBetween(head, 1, 4)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (201, '2025-04-24 01:25:59.962', '2025-04-24 01:25:59.962', '2025-04-24 01:36:33.637', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (202, '2025-04-24 01:26:00.022', '2025-04-24 01:26:00.022', '2025-04-24 01:36:33.637', 67, 'package main\nimport (\n	\"fmt\"\n)\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n	var head *ListNode\n	var tail *ListNode\n	for i := 0; i < 8; i++ {\n		node := &ListNode {Val: i}\n		if head == nil {\n			head = node\n			tail = node\n		} else {\n			tail.Next = node\n			tail = tail.Next\n		}\n	}\n\n    fmt.Print(\"原始链表: \")\n    printList(head)\n\n    reversedHead := reverseBetween(head, 1, 4)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (203, '2025-04-24 01:36:33.698', '2025-04-24 01:36:33.698', '2025-04-24 01:36:49.181', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (204, '2025-04-24 01:36:33.759', '2025-04-24 01:36:33.759', '2025-04-24 01:36:49.181', 67, 'package main\nimport (\n	\"fmt\"\n)\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n	var head *ListNode\n	var tail *ListNode\n	for i := 0; i < 8; i++ {\n		node := &ListNode {Val: i}\n		if head == nil {\n			head = node\n			tail = node\n		} else {\n			tail.Next = node\n			tail = tail.Next\n		}\n	}\n\n    fmt.Print(\"原始链表: \")\n    printList(head)\n\n    reversedHead := reverseBetween(head, 1, 4)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (205, '2025-04-24 01:36:49.242', '2025-04-24 01:36:49.242', '2025-05-14 01:21:07.588', 67, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (206, '2025-04-24 01:36:49.303', '2025-04-24 01:36:49.303', '2025-05-14 01:21:07.588', 67, 'package main\nimport (\n	\"fmt\"\n)\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n	var head *ListNode\n	var tail *ListNode\n	for i := 0; i < 8; i++ {\n		node := &ListNode {Val: i}\n		if head == nil {\n			head = node\n			tail = node\n		} else {\n			tail.Next = node\n			tail = tail.Next\n		}\n	}\n\n    fmt.Print(\"原始链表: \")\n    printList(head)\n\n    reversedHead := reverseBetween(head, 1, 4)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (207, '2025-04-26 20:29:29.896', '2025-04-26 20:29:29.896', '2025-08-16 21:54:56.320', 68, '#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (208, '2025-04-26 20:29:51.783', '2025-04-26 20:29:51.783', '2025-04-26 20:30:25.673', 69, '#include <stdio.h>\n\nint main() {\n    // 整数类型\n    int integer_num = 10;\n    short short_num = 20;\n    long long_num = 30;\n    long long long_long_num = 40LL;\n    unsigned int unsigned_num = 100;\n\n    // 浮点类型\n    float float_num = 3.14f;\n    double double_num = 3.14159;\n    long double long_double_num = 3.1415926L;\n\n    // 字符类型\n    char char_letter = \'A\';\n    signed char signed_char_letter = \'B\';\n    unsigned char unsigned_char_letter = \'C\';\n\n    // 布尔类型（C99 引入）\n    _Bool bool_value = 1;\n\n    // 输出整数类型的值\n    printf(\"整数类型的值: %d\\n\", integer_num);\n    printf(\"短整数类型的值: %hd\\n\", short_num);\n    printf(\"长整数类型的值: %ld\\n\", long_num);\n    printf(\"长长整数类型的值: %lld\\n\", long_long_num);\n    printf(\"无符号整数类型的值: %u\\n\", unsigned_num);\n\n    // 输出浮点类型的值\n    printf(\"单精度浮点类型的值: %f\\n\", float_num);\n    printf(\"双精度浮点类型的值: %lf\\n\", double_num);\n    printf(\"长双精度浮点类型的值: %Lf\\n\", long_double_num);\n\n    // 输出字符类型的值\n    printf(\"字符类型的值: %c\\n\", char_letter);\n    printf(\"有符号字符类型的值: %c\\n\", signed_char_letter);\n    printf(\"无符号字符类型的值: %c\\n\", unsigned_char_letter);\n\n    // 输出布尔类型的值\n    printf(\"布尔类型的值: %d\\n\", bool_value);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (209, '2025-04-26 20:30:25.723', '2025-04-26 20:30:25.723', '2025-04-26 20:48:50.091', 69, '#include <stdio.h>\n\nint main() {\n    // 整数类型\n    int integer_num = 10;\n    short short_num = 20;\n    long long_num = 30;\n    long long long_long_num = 40LL;\n    unsigned int unsigned_num = 100;\n\n    // 浮点类型\n    float float_num = 3.14f;\n    double double_num = 3.14159;\n    long double long_double_num = 3.1415926L;\n\n    // 字符类型\n    char char_letter = \'A\';\n    signed char signed_char_letter = \'B\';\n    unsigned char unsigned_char_letter = \'C\';\n\n    // 布尔类型（C99 引入）\n    _Bool bool_value = 1;\n\n    // 输出整数类型的值\n    printf(\"整数类型的值: %d\\n\", integer_num);\n    printf(\"短整数类型的值: %hd\\n\", short_num);\n    printf(\"长整数类型的值: %ld\\n\", long_num);\n    printf(\"长长整数类型的值: %lld\\n\", long_long_num);\n    printf(\"无符号整数类型的值: %u\\n\", unsigned_num);\n\n    // 输出浮点类型的值\n    printf(\"单精度浮点类型的值: %f\\n\", float_num);\n    printf(\"双精度浮点类型的值: %lf\\n\", double_num);\n    printf(\"长双精度浮点类型的值: %Lf\\n\", long_double_num);\n\n    // 输出字符类型的值\n    printf(\"字符类型的值: %c\\n\", char_letter);\n    printf(\"有符号字符类型的值: %c\\n\", signed_char_letter);\n    printf(\"无符号字符类型的值: %c\\n\", unsigned_char_letter);\n\n    // 输出布尔类型的值\n    printf(\"布尔类型的值: %d\\n\", bool_value);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (210, '2025-04-26 20:31:37.006', '2025-04-26 20:31:37.006', '2025-04-26 20:33:01.007', 70, '#include <stdio.h>\n\nint main() {\n    int a = 10;\n    int b = 3;\n\n    int sum = a + b;\n    int difference = a - b;\n    int product = a * b;\n    int quotient = a / b;\n    int remainder = a % b;\n\n    printf(\"加法结果: %d\\n\", sum);\n    printf(\"减法结果: %d\\n\", difference);\n    printf(\"乘法结果: %d\\n\", product);\n    printf(\"除法结果: %d\\n\", quotient);\n    printf(\"取模结果: %d\\n\", remainder);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (211, '2025-04-26 20:33:01.076', '2025-04-26 20:33:01.076', NULL, 70, '#include <stdio.h>\n\nint main() {\n    int a = 10;\n    int b = 3;\n\n    int sum = a + b;\n    int difference = a - b;\n    int product = a * b;\n    int quotient = a / b;\n    int remainder = a % b;\n\n    printf(\"加法结果: %d\\n\", sum);\n    printf(\"减法结果: %d\\n\", difference);\n    printf(\"乘法结果: %d\\n\", product);\n    printf(\"除法结果: %d\\n\", quotient);\n    printf(\"取模结果: %d\\n\", remainder);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (212, '2025-04-26 20:42:06.465', '2025-04-26 20:42:06.465', '2025-04-26 20:49:59.986', 71, '#include <stdio.h>\n\nint main() {\n    int num = 12;\n    if (num > 10) {\n        printf(\"num大于10\\n\");\n    }\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (213, '2025-04-26 20:42:59.505', '2025-04-26 20:42:59.505', '2025-04-26 20:43:01.361', 72, '#include <stdio.h>\n\nint main() {\n    // 使用 for 循环打印 1 到 5 的整数\n    for (int i = 1; i <= 5; i++) {\n        printf(\"%d \", i);\n    }\n    printf(\"\\n\");\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (214, '2025-04-26 20:43:01.411', '2025-04-26 20:43:01.411', '2025-04-26 20:50:18.331', 72, '#include <stdio.h>\n\nint main() {\n    // 使用 for 循环打印 1 到 5 的整数\n    for (int i = 1; i <= 5; i++) {\n        printf(\"%d \", i);\n    }\n    printf(\"\\n\");\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (215, '2025-04-26 20:44:29.879', '2025-04-26 20:44:29.879', '2025-04-26 20:44:31.480', 73, '#include <stdio.h>\n\nint main() {\n    // 定义一个包含 5 个整数的一维数组\n    int arr[5];\n\n    // 初始化数组元素\n    arr[0] = 10;\n    arr[1] = 20;\n    arr[2] = 30;\n    arr[3] = 40;\n    arr[4] = 50;\n\n    // 访问并输出数组元素\n    for (int i = 0; i < 5; i++) {\n        printf(\"arr[%d] = %d\\n\", i, arr[i]);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (216, '2025-04-26 20:44:31.530', '2025-04-26 20:44:31.530', '2025-04-26 20:50:36.520', 73, '#include <stdio.h>\n\nint main() {\n    // 定义一个包含 5 个整数的一维数组\n    int arr[5];\n\n    // 初始化数组元素\n    arr[0] = 10;\n    arr[1] = 20;\n    arr[2] = 30;\n    arr[3] = 40;\n    arr[4] = 50;\n\n    // 访问并输出数组元素\n    for (int i = 0; i < 5; i++) {\n        printf(\"arr[%d] = %d\\n\", i, arr[i]);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (217, '2025-04-26 20:46:05.303', '2025-04-26 20:46:05.303', '2025-04-26 20:46:07.466', 74, '#include <stdio.h>\n\n// 函数定义：计算两个整数的和\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int num1 = 5, num2 = 3;\n    // 函数调用\n    int result = add(num1, num2);\n    printf(\"两数之和为: %d\\n\", result);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (218, '2025-04-26 20:46:07.516', '2025-04-26 20:46:07.516', '2025-04-26 20:51:03.375', 74, '#include <stdio.h>\n\n// 函数定义：计算两个整数的和\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int num1 = 5, num2 = 3;\n    // 函数调用\n    int result = add(num1, num2);\n    printf(\"两数之和为: %d\\n\", result);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (219, '2025-04-26 20:47:28.079', '2025-04-26 20:47:28.079', '2025-04-26 20:47:29.460', 75, '#include <stdio.h>\n#include <string.h>\n\n// 定义结构体\nstruct Student {\n    char name[20];\n    int age;\n    float score;\n};\n\nint main() {\n    // 定义结构体变量\n    struct Student stu;\n    // 给结构体成员赋值\n    strcpy(stu.name, \"Alice\");\n    stu.age = 20;\n    stu.score = 88.5;\n\n    // 输出结构体成员信息\n    printf(\"姓名: %s\\n\", stu.name);\n    printf(\"年龄: %d\\n\", stu.age);\n    printf(\"成绩: %.2f\\n\", stu.score);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (220, '2025-04-26 20:47:29.510', '2025-04-26 20:47:29.510', '2025-04-26 20:51:32.714', 75, '#include <stdio.h>\n#include <string.h>\n\n// 定义结构体\nstruct Student {\n    char name[20];\n    int age;\n    float score;\n};\n\nint main() {\n    // 定义结构体变量\n    struct Student stu;\n    // 给结构体成员赋值\n    strcpy(stu.name, \"Alice\");\n    stu.age = 20;\n    stu.score = 88.5;\n\n    // 输出结构体成员信息\n    printf(\"姓名: %s\\n\", stu.name);\n    printf(\"年龄: %d\\n\", stu.age);\n    printf(\"成绩: %.2f\\n\", stu.score);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (221, '2025-04-26 20:48:50.146', '2025-04-26 20:48:50.146', NULL, 69, '#include <stdio.h>\n\nint main() {\n    // 整数类型\n    int integer_num = 10;\n    short short_num = 20;\n    long long_num = 30;\n    long long long_long_num = 40LL;\n    unsigned int unsigned_num = 100;\n\n    // 浮点类型\n    float float_num = 3.14f;\n    double double_num = 3.14159;\n    long double long_double_num = 3.1415926L;\n\n    // 字符类型\n    char char_letter = \'A\';\n    signed char signed_char_letter = \'B\';\n    unsigned char unsigned_char_letter = \'C\';\n\n    // 布尔类型（C99 引入）\n    _Bool bool_value = 1;\n\n    // 输出整数类型的值\n    printf(\"整数类型的值: %d\\n\", integer_num);\n    printf(\"短整数类型的值: %hd\\n\", short_num);\n    printf(\"长整数类型的值: %ld\\n\", long_num);\n    printf(\"长长整数类型的值: %lld\\n\", long_long_num);\n    printf(\"无符号整数类型的值: %u\\n\", unsigned_num);\n\n    // 输出浮点类型的值\n    printf(\"单精度浮点类型的值: %f\\n\", float_num);\n    printf(\"双精度浮点类型的值: %lf\\n\", double_num);\n    printf(\"长双精度浮点类型的值: %Lf\\n\", long_double_num);\n\n    // 输出字符类型的值\n    printf(\"字符类型的值: %c\\n\", char_letter);\n    printf(\"有符号字符类型的值: %c\\n\", signed_char_letter);\n    printf(\"无符号字符类型的值: %c\\n\", unsigned_char_letter);\n\n    // 输出布尔类型的值\n    printf(\"布尔类型的值: %d\\n\", bool_value);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (222, '2025-04-26 20:50:00.041', '2025-04-26 20:50:00.041', '2025-08-24 18:25:04.224', 71, '#include <stdio.h>\n\nint main() {\n    int num = 12;\n    if (num > 10) {\n        printf(\"num大于10\\n\");\n    }\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (223, '2025-04-26 20:50:18.386', '2025-04-26 20:50:18.386', NULL, 72, '#include <stdio.h>\n\nint main() {\n    // 使用 for 循环打印 1 到 5 的整数\n    for (int i = 1; i <= 5; i++) {\n        printf(\"%d \", i);\n    }\n    printf(\"\\n\");\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (224, '2025-04-26 20:50:36.575', '2025-04-26 20:50:36.575', NULL, 73, '#include <stdio.h>\n\nint main() {\n    // 定义一个包含 5 个整数的一维数组\n    int arr[5];\n\n    // 初始化数组元素\n    arr[0] = 10;\n    arr[1] = 20;\n    arr[2] = 30;\n    arr[3] = 40;\n    arr[4] = 50;\n\n    // 访问并输出数组元素\n    for (int i = 0; i < 5; i++) {\n        printf(\"arr[%d] = %d\\n\", i, arr[i]);\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (225, '2025-04-26 20:51:03.430', '2025-04-26 20:51:03.430', NULL, 74, '#include <stdio.h>\n\n// 函数定义：计算两个整数的和\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int num1 = 5, num2 = 3;\n    // 函数调用\n    int result = add(num1, num2);\n    printf(\"两数之和为: %d\\n\", result);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (226, '2025-04-26 20:51:32.769', '2025-04-26 20:51:32.769', '2025-04-26 20:51:44.731', 75, '#include <stdio.h>\n#include <string.h>\n\n// 定义结构体\nstruct Student {\n    char name[20];\n    int age;\n    float score;\n};\n\nint main() {\n    // 定义结构体变量\n    struct Student stu;\n    // 给结构体成员赋值\n    strcpy(stu.name, \"Alice\");\n    stu.age = 20;\n    stu.score = 88.5;\n\n    // 输出结构体成员信息\n    printf(\"姓名: %s\\n\", stu.name);\n    printf(\"年龄: %d\\n\", stu.age);\n    printf(\"成绩: %.2f\\n\", stu.score);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (227, '2025-04-26 20:51:44.785', '2025-04-26 20:51:44.785', NULL, 75, '#include <stdio.h>\n#include <string.h>\n\n// 定义结构体\nstruct Student {\n    char name[20];\n    int age;\n    float score;\n};\n\nint main() {\n    // 定义结构体变量\n    struct Student stu;\n    // 给结构体成员赋值\n    strcpy(stu.name, \"Alice\");\n    stu.age = 20;\n    stu.score = 88.5;\n\n    // 输出结构体成员信息\n    printf(\"姓名: %s\\n\", stu.name);\n    printf(\"年龄: %d\\n\", stu.age);\n    printf(\"成绩: %.2f\\n\", stu.score);\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (228, '2025-04-26 20:55:36.051', '2025-04-26 20:55:36.051', '2025-04-26 20:55:37.057', 76, '#include <stdio.h>\n\nint main() {\n    int num = 10;\n    int *p = &num;  // 声明并初始化指针\n    printf(\"num 的值是: %d\\n\", *p);  // 解引用指针，输出 num 的值\n    *p = 20;  // 通过指针修改 num 的值\n    printf(\"修改后 num 的值是: %d\\n\", num);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (229, '2025-04-26 20:55:37.112', '2025-04-26 20:55:37.112', NULL, 76, '#include <stdio.h>\n\nint main() {\n    int num = 10;\n    int *p = &num;  // 声明并初始化指针\n    printf(\"num 的值是: %d\\n\", *p);  // 解引用指针，输出 num 的值\n    *p = 20;  // 通过指针修改 num 的值\n    printf(\"修改后 num 的值是: %d\\n\", num);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (230, '2025-04-26 20:56:19.193', '2025-04-26 20:56:19.193', '2025-08-24 17:52:32.679', 62, '#include <stdio.h>\nint main() {\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (231, '2025-04-27 23:33:28.330', '2025-04-27 23:33:28.330', '2025-04-27 23:35:07.931', 77, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (232, '2025-04-27 23:33:28.400', '2025-04-27 23:33:28.400', '2025-04-27 23:35:07.931', 77, 'package main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	a := 0\n	b := 0\n	for {\n		n, _ := fmt.Scan(&a, &b)\n		if n == 0 {\n			break\n		} else {\n			fmt.Printf(\"%d\n\", a+b)\n		}\n	}\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (233, '2025-04-27 23:35:08.001', '2025-04-27 23:35:08.001', '2025-04-27 23:35:30.036', 77, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (234, '2025-04-27 23:35:08.071', '2025-04-27 23:35:08.071', '2025-04-27 23:35:30.036', 77, 'package main\n\nimport \"fmt\"\n\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 2, 3, 4, 5, 7, 9, 12}\n    target := 3\n\n    answer := BinarySearch(arr, target)\n    fmt.Printf(\"二分结果: %d\\n\", answer)\n}', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (235, '2025-04-27 23:35:30.106', '2025-04-27 23:35:30.106', '2025-04-27 23:37:11.900', 77, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (236, '2025-04-27 23:35:30.176', '2025-04-27 23:35:30.176', '2025-04-27 23:37:11.900', 77, 'package main\n\nimport \"fmt\"\n\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 2, 3, 4, 5, 7, 9, 12}\n    target := 3\n\n    answer := BinarySearch(arr, target)\n    fmt.Printf(\"二分结果: %d\\n\", answer)\n}', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\"]}}');
INSERT INTO `visual_document_codes` VALUES (237, '2025-04-27 23:37:11.970', '2025-04-27 23:37:11.970', '2025-04-27 23:37:26.374', 77, '#include <stdio.h>\n\n// 二分查找函数\nint BinarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n// 测试函数\nint main() {\n    // 定义一个有序数组\n    int arr[] = {1, 3, 5, 7, 9, 11, 13};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    // 测试用例 1：查找存在的元素\n    int target1 = 7;\n    int result1 = BinarySearch(arr, size, target1);\n    if (result1 != -1) {\n        printf(\"元素 %d 在数组中的索引是 %d\\n\", target1, result1);\n    } else {\n        printf(\"元素 %d 不在数组中\\n\", target1);\n    }\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (238, '2025-04-27 23:37:12.040', '2025-04-27 23:37:12.040', '2025-04-27 23:37:26.374', 77, 'package main\n\nimport \"fmt\"\n\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 2, 3, 4, 5, 7, 9, 12}\n    target := 3\n\n    answer := BinarySearch(arr, target)\n    fmt.Printf(\"二分结果: %d\\n\", answer)\n}', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\"]}}');
INSERT INTO `visual_document_codes` VALUES (239, '2025-04-27 23:37:26.444', '2025-04-27 23:37:26.444', '2025-04-27 23:37:35.203', 77, '#include <stdio.h>\n\n// 二分查找函数\nint BinarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n// 测试函数\nint main() {\n    // 定义一个有序数组\n    int arr[] = {1, 3, 5, 7, 9, 11, 13};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    // 测试用例 1：查找存在的元素\n    int target1 = 7;\n    int result1 = BinarySearch(arr, size, target1);\n    if (result1 != -1) {\n        printf(\"元素 %d 在数组中的索引是 %d\\n\", target1, result1);\n    } else {\n        printf(\"元素 %d 不在数组中\\n\", target1);\n    }\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (240, '2025-04-27 23:37:26.514', '2025-04-27 23:37:26.514', '2025-04-27 23:37:35.203', 77, 'package main\n\nimport \"fmt\"\n\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 2, 3, 4, 5, 7, 9, 12}\n    target := 3\n\n    answer := BinarySearch(arr, target)\n    fmt.Printf(\"二分结果: %d\\n\", answer)\n}', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\"]}}');
INSERT INTO `visual_document_codes` VALUES (241, '2025-04-27 23:37:35.275', '2025-04-27 23:37:35.275', '2025-04-27 23:38:30.754', 77, '#include <stdio.h>\n\n// 二分查找函数\nint BinarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n// 测试函数\nint main() {\n    // 定义一个有序数组\n    int arr[] = {1, 3, 5, 7, 9, 11, 13};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    // 测试用例 1：查找存在的元素\n    int target1 = 7;\n    int result1 = BinarySearch(arr, size, target1);\n    if (result1 != -1) {\n        printf(\"元素 %d 在数组中的索引是 %d\\n\", target1, result1);\n    } else {\n        printf(\"元素 %d 不在数组中\\n\", target1);\n    }\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (242, '2025-04-27 23:37:35.345', '2025-04-27 23:37:35.345', '2025-04-27 23:38:30.754', 77, 'package main\n\nimport \"fmt\"\n\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 2, 3, 4, 5, 7, 9, 12}\n    target := 3\n\n    answer := BinarySearch(arr, target)\n    fmt.Printf(\"二分结果: %d\\n\", answer)\n}', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (243, '2025-04-27 23:38:30.810', '2025-04-27 23:38:30.810', '2025-04-27 23:39:05.698', 77, '#include <stdio.h>\n\n// 二分查找函数\nint BinarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n// 测试函数\nint main() {\n    // 定义一个有序数组\n    int arr[] = {1, 3, 5, 7, 9, 11, 13};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    // 测试用例 1：查找存在的元素\n    int target1 = 7;\n    int result1 = BinarySearch(arr, size, target1);\n    if (result1 != -1) {\n        printf(\"元素 %d 在数组中的索引是 %d\\n\", target1, result1);\n    } else {\n        printf(\"元素 %d 不在数组中\\n\", target1);\n    }\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (244, '2025-04-27 23:38:30.866', '2025-04-27 23:38:30.866', '2025-04-27 23:39:05.698', 77, 'package main\n\nimport \"fmt\"\n\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 2, 3, 4, 5, 7, 9, 12}\n    target := 3\n\n    answer := BinarySearch(arr, target)\n    fmt.Printf(\"二分结果: %d\\n\", answer)\n}', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (245, '2025-04-27 23:39:05.754', '2025-04-27 23:39:05.754', '2025-04-27 23:39:36.296', 77, '#include <stdio.h>\n\n// 二分查找函数\nint BinarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n// 测试函数\nint main() {\n    // 定义一个有序数组\n    int arr[] = {1, 3, 5, 7, 9, 11, 13};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    // 测试用例 1：查找存在的元素\n    int target1 = 7;\n    int result1 = BinarySearch(arr, size, target1);\n    if (result1 != -1) {\n        printf(\"元素 %d 在数组中的索引是 %d\\n\", target1, result1);\n    } else {\n        printf(\"元素 %d 不在数组中\\n\", target1);\n    }\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (246, '2025-04-27 23:39:05.809', '2025-04-27 23:39:05.809', '2025-04-27 23:39:36.296', 77, 'package main\n\nimport \"fmt\"\n\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 2, 3, 4, 5, 7, 9, 12}\n    target := 3\n\n    answer := BinarySearch(arr, target)\n    fmt.Printf(\"二分结果: %d\\n\", answer)\n}', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (247, '2025-04-27 23:39:36.355', '2025-04-27 23:39:36.355', '2025-04-27 23:40:29.163', 77, '#include <stdio.h>\n\n// 二分查找函数\nint BinarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n// 测试函数\nint main() {\n    // 定义一个有序数组\n    int arr[] = {1, 3, 5, 7, 9, 11, 13};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    // 测试用例 1：查找存在的元素\n    int target1 = 7;\n    int result1 = BinarySearch(arr, size, target1);\n    if (result1 != -1) {\n        printf(\"元素 %d 在数组中的索引是 %d\\n\", target1, result1);\n    } else {\n        printf(\"元素 %d 不在数组中\\n\", target1);\n    }\n    return 0;\n}', 'c', '[7]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (248, '2025-04-27 23:39:36.414', '2025-04-27 23:39:36.414', '2025-04-27 23:40:29.163', 77, 'package main\n\nimport \"fmt\"\n\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 2, 3, 4, 5, 7, 9, 12}\n    target := 3\n\n    answer := BinarySearch(arr, target)\n    fmt.Printf(\"二分结果: %d\\n\", answer)\n}', 'go', '[7]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (249, '2025-04-27 23:40:29.224', '2025-04-27 23:40:29.224', '2025-04-27 23:40:33.518', 77, '#include <stdio.h>\n\n// 二分查找函数\nint BinarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n// 测试函数\nint main() {\n    // 定义一个有序数组\n    int arr[] = {1, 3, 5, 7, 9, 11, 13};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    // 测试用例 1：查找存在的元素\n    int target1 = 7;\n    int result1 = BinarySearch(arr, size, target1);\n    if (result1 != -1) {\n        printf(\"元素 %d 在数组中的索引是 %d\\n\", target1, result1);\n    } else {\n        printf(\"元素 %d 不在数组中\\n\", target1);\n    }\n    return 0;\n}', 'c', '[7]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (250, '2025-04-27 23:40:29.285', '2025-04-27 23:40:29.285', '2025-04-27 23:40:33.518', 77, 'package main\n\nimport \"fmt\"\n\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 2, 3, 4, 5, 7, 9, 12}\n    target := 3\n\n    answer := BinarySearch(arr, target)\n    fmt.Printf(\"二分结果: %d\\n\", answer)\n}', 'go', '[7,9]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (251, '2025-04-27 23:40:33.579', '2025-04-27 23:40:33.579', '2025-05-14 01:19:05.169', 77, '#include <stdio.h>\n\n// 二分查找函数\nint BinarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n// 测试函数\nint main() {\n    // 定义一个有序数组\n    int arr[] = {1, 3, 5, 7, 9, 11, 13};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    // 测试用例 1：查找存在的元素\n    int target1 = 7;\n    int result1 = BinarySearch(arr, size, target1);\n    if (result1 != -1) {\n        printf(\"元素 %d 在数组中的索引是 %d\\n\", target1, result1);\n    } else {\n        printf(\"元素 %d 不在数组中\\n\", target1);\n    }\n    return 0;\n}', 'c', '[7,9]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (252, '2025-04-27 23:40:33.640', '2025-04-27 23:40:33.640', '2025-05-14 01:19:05.169', 77, 'package main\n\nimport \"fmt\"\n\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 2, 3, 4, 5, 7, 9, 12}\n    target := 3\n\n    answer := BinarySearch(arr, target)\n    fmt.Printf(\"二分结果: %d\\n\", answer)\n}', 'go', '[7,9]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (253, '2025-04-28 00:24:38.657', '2025-04-28 00:24:38.657', '2025-04-28 00:24:51.499', 78, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// addTwoNumbers 函数用于将两个链表表示的数字相加\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    carry := 0\n    var head *ListNode\n    var tail *ListNode\n    for l1 != nil || l2 != nil {\n        sum := carry\n        if l1 != nil {\n            sum += l1.Val\n            l1 = l1.Next\n        }\n        if l2 != nil {\n            sum += l2.Val\n            l2 = l2.Next\n        }\n        carry = sum / 10\n        node := &ListNode{\n            Val: sum % 10,\n        }\n        if head == nil {\n            head = node\n            tail = node\n        } else {\n            tail.Next = node\n            tail = tail.Next\n        }\n    }\n    if carry != 0 {\n        tail.Next = &ListNode{\n            Val: carry,\n        }\n    }\n    return head\n}\n\n// printList 函数用于打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        fmt.Print(head.Val, \" -> \")\n        head = head.Next\n    }\n    fmt.Println(\"nil\")\n}\n\nfunc main() {\n    // 构建第一个链表 2 -> 4 -> 3\n    l1 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 3}}}\n    // 构建第二个链表 5 -> 6 -> 4\n    l2 := &ListNode{Val: 5, Next: &ListNode{Val: 6, Next: &ListNode{Val: 4}}}\n\n    // 调用 addTwoNumbers 函数\n    result := addTwoNumbers(l1, l2)\n\n    // 打印结果链表\n    printList(result)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (254, '2025-04-28 00:24:51.558', '2025-04-28 00:24:51.558', '2025-04-28 00:24:52.897', 78, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// addTwoNumbers 函数用于将两个链表表示的数字相加\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    carry := 0\n    var head *ListNode\n    var tail *ListNode\n    for l1 != nil || l2 != nil {\n        sum := carry\n        if l1 != nil {\n            sum += l1.Val\n            l1 = l1.Next\n        }\n        if l2 != nil {\n            sum += l2.Val\n            l2 = l2.Next\n        }\n        carry = sum / 10\n        node := &ListNode{\n            Val: sum % 10,\n        }\n        if head == nil {\n            head = node\n            tail = node\n        } else {\n            tail.Next = node\n            tail = tail.Next\n        }\n    }\n    if carry != 0 {\n        tail.Next = &ListNode{\n            Val: carry,\n        }\n    }\n    return head\n}\n\n// printList 函数用于打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        fmt.Print(head.Val, \" -> \")\n        head = head.Next\n    }\n    fmt.Println(\"nil\")\n}\n\nfunc main() {\n    // 构建第一个链表 2 -> 4 -> 3\n    l1 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 3}}}\n    // 构建第二个链表 5 -> 6 -> 4\n    l2 := &ListNode{Val: 5, Next: &ListNode{Val: 6, Next: &ListNode{Val: 4}}}\n\n    // 调用 addTwoNumbers 函数\n    result := addTwoNumbers(l1, l2)\n\n    // 打印结果链表\n    printList(result)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (255, '2025-04-28 00:24:52.959', '2025-04-28 00:24:52.959', '2025-05-14 01:19:47.070', 78, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// addTwoNumbers 函数用于将两个链表表示的数字相加\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    carry := 0\n    var head *ListNode\n    var tail *ListNode\n    for l1 != nil || l2 != nil {\n        sum := carry\n        if l1 != nil {\n            sum += l1.Val\n            l1 = l1.Next\n        }\n        if l2 != nil {\n            sum += l2.Val\n            l2 = l2.Next\n        }\n        carry = sum / 10\n        node := &ListNode{\n            Val: sum % 10,\n        }\n        if head == nil {\n            head = node\n            tail = node\n        } else {\n            tail.Next = node\n            tail = tail.Next\n        }\n    }\n    if carry != 0 {\n        tail.Next = &ListNode{\n            Val: carry,\n        }\n    }\n    return head\n}\n\n// printList 函数用于打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        fmt.Print(head.Val, \" -> \")\n        head = head.Next\n    }\n    fmt.Println(\"nil\")\n}\n\nfunc main() {\n    // 构建第一个链表 2 -> 4 -> 3\n    l1 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 3}}}\n    // 构建第二个链表 5 -> 6 -> 4\n    l2 := &ListNode{Val: 5, Next: &ListNode{Val: 6, Next: &ListNode{Val: 4}}}\n\n    // 调用 addTwoNumbers 函数\n    result := addTwoNumbers(l1, l2)\n\n    // 打印结果链表\n    printList(result)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (256, '2025-05-03 14:20:52.499', '2025-05-03 14:20:52.499', '2025-05-03 15:58:34.938', 52, '#include <stdio.h>\nint main() {\n    int a, b;\n	scanf(\"%d\", &a);\n    printf(\"a * a = %d\n\", a * a);\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (257, '2025-05-03 15:58:34.999', '2025-05-03 15:58:34.999', '2025-05-04 13:40:06.206', 52, '#include <stdio.h>\nint main() {\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (258, '2025-05-04 13:40:06.270', '2025-05-04 13:40:06.270', '2025-08-16 20:38:26.375', 52, '#include <stdio.h>\nint main() {\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (259, '2025-05-14 01:18:07.892', '2025-05-14 01:18:07.892', '2025-05-14 01:24:14.618', 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *newHead = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = newHead;\n        newHead = curr;\n        curr = nextNode;\n    }\n    return newHead;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[12]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (260, '2025-05-14 01:18:07.949', '2025-05-14 01:18:07.949', '2025-05-14 01:24:14.618', 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = nextNode\n    }\n    return newHead\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    node5 := &ListNode{Val: 5, Next: nil}\n    node4 := &ListNode{Val: 4, Next: node5}\n    node3 := &ListNode{Val: 3, Next: node4}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[13]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (261, '2025-05-14 01:18:08.006', '2025-05-14 01:18:08.006', '2025-05-14 01:24:14.618', 66, '#include <iostream>\r\n#include <memory>  // 用于智能指针\r\n\r\n// 定义链表节点结构\r\nstruct ListNode {\r\n    int val;\r\n    std::shared_ptr<ListNode> next;\r\n    \r\n    // 构造函数简化初始化\r\n    ListNode(int x) : val(x), next(nullptr) {}\r\n};\r\n\r\n// 反转链表\r\nstd::shared_ptr<ListNode> reverseList(const std::shared_ptr<ListNode>& head) {\r\n    std::shared_ptr<ListNode> newHead = nullptr;\r\n    auto curr = head;\r\n    \r\n    while (curr) {\r\n        auto nextNode = curr->next;\r\n        curr->next = newHead;\r\n        newHead = curr;\r\n        curr = nextNode;\r\n    }\r\n    \r\n    return newHead;\r\n}\r\n\r\n// 打印链表\r\nvoid printList(const std::shared_ptr<ListNode>& head) {\r\n    auto curr = head;\r\n    while (curr) {\r\n        std::cout << curr->val;\r\n        if (curr->next) {\r\n            std::cout << \" -> \";\r\n        }\r\n        curr = curr->next;\r\n    }\r\n    std::cout << std::endl;\r\n}\r\n\r\nint main() {\r\n    // 创建链表 1 -> 2 -> 3\r\n    auto node1 = std::make_shared<ListNode>(1);\r\n    auto node2 = std::make_shared<ListNode>(2);\r\n    auto node3 = std::make_shared<ListNode>(3);\r\n    \r\n    node1->next = node2;\r\n    node2->next = node3;\r\n\r\n    std::cout << \"原始链表: \";\r\n    printList(node1);\r\n\r\n    auto reversedHead = reverseList(node1);\r\n\r\n    std::cout << \"反转后链表: \";\r\n    printList(reversedHead);\r\n\r\n    // 无需手动释放内存，智能指针自动管理\r\n\r\n    return 0;\r\n}', 'cpp', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (262, '2025-05-14 01:19:05.229', '2025-05-14 01:19:05.229', '2025-05-14 01:23:13.288', 77, '#include <stdio.h>\n\n// 二分查找函数\nint BinarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n// 测试函数\nint main() {\n    // 定义一个有序数组\n    int arr[] = {1, 3, 5, 7, 9, 11, 13};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    // 测试用例 1：查找存在的元素\n    int target1 = 7;\n    int result1 = BinarySearch(arr, size, target1);\n    if (result1 != -1) {\n        printf(\"元素 %d 在数组中的索引是 %d\\n\", target1, result1);\n    } else {\n        printf(\"元素 %d 不在数组中\\n\", target1);\n    }\n    return 0;\n}', 'c', '[7,9]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (263, '2025-05-14 01:19:05.287', '2025-05-14 01:19:05.287', '2025-05-14 01:23:13.288', 77, 'package main\n\nimport \"fmt\"\n\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 2, 3, 4, 5, 7, 9, 12}\n    target := 3\n\n    answer := BinarySearch(arr, target)\n    fmt.Printf(\"二分结果: %d\\n\", answer)\n}', 'go', '[7,9]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (264, '2025-05-14 01:19:05.343', '2025-05-14 01:19:05.343', '2025-05-14 01:23:13.288', 77, '#include <iostream>\r\n#include <vector>\r\n\r\n// 模板化二分查找函数，支持不同类型的有序数组\r\ntemplate<typename T>\r\nint BinarySearch(const std::vector<T>& arr, const T& target) {\r\n    int left = 0;\r\n    int right = arr.size() - 1;\r\n    \r\n    while (left <= right) {\r\n        int mid = left + (right - left) / 2;  // 防止整数溢出\r\n        \r\n        if (arr[mid] == target) {\r\n            return mid;  // 找到目标值，返回索引\r\n        } else if (arr[mid] < target) {\r\n            left = mid + 1;  // 目标在右半部分\r\n        } else {\r\n            right = mid - 1;  // 目标在左半部分\r\n        }\r\n    }\r\n    \r\n    return -1;  // 未找到目标值\r\n}\r\n\r\nint main() {\r\n    // 使用C++向量替代C风格数组\r\n    std::vector<int> arr = {1, 3, 5, 7, 9, 11, 13};\r\n\r\n    // 测试用例：查找存在的元素\r\n    int target = 7;\r\n    int result = BinarySearch(arr, target);\r\n    \r\n    if (result != -1) {\r\n        std::cout << \"元素 \" << target << \" 在数组中的索引是 \" << result << std::endl;\r\n    } else {\r\n        std::cout << \"元素 \" << target << \" 不在数组中\" << std::endl;\r\n    }\r\n\r\n    return 0;\r\n}', 'cpp', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (265, '2025-05-14 01:19:47.128', '2025-05-14 01:19:47.128', '2025-05-14 01:20:14.105', 78, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// addTwoNumbers 函数用于将两个链表表示的数字相加\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    carry := 0\n    var head *ListNode\n    var tail *ListNode\n    for l1 != nil || l2 != nil {\n        sum := carry\n        if l1 != nil {\n            sum += l1.Val\n            l1 = l1.Next\n        }\n        if l2 != nil {\n            sum += l2.Val\n            l2 = l2.Next\n        }\n        carry = sum / 10\n        node := &ListNode{\n            Val: sum % 10,\n        }\n        if head == nil {\n            head = node\n            tail = node\n        } else {\n            tail.Next = node\n            tail = tail.Next\n        }\n    }\n    if carry != 0 {\n        tail.Next = &ListNode{\n            Val: carry,\n        }\n    }\n    return head\n}\n\n// printList 函数用于打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        fmt.Print(head.Val, \" -> \")\n        head = head.Next\n    }\n    fmt.Println(\"nil\")\n}\n\nfunc main() {\n    // 构建第一个链表 2 -> 4 -> 3\n    l1 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 3}}}\n    // 构建第二个链表 5 -> 6 -> 4\n    l2 := &ListNode{Val: 5, Next: &ListNode{Val: 6, Next: &ListNode{Val: 4}}}\n\n    // 调用 addTwoNumbers 函数\n    result := addTwoNumbers(l1, l2)\n\n    // 打印结果链表\n    printList(result)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (266, '2025-05-14 01:19:47.184', '2025-05-14 01:19:47.184', '2025-05-14 01:20:14.105', 78, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 创建新节点\nListNode* createNode(int value) {\n    ListNode *newNode = (ListNode*)malloc(sizeof(ListNode));\n    newNode->val = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 将两个链表表示的数字相加\nListNode* addTwoNumbers(ListNode *l1, ListNode *l2) {\n    int carry = 0;\n    ListNode *head = NULL;\n    ListNode *tail = NULL;\n\n    while (l1 != NULL || l2 != NULL) {\n        int sum = carry;\n        if (l1 != NULL) {\n            sum += l1->val;\n            l1 = l1->next;\n        }\n        if (l2 != NULL) {\n            sum += l2->val;\n            l2 = l2->next;\n        }\n        carry = sum / 10;\n        ListNode *newNode = createNode(sum % 10);\n        if (head == NULL) {\n            head = newNode;\n            tail = newNode;\n        } else {\n            tail->next = newNode;\n            tail = newNode;\n        }\n    }\n\n    if (carry != 0) {\n        tail->next = createNode(carry);\n    }\n\n    return head;\n}\n\n// 打印链表\nvoid printList(ListNode *head) {\n    while (head != NULL) {\n        printf(\"%d -> \", head->val);\n        head = head->next;\n    }\n    printf(\"null\\n\");\n}\n\nint main() {\n    // 构建第一个链表 2 -> 4 -> 3\n    ListNode *l1 = createNode(2);\n    l1->next = createNode(4);\n    l1->next->next = createNode(3);\n\n    // 构建第二个链表 5 -> 6 -> 4\n    ListNode *l2 = createNode(5);\n    l2->next = createNode(6);\n    l2->next->next = createNode(4);\n\n    // 调用 addTwoNumbers 函数\n    ListNode *result = addTwoNumbers(l1, l2);\n\n    // 打印结果链表\n    printList(result);\n\n    // 释放链表内存\n    ListNode *current = result;\n    ListNode *next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n\n    current = l1;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n\n    current = l2;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (267, '2025-05-14 01:20:14.184', '2025-05-14 01:20:14.184', NULL, 78, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// addTwoNumbers 函数用于将两个链表表示的数字相加\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    carry := 0\n    var head *ListNode\n    var tail *ListNode\n    for l1 != nil || l2 != nil {\n        sum := carry\n        if l1 != nil {\n            sum += l1.Val\n            l1 = l1.Next\n        }\n        if l2 != nil {\n            sum += l2.Val\n            l2 = l2.Next\n        }\n        carry = sum / 10\n        node := &ListNode{\n            Val: sum % 10,\n        }\n        if head == nil {\n            head = node\n            tail = node\n        } else {\n            tail.Next = node\n            tail = tail.Next\n        }\n    }\n    if carry != 0 {\n        tail.Next = &ListNode{\n            Val: carry,\n        }\n    }\n    return head\n}\n\n// printList 函数用于打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        fmt.Print(head.Val, \" -> \")\n        head = head.Next\n    }\n    fmt.Println(\"nil\")\n}\n\nfunc main() {\n    // 构建第一个链表 2 -> 4 -> 3\n    l1 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 3}}}\n    // 构建第二个链表 5 -> 6 -> 4\n    l2 := &ListNode{Val: 5, Next: &ListNode{Val: 6, Next: &ListNode{Val: 4}}}\n\n    // 调用 addTwoNumbers 函数\n    result := addTwoNumbers(l1, l2)\n\n    // 打印结果链表\n    printList(result)\n}', 'go', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (268, '2025-05-14 01:20:14.239', '2025-05-14 01:20:14.239', NULL, 78, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 创建新节点\nListNode* createNode(int value) {\n    ListNode *newNode = (ListNode*)malloc(sizeof(ListNode));\n    newNode->val = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 将两个链表表示的数字相加\nListNode* addTwoNumbers(ListNode *l1, ListNode *l2) {\n    int carry = 0;\n    ListNode *head = NULL;\n    ListNode *tail = NULL;\n\n    while (l1 != NULL || l2 != NULL) {\n        int sum = carry;\n        if (l1 != NULL) {\n            sum += l1->val;\n            l1 = l1->next;\n        }\n        if (l2 != NULL) {\n            sum += l2->val;\n            l2 = l2->next;\n        }\n        carry = sum / 10;\n        ListNode *newNode = createNode(sum % 10);\n        if (head == NULL) {\n            head = newNode;\n            tail = newNode;\n        } else {\n            tail->next = newNode;\n            tail = newNode;\n        }\n    }\n\n    if (carry != 0) {\n        tail->next = createNode(carry);\n    }\n\n    return head;\n}\n\n// 打印链表\nvoid printList(ListNode *head) {\n    while (head != NULL) {\n        printf(\"%d -> \", head->val);\n        head = head->next;\n    }\n    printf(\"null\\n\");\n}\n\nint main() {\n    // 构建第一个链表 2 -> 4 -> 3\n    ListNode *l1 = createNode(2);\n    l1->next = createNode(4);\n    l1->next->next = createNode(3);\n\n    // 构建第二个链表 5 -> 6 -> 4\n    ListNode *l2 = createNode(5);\n    l2->next = createNode(6);\n    l2->next->next = createNode(4);\n\n    // 调用 addTwoNumbers 函数\n    ListNode *result = addTwoNumbers(l1, l2);\n\n    // 打印结果链表\n    printList(result);\n\n    // 释放链表内存\n    ListNode *current = result;\n    ListNode *next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n\n    current = l1;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n\n    current = l2;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (269, '2025-05-14 01:20:14.302', '2025-05-14 01:20:14.302', NULL, 78, '#include <iostream>\r\n#include <memory>\r\n\r\n// 定义链表节点结构\r\nstruct ListNode {\r\n    int val;\r\n    std::shared_ptr<ListNode> next;\r\n    \r\n    // 构造函数简化节点创建\r\n    ListNode(int x) : val(x), next(nullptr) {}\r\n};\r\n\r\n// 将两个链表表示的数字相加\r\nstd::shared_ptr<ListNode> addTwoNumbers(const std::shared_ptr<ListNode>& l1, \r\n                                        const std::shared_ptr<ListNode>& l2) {\r\n    int carry = 0;\r\n    std::shared_ptr<ListNode> head = nullptr;\r\n    std::shared_ptr<ListNode> tail = nullptr;\r\n\r\n    auto current1 = l1;\r\n    auto current2 = l2;\r\n\r\n    while (current1 || current2) {\r\n        int sum = carry;\r\n        if (current1) {\r\n            sum += current1->val;\r\n            current1 = current1->next;\r\n        }\r\n        if (current2) {\r\n            sum += current2->val;\r\n            current2 = current2->next;\r\n        }\r\n        carry = sum / 10;\r\n        \r\n        auto newNode = std::make_shared<ListNode>(sum % 10);\r\n        if (!head) {\r\n            head = newNode;\r\n            tail = newNode;\r\n        } else {\r\n            tail->next = newNode;\r\n            tail = newNode;\r\n        }\r\n    }\r\n\r\n    if (carry != 0) {\r\n        tail->next = std::make_shared<ListNode>(carry);\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n// 打印链表\r\nvoid printList(const std::shared_ptr<ListNode>& head) {\r\n    auto current = head;\r\n    while (current) {\r\n        std::cout << current->val << \" -> \";\r\n        current = current->next;\r\n    }\r\n    std::cout << \"null\" << std::endl;\r\n}\r\n\r\nint main() {\r\n    // 构建第一个链表 2 -> 4 -> 3\r\n    auto l1 = std::make_shared<ListNode>(2);\r\n    l1->next = std::make_shared<ListNode>(4);\r\n    l1->next->next = std::make_shared<ListNode>(3);\r\n\r\n    // 构建第二个链表 5 -> 6 -> 4\r\n    auto l2 = std::make_shared<ListNode>(5);\r\n    l2->next = std::make_shared<ListNode>(6);\r\n    l2->next->next = std::make_shared<ListNode>(4);\r\n\r\n    // 调用 addTwoNumbers 函数\r\n    auto result = addTwoNumbers(l1, l2);\r\n\r\n    // 打印结果链表\r\n    printList(result);\r\n\r\n    // 无需手动释放内存，智能指针自动管理\r\n\r\n    return 0;\r\n}', 'cpp', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (270, '2025-05-14 01:21:07.650', '2025-05-14 01:21:07.650', '2025-05-14 01:21:34.929', 67, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 创建新节点\nListNode* createNode(int value) {\n    ListNode *newNode = (ListNode*)malloc(sizeof(ListNode));\n    newNode->val = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 反转链表\nListNode* reverse(ListNode *head) {\n    ListNode *newHead = NULL;\n    ListNode *curr = head;\n    while (curr != NULL) {\n        ListNode *next = curr->next;\n        curr->next = newHead;\n        newHead = curr;\n        curr = next;\n    }\n    return newHead;\n}\n\n// 反转链表中指定区间的节点\nListNode* reverseBetween(ListNode *head, int left, int right) {\n    ListNode dummyNode = (ListNode){.val = -1,.next = head};\n    ListNode *pre = &dummyNode;\n    // 找到反转区间的前驱节点\n    for (int i = 0; i < left - 1; i++) {\n        pre = pre->next;\n    }\n    ListNode *leftNode = pre->next;\n    ListNode *rightNode = pre;\n    // 找到反转区间的最后一个节点\n    for (int i = 0; i < right; i++) {\n        rightNode = rightNode->next;\n    }\n    ListNode *succ = rightNode->next;\n    rightNode->next = NULL;\n    // 反转指定区间的链表\n    leftNode = reverse(leftNode);\n    pre->next = rightNode;\n    pre = leftNode;\n    while (pre->next != NULL) {\n        pre = pre->next;\n    }\n    pre->next = succ;\n    return dummyNode.next;\n}\n\n// 打印链表\nvoid printList(ListNode *head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    ListNode *head = NULL;\n    ListNode *tail = NULL;\n    for (int i = 0; i < 8; i++) {\n        ListNode *node = createNode(i);\n        if (head == NULL) {\n            head = node;\n            tail = node;\n        } else {\n            tail->next = node;\n            tail = tail->next;\n        }\n    }\n\n    printf(\"原始链表: \");\n    printList(head);\n\n    ListNode *reversedHead = reverseBetween(head, 1, 4);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放链表内存\n    ListNode *current = head;\n    ListNode *next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (271, '2025-05-14 01:21:07.708', '2025-05-14 01:21:07.708', '2025-05-14 01:21:34.929', 67, 'package main\nimport (\n	\"fmt\"\n)\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n	var head *ListNode\n	var tail *ListNode\n	for i := 0; i < 8; i++ {\n		node := &ListNode {Val: i}\n		if head == nil {\n			head = node\n			tail = node\n		} else {\n			tail.Next = node\n			tail = tail.Next\n		}\n	}\n\n    fmt.Print(\"原始链表: \")\n    printList(head)\n\n    reversedHead := reverseBetween(head, 1, 4)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (272, '2025-05-14 01:21:35.004', '2025-05-14 01:21:35.004', NULL, 67, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 创建新节点\nListNode* createNode(int value) {\n    ListNode *newNode = (ListNode*)malloc(sizeof(ListNode));\n    newNode->val = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 反转链表\nListNode* reverse(ListNode *head) {\n    ListNode *newHead = NULL;\n    ListNode *curr = head;\n    while (curr != NULL) {\n        ListNode *next = curr->next;\n        curr->next = newHead;\n        newHead = curr;\n        curr = next;\n    }\n    return newHead;\n}\n\n// 反转链表中指定区间的节点\nListNode* reverseBetween(ListNode *head, int left, int right) {\n    ListNode dummyNode = (ListNode){.val = -1,.next = head};\n    ListNode *pre = &dummyNode;\n    // 找到反转区间的前驱节点\n    for (int i = 0; i < left - 1; i++) {\n        pre = pre->next;\n    }\n    ListNode *leftNode = pre->next;\n    ListNode *rightNode = pre;\n    // 找到反转区间的最后一个节点\n    for (int i = 0; i < right; i++) {\n        rightNode = rightNode->next;\n    }\n    ListNode *succ = rightNode->next;\n    rightNode->next = NULL;\n    // 反转指定区间的链表\n    leftNode = reverse(leftNode);\n    pre->next = rightNode;\n    pre = leftNode;\n    while (pre->next != NULL) {\n        pre = pre->next;\n    }\n    pre->next = succ;\n    return dummyNode.next;\n}\n\n// 打印链表\nvoid printList(ListNode *head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    ListNode *head = NULL;\n    ListNode *tail = NULL;\n    for (int i = 0; i < 8; i++) {\n        ListNode *node = createNode(i);\n        if (head == NULL) {\n            head = node;\n            tail = node;\n        } else {\n            tail->next = node;\n            tail = tail->next;\n        }\n    }\n\n    printf(\"原始链表: \");\n    printList(head);\n\n    ListNode *reversedHead = reverseBetween(head, 1, 4);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放链表内存\n    ListNode *current = head;\n    ListNode *next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n\n    return 0;\n}', 'c', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (273, '2025-05-14 01:21:35.061', '2025-05-14 01:21:35.061', NULL, 67, 'package main\nimport (\n	\"fmt\"\n)\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummyNode := &ListNode{Val:-1}\n    dummyNode.Next = head\n    rightNode := dummyNode\n    for i := 0; i < right; i++ {\n        rightNode = rightNode.Next\n    }\n    succ := rightNode.Next\n    rightNode.Next = nil\n\n    pre := dummyNode\n    for i := 0; i < left - 1; i++ {\n        pre = pre.Next\n    }\n    leftNode := pre.Next\n    pre.Next = nil\n\n    reverse(leftNode)\n    pre.Next = rightNode\n    leftNode.Next = succ\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        next := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = next\n    }\n    return curr\n}\n\nfunc main() {\n	var head *ListNode\n	var tail *ListNode\n	for i := 0; i < 8; i++ {\n		node := &ListNode {Val: i}\n		if head == nil {\n			head = node\n			tail = node\n		} else {\n			tail.Next = node\n			tail = tail.Next\n		}\n	}\n\n    fmt.Print(\"原始链表: \")\n    printList(head)\n\n    reversedHead := reverseBetween(head, 1, 4)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n', 'go', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (274, '2025-05-14 01:21:35.122', '2025-05-14 01:21:35.122', NULL, 67, '#include <iostream>\r\nusing namespace std;\r\n\r\n// 定义链表节点结构\r\nstruct ListNode {\r\n    int val;\r\n    ListNode* next;\r\n    ListNode(int x) : val(x), next(nullptr) {}\r\n};\r\n\r\n// 反转链表\r\nListNode* reverse(ListNode* head) {\r\n    ListNode* newHead = nullptr;\r\n    ListNode* curr = head;\r\n    while (curr != nullptr) {\r\n        ListNode* next = curr->next;\r\n        curr->next = newHead;\r\n        newHead = curr;\r\n        curr = next;\r\n    }\r\n    return newHead;\r\n}\r\n\r\n// 反转链表中指定区间的节点\r\nListNode* reverseBetween(ListNode* head, int left, int right) {\r\n    ListNode dummy(-1);\r\n    dummy.next = head;\r\n    ListNode* pre = &dummy;\r\n    for (int i = 0; i < left - 1; ++i) {\r\n        pre = pre->next;\r\n    }\r\n    ListNode* leftNode = pre->next;\r\n    ListNode* rightNode = pre;\r\n    for (int i = 0; i < right; ++i) {\r\n        rightNode = rightNode->next;\r\n    }\r\n    ListNode* succ = rightNode->next;\r\n    rightNode->next = nullptr;\r\n    leftNode = reverse(leftNode);\r\n    pre->next = rightNode;\r\n    ListNode* p = leftNode;\r\n    while (p->next != nullptr) {\r\n        p = p->next;\r\n    }\r\n    p->next = succ;\r\n    return dummy.next;\r\n}\r\n\r\n// 打印链表\r\nvoid printList(ListNode* head) {\r\n    while (head != nullptr) {\r\n        if (head->next != nullptr) {\r\n            cout << head->val << \" -> \";\r\n        } else {\r\n            cout << head->val << endl;\r\n        }\r\n        head = head->next;\r\n    }\r\n}\r\n\r\nint main() {\r\n    ListNode* head = nullptr;\r\n    ListNode* tail = nullptr;\r\n    for (int i = 0; i < 8; ++i) {\r\n        ListNode* node = new ListNode(i);\r\n        if (head == nullptr) {\r\n            head = node;\r\n            tail = node;\r\n        } else {\r\n            tail->next = node;\r\n            tail = tail->next;\r\n        }\r\n    }\r\n\r\n    cout << \"原始链表: \";\r\n    printList(head);\r\n\r\n    ListNode* reversedHead = reverseBetween(head, 1, 4);\r\n\r\n    cout << \"反转后链表: \";\r\n    printList(reversedHead);\r\n\r\n    // 释放链表内存\r\n    ListNode* current = head;\r\n    ListNode* next;\r\n    while (current != nullptr) {\r\n        next = current->next;\r\n        delete current;\r\n        current = next;\r\n    }\r\n\r\n    return 0;\r\n}', 'cpp', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"point1\",\"point2\"]}}');
INSERT INTO `visual_document_codes` VALUES (275, '2025-05-14 01:23:13.351', '2025-05-14 01:23:13.351', NULL, 77, '#include <stdio.h>\n\n// 二分查找函数\nint BinarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n// 测试函数\nint main() {\n    // 定义一个有序数组\n    int arr[] = {1, 3, 5, 7, 9, 11, 13};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    // 测试用例 1：查找存在的元素\n    int target1 = 7;\n    int result1 = BinarySearch(arr, size, target1);\n    if (result1 != -1) {\n        printf(\"元素 %d 在数组中的索引是 %d\\n\", target1, result1);\n    } else {\n        printf(\"元素 %d 不在数组中\\n\", target1);\n    }\n    return 0;\n}', 'c', '[7,9]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (276, '2025-05-14 01:23:13.415', '2025-05-14 01:23:13.415', NULL, 77, 'package main\n\nimport \"fmt\"\n\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 2, 3, 4, 5, 7, 9, 12}\n    target := 3\n\n    answer := BinarySearch(arr, target)\n    fmt.Printf(\"二分结果: %d\\n\", answer)\n}', 'go', '[7,9]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (277, '2025-05-14 01:23:13.479', '2025-05-14 01:23:13.479', NULL, 77, '#include <iostream>\r\n#include <vector>\r\n\r\n// 模板化二分查找函数，支持不同类型的有序数组\r\ntemplate<typename T>\r\nint BinarySearch(const std::vector<T>& arr, const T& target) {\r\n    int left = 0;\r\n    int right = arr.size() - 1;\r\n    \r\n    while (left <= right) {\r\n        int mid = left + (right - left) / 2;  // 防止整数溢出\r\n        \r\n        if (arr[mid] == target) {\r\n            return mid;  // 找到目标值，返回索引\r\n        } else if (arr[mid] < target) {\r\n            left = mid + 1;  // 目标在右半部分\r\n        } else {\r\n            right = mid - 1;  // 目标在左半部分\r\n        }\r\n    }\r\n    \r\n    return -1;  // 未找到目标值\r\n}\r\n\r\nint main() {\r\n    // 使用C++向量替代C风格数组\r\n    std::vector<int> arr = {1, 3, 5, 7, 9, 11, 13};\r\n\r\n    // 测试用例：查找存在的元素\r\n    int target = 7;\r\n    int result = BinarySearch(arr, target);\r\n    \r\n    if (result != -1) {\r\n        std::cout << \"元素 \" << target << \" 在数组中的索引是 \" << result << std::endl;\r\n    } else {\r\n        std::cout << \"元素 \" << target << \" 不在数组中\" << std::endl;\r\n    }\r\n\r\n    return 0;\r\n}', 'cpp', '[]', '{\"type\":\"array\",\"description\":{\"arrayName\":\"arr\",\"pointNames\":[\"left\",\"right\",\"mid\"]}}');
INSERT INTO `visual_document_codes` VALUES (278, '2025-05-14 01:24:14.683', '2025-05-14 01:24:14.683', NULL, 66, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *newHead = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = newHead;\n        newHead = curr;\n        curr = nextNode;\n    }\n    return newHead;\n}\n\n// 打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        if (head->next != NULL) {\n            printf(\"%d -> \", head->val);\n        } else {\n            printf(\"%d\\n\", head->val);\n        }\n        head = head->next;\n    }\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3\n    ListNode *node3 = (ListNode*)malloc(sizeof(ListNode));\n    node3->val = 3;\n    node3->next = NULL;\n\n    ListNode *node2 = (ListNode*)malloc(sizeof(ListNode));\n    node2->val = 2;\n    node2->next = node3;\n\n    ListNode *node1 = (ListNode*)malloc(sizeof(ListNode));\n    node1->val = 1;\n    node1->next = node2;\n\n    printf(\"原始链表: \");\n    printList(node1);\n\n    ListNode *reversedHead = reverseList(node1);\n\n    printf(\"反转后链表: \");\n    printList(reversedHead);\n\n    // 释放内存\n    while (reversedHead != NULL) {\n        ListNode *temp = reversedHead;\n        reversedHead = reversedHead->next;\n        free(temp);\n    }\n\n    return 0;\n}', 'c', '[12]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (279, '2025-05-14 01:24:14.749', '2025-05-14 01:24:14.749', NULL, 66, 'package main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = nextNode\n    }\n    return newHead\n}\n\n// printList 打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        if head.Next != nil {\n            fmt.Printf(\"%d -> \", head.Val)\n        } else {\n            fmt.Printf(\"%d\\n\", head.Val)\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    node5 := &ListNode{Val: 5, Next: nil}\n    node4 := &ListNode{Val: 4, Next: node5}\n    node3 := &ListNode{Val: 3, Next: node4}\n    node2 := &ListNode{Val: 2, Next: node3}\n    node1 := &ListNode{Val: 1, Next: node2}\n\n    fmt.Print(\"原始链表: \")\n    printList(node1)\n\n    reversedHead := reverseList(node1)\n\n    fmt.Print(\"反转后链表: \")\n    printList(reversedHead)\n}', 'go', '[13]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"Val\",\"next\":\"Next\",\"prev\":\"\"}}');
INSERT INTO `visual_document_codes` VALUES (280, '2025-05-14 01:24:14.813', '2025-05-14 01:24:14.813', NULL, 66, '#include <iostream>\r\n#include <memory>  // 用于智能指针\r\n\r\n// 定义链表节点结构\r\nstruct ListNode {\r\n    int val;\r\n    std::shared_ptr<ListNode> next;\r\n    \r\n    // 构造函数简化初始化\r\n    ListNode(int x) : val(x), next(nullptr) {}\r\n};\r\n\r\n// 反转链表\r\nstd::shared_ptr<ListNode> reverseList(const std::shared_ptr<ListNode>& head) {\r\n    std::shared_ptr<ListNode> newHead = nullptr;\r\n    auto curr = head;\r\n    \r\n    while (curr) {\r\n        auto nextNode = curr->next;\r\n        curr->next = newHead;\r\n        newHead = curr;\r\n        curr = nextNode;\r\n    }\r\n    \r\n    return newHead;\r\n}\r\n\r\n// 打印链表\r\nvoid printList(const std::shared_ptr<ListNode>& head) {\r\n    auto curr = head;\r\n    while (curr) {\r\n        std::cout << curr->val;\r\n        if (curr->next) {\r\n            std::cout << \" -> \";\r\n        }\r\n        curr = curr->next;\r\n    }\r\n    std::cout << std::endl;\r\n}\r\n\r\nint main() {\r\n    // 创建链表 1 -> 2 -> 3\r\n    auto node1 = std::make_shared<ListNode>(1);\r\n    auto node2 = std::make_shared<ListNode>(2);\r\n    auto node3 = std::make_shared<ListNode>(3);\r\n    \r\n    node1->next = node2;\r\n    node2->next = node3;\r\n\r\n    std::cout << \"原始链表: \";\r\n    printList(node1);\r\n\r\n    auto reversedHead = reverseList(node1);\r\n\r\n    std::cout << \"反转后链表: \";\r\n    printList(reversedHead);\r\n\r\n    // 无需手动释放内存，智能指针自动管理\r\n\r\n    return 0;\r\n}', 'cpp', '[]', '{\"type\":\"linkList\",\"description\":{\"linkNode\":\"ListNode\",\"data\":\"val\",\"next\":\"next\",\"prev\":\"prev\"}}');
INSERT INTO `visual_document_codes` VALUES (281, '2025-07-06 00:53:39.636', '2025-07-06 00:53:39.636', NULL, 60, '#include <stdio.h>\n#include <stdlib.h>\n\n// 定义双向链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* prev;  // 指向前一个节点的指针\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    \n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    newNode->next = head;\n    head->prev = newNode;\n    return newNode;\n}\n\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n\n// 在指定位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"位置超出链表长度\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    if (temp->next != NULL) {\n        temp->next->prev = newNode;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n\n// 从前往后遍历链表\nvoid traverseForward(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\n// 从后往前遍历链表\nvoid traverseBackward(Node* head) {\n    if (head == NULL) return;\n    Node* current = head;\n    while (current->next != NULL) {\n        current = current->next;\n    }\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->prev;\n    }\n    printf(\"\\n\");\n}\n\n// 删除头节点\nNode* deleteAtBeginning(Node* head) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    head = head->next;\n    if (head != NULL) {\n        head->prev = NULL;\n    }\n    free(temp);\n    return head;\n}\n\n// 删除尾节点\nNode* deleteAtEnd(Node* head) {\n    if (head == NULL) return NULL;\n    if (head->next == NULL) {\n        free(head);\n        return NULL;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->prev->next = NULL;\n    free(temp);\n    return head;\n}\n\n// 删除指定值的节点\nNode* deleteNode(Node* head, int key) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    if (temp->data == key) {\n        return deleteAtBeginning(head);\n    }\n    while (temp != NULL && temp->data != key) {\n        temp = temp->next;\n    }\n    if (temp == NULL) {\n        printf(\"未找到该值的节点\\n\");\n        return head;\n    }\n    if (temp->next != NULL) {\n        temp->next->prev = temp->prev;\n    }\n    temp->prev->next = temp->next;\n    free(temp);\n    return head;\n}\n\nint main() {\n    Node* head = NULL;\n\n    // 插入节点\n    head = insertAtBeginning(head, 1);\n    head = insertAtEnd(head, 3);\n    head = insertAtPosition(head, 2, 1);\n\n    // 从前往后遍历链表\n    printf(\"从前往后遍历链表: \");\n    traverseForward(head);\n\n    // 从后往前遍历链表\n    printf(\"从后往前遍历链表: \");\n    traverseBackward(head);\n\n    // 删除节点\n    head = deleteNode(head, 2);\n\n    // 再次从前往后遍历链表\n    printf(\"删除节点 2 后从前往后遍历链表: \");\n    traverseForward(head);\n\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (282, '2025-08-16 20:38:26.437', '2025-08-16 20:38:26.437', '2025-08-16 20:38:57.069', 52, '#include <stdio.h>\nint main() {\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (283, '2025-08-16 20:38:57.131', '2025-08-16 20:38:57.131', NULL, 52, '#include <stdio.h>\nint main() {\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (284, '2025-08-16 21:54:56.394', '2025-08-16 21:54:56.394', '2025-08-16 22:14:38.808', 68, '#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (285, '2025-08-16 21:56:20.844', '2025-08-16 21:56:20.844', '2025-08-16 21:57:37.692', 80, '#include <stdio.h>\nint main() {\n    // 无实例代码\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (286, '2025-08-16 21:57:37.765', '2025-08-16 21:57:37.765', '2025-08-16 22:03:03.948', 80, '#include <stdio.h>\nint main() {\n    // 无实例代码\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (287, '2025-08-16 22:03:04.021', '2025-08-16 22:03:04.021', '2025-08-16 22:03:11.594', 80, '#include <stdio.h>\nint main() {\n    // 无实例代码\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (288, '2025-08-16 22:03:11.667', '2025-08-16 22:03:11.667', '2025-08-16 22:09:49.604', 80, '#include <stdio.h>\nint main() {\n    // 无实例代码\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (289, '2025-08-16 22:09:49.677', '2025-08-16 22:09:49.677', '2025-08-16 22:10:00.649', 80, '#include <stdio.h>\nint main() {\n    // 无实例代码\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (290, '2025-08-16 22:10:00.722', '2025-08-16 22:10:00.722', '2025-08-16 22:10:49.714', 80, '#include <stdio.h>\nint main() {\n    // 无实例代码\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (291, '2025-08-16 22:10:49.787', '2025-08-16 22:10:49.787', '2025-08-16 22:12:37.379', 80, '#include <stdio.h>\nint main() {\n    // 无实例代码\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (292, '2025-08-16 22:12:37.451', '2025-08-16 22:12:37.451', '2025-08-16 22:14:02.135', 80, '#include <stdio.h>\nint main() {\n    // 无实例代码\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (293, '2025-08-16 22:14:02.207', '2025-08-16 22:14:02.207', NULL, 80, '#include <stdio.h>\nint main() {\n    // 无实例代码\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (294, '2025-08-16 22:14:38.881', '2025-08-16 22:14:38.881', '2025-08-16 22:14:57.165', 68, '#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (295, '2025-08-16 22:14:57.237', '2025-08-16 22:14:57.237', NULL, 68, '#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (296, '2025-08-24 17:52:32.728', '2025-08-24 17:52:32.728', NULL, 62, '#include <stdio.h>\nint main() {\n\n    return 0;\n}', 'c', '[]', NULL);
INSERT INTO `visual_document_codes` VALUES (297, '2025-08-24 18:25:04.279', '2025-08-24 18:25:04.279', NULL, 71, '#include <stdio.h>\n\nint main() {\n    int num = 12;\n    if (num > 10) {\n        printf(\"num大于10\\n\");\n    }\n    return 0;\n}', 'c', '[]', NULL);

-- ----------------------------
-- Table structure for visual_documents
-- ----------------------------
DROP TABLE IF EXISTS `visual_documents`;
CREATE TABLE `visual_documents`  (
  `id` bigint UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) NULL DEFAULT NULL,
  `updated_at` datetime(3) NULL DEFAULT NULL,
  `deleted_at` datetime(3) NULL DEFAULT NULL,
  `parent_id` bigint UNSIGNED NULL DEFAULT NULL,
  `title` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `creator_id` bigint UNSIGNED NULL DEFAULT NULL,
  `enable` tinyint(1) NULL DEFAULT NULL,
  `order` bigint UNSIGNED NULL DEFAULT NULL,
  `bank_id` bigint UNSIGNED NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_visual_documents_deleted_at`(`deleted_at` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 81 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of visual_documents
-- ----------------------------
INSERT INTO `visual_documents` VALUES (1, '2025-01-06 00:06:05.632', '2025-01-06 00:06:05.632', '2025-01-18 02:04:07.347', 0, '', '', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (2, '2025-01-06 00:06:18.568', '2025-01-06 00:06:18.568', '2025-01-18 01:28:46.491', 0, '', '', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (3, '2025-01-06 00:10:14.844', '2025-01-17 02:41:14.772', '2025-01-18 02:07:06.236', 0, '测试23', '# 测试', 1, 1, NULL, 3);
INSERT INTO `visual_documents` VALUES (4, '2025-01-17 02:40:57.028', '2025-01-17 02:40:57.028', '2025-01-18 01:28:38.703', 3, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (5, '2025-01-18 02:06:00.072', '2025-01-18 02:06:00.072', '2025-01-18 02:13:30.804', 12, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (6, '2025-01-18 02:06:04.484', '2025-01-18 02:06:04.484', '2025-01-18 02:13:05.324', 13, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (7, '2025-01-18 02:06:11.435', '2025-01-18 02:06:11.435', '2025-01-18 02:12:37.140', 14, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (8, '2025-01-18 02:06:37.810', '2025-01-18 02:06:37.810', '2025-01-18 02:07:02.988', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (9, '2025-01-18 02:06:44.330', '2025-01-18 02:06:44.330', '2025-01-18 02:06:58.584', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (10, '2025-01-18 02:06:47.929', '2025-01-18 02:06:47.929', '2025-01-18 02:06:54.280', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (11, '2025-01-18 02:08:35.226', '2025-01-18 02:08:35.226', '2025-01-18 02:30:35.515', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (12, '2025-01-18 02:10:55.308', '2025-01-18 02:10:55.308', '2025-01-18 02:30:37.008', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (13, '2025-01-18 02:11:11.069', '2025-01-18 02:11:11.069', '2025-01-18 02:13:15.590', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (14, '2025-01-18 02:11:24.210', '2025-01-18 02:11:24.210', '2025-01-18 02:12:55.325', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (15, '2025-01-18 02:13:55.865', '2025-01-18 02:13:55.865', '2025-01-18 02:30:40.026', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (16, '2025-01-18 02:14:33.177', '2025-01-18 02:14:33.177', '2025-01-18 02:18:58.122', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (17, '2025-01-18 02:14:37.975', '2025-01-18 02:14:37.975', '2025-01-18 02:18:38.312', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (18, '2025-01-18 02:16:03.573', '2025-01-18 02:16:03.573', '2025-01-18 02:18:34.426', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (19, '2025-01-18 02:16:13.071', '2025-01-18 02:16:13.071', '2025-01-18 02:18:30.236', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (20, '2025-01-18 02:17:22.693', '2025-01-18 02:17:22.693', '2025-01-18 02:17:27.863', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (21, '2025-01-18 02:20:56.495', '2025-01-18 02:20:56.495', NULL, 25, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (22, '2025-01-18 02:21:22.688', '2025-01-18 02:21:22.688', NULL, 3, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (23, '2025-01-18 02:23:09.114', '2025-01-18 02:23:09.114', NULL, 6, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (24, '2025-01-18 02:26:40.699', '2025-01-18 02:26:40.699', '2025-01-18 02:30:42.458', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (25, '2025-01-18 02:27:20.820', '2025-01-18 02:27:20.820', '2025-01-18 02:30:43.736', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (26, '2025-01-18 02:27:24.636', '2025-01-18 02:27:24.636', '2025-01-18 02:30:45.830', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (27, '2025-01-18 02:27:31.303', '2025-01-18 02:27:31.303', '2025-01-18 02:30:47.895', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (28, '2025-01-18 02:27:34.687', '2025-01-18 02:27:34.687', '2025-01-18 02:30:49.884', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (29, '2025-01-18 02:27:44.542', '2025-01-18 02:27:44.542', '2025-01-18 02:30:51.802', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (30, '2025-01-18 02:28:17.312', '2025-01-18 02:28:17.312', NULL, 72, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (31, '2025-01-18 02:28:33.165', '2025-01-18 02:28:33.165', NULL, 80, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (32, '2025-01-18 02:30:20.810', '2025-01-18 02:30:20.810', '2025-01-18 02:30:32.698', 29, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (33, '2025-01-18 02:31:01.250', '2025-04-27 23:53:26.174', NULL, 0, '数组', '# 数组理论基础\n\n<div style=\"border: 2px solid #FF9800; border-radius: 5px; background-color: #FFF3E0; padding: 15px; margin-top: 20px;\">   <i style=\"color: #FF9800; font-size: 24px; margin-bottom: 10px;\" class=\"fas fa-exclamation-circle\"></i><p style=\"color: #444;\">&#9997; 数组是一个非常基础且常见的数据结构，虽说大部分数组相关算法不会特别难，但是还是需要勤加练习的。</p> </div>\n\n&nbsp;\n\n数组是一段用于存储多个相同类型数据的数据结构，数组的每一个元素都被有序的存储在一段连续空间中。如下图：\n\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/ee0bfbbc-d690-11ef-8294-fe38d72b5b02.image.png)\n\n\n数组通过下标取值，第一个元素的下标为0。而且数组的随机访问非常快，时间复杂度为O(1)\n\n&nbsp;\n\n\n## 时间复杂度\n- 随机访问\n\n数组随机访问非常快，时间复杂度为O(1)。 这归功于数据存储的连续性。计算机可以非常瞬速的确定数组元素地址\n\n> 取地址公式：address = base_address + i * sizeof(array_element)\n\n`base_address`为数组的起始地址，`sizeof(array_element)`计算数组元素大小\n\n&nbsp;\n\n- 插入与删除\n\n数组的节点是无法被真实删除或者插入的\n\n&nbsp;\n\n当我们需要删除数组中某一个元素时，需要将待删除元素后面的所有元素往前移动一位，平均的时间复杂度为O(n)\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/ef7e3637-d695-11ef-8294-fe38d72b5b02.image.png)\n\n&nbsp;\n\n插入元素也是如此，假设我想在arr[2]后面插入一个元素，那么我就需要先将arr[2]后面元素整体后移一位，留出空间，然后再写入新元素。平均的时间复杂度为O(n)\n\n&nbsp;\n\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/3f4b3dc5-d74d-11ef-9666-fe38d72b5b02.image.png)\n\n\n\n\n## 可变长数组\n\n**数组还有一个特性，就是大小固定**。因为数组需要一段连续的内存空间（大小不固定会造成内存越界）\n\n&nbsp;\n\n很多时候我们无法预先确定我们需要的元素个数，所以大部分的现代的编程语言都会支持可变长的数组。比如`Go`里面的切片`(Slice)`，`JAVA`里面的`ArrayList`。\n\n&nbsp;\n\n它们的实现方式都大同小异，主要原理：\n1. 申请比数组长度更大容量，给数组添加元素的时候使用这部分为数组额外申请的容量\n\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/aea42ed8-d755-11ef-82c0-1adfa4c084c1.image.png)\n\n2. 当数组容量使用完成以后，重新申请新的更大的内存空间，将原来数组拷贝到新的内存空间中\n\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/570d61b5-d755-11ef-82c0-1adfa4c084c1.image.png)', 1, 1, 999987, 3);
INSERT INTO `visual_documents` VALUES (34, '2025-01-18 02:31:09.539', '2025-01-18 02:49:11.507', NULL, 34, '测试文档2', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (35, '2025-01-18 02:31:18.412', '2025-01-18 02:49:16.821', NULL, 35, '测试文档3', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (36, '2025-01-18 02:48:06.552', '2025-01-18 02:49:01.913', NULL, 36, '未命名9', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, NULL, 3);
INSERT INTO `visual_documents` VALUES (37, '2025-01-18 02:49:34.897', '2025-03-02 14:37:22.775', NULL, 33, '二分搜索', '# 二分查找\n\n<div style=\"border: 2px solid #FF9800; border-radius: 5px; background-color: #FFF3E0; padding: 15px; margin-top: 20px;\">   <i style=\"color: #FF9800; font-size: 24px; margin-bottom: 10px;\" class=\"fas fa-exclamation-circle\"></i><p style=\"color: #444;\">&#9997; 二分查找的思想非常简单，难在边界处理。很多人都是纯靠记忆，幸运的是我们有可视化算法，理解二分法会变得容易</p> </div>\n\n\n## 二分法思想\n\n> 二分查找的基本思想是将有序数组从中间分成两部分，然后将目标元素与中间元素进行比较。\n1.如果目标元素等于中间元素，则查找成功，返回中间元素的索引。\n2.如果目标元素小于中间元素，则在数组的左半部分继续进行二分查找。\n3.如果目标元素大于中间元素，则在数组的右半部分继续进行二分查找。\n重复上述步骤，直到找到目标元素或者确定目标元素不存在于数组中。\n\n\n二分查找思想非常简单，但是想要处理好边界条件并不简单，很多人写二分容易出现死循环\n\n&nbsp;\n\n因为查找的区间是不断迭代的，在迭代过程中需要保持查找的区间开闭是保证不变的，很多人没有注意到这点。常用的区间类型如下：\n- 左闭右闭[left, right]\n- 左闭右开[left, right)\n\n## 例题\n[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)\n\n&nbsp;\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n**示例 :**\n\n> 输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n\n\n&nbsp;\n\n\n### 左闭右闭写法\n~~~go\npackage main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left <= right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid - 1\n		} else {\n			return mid\n		}\n	}\n	return -1\n}\n~~~\n\n因为我们维护的区间是一个左闭右闭的区间，目标元素在我们的`[left, right]`区间内\n- 循环条件是：`for(left <= right)`，因为当区间`left == right`的时候`[left, right]`区间是有意义的，数组只有一个元素。需要进入循环继续查找\n- 判断条件`nums[mid] < target`的时候，可以排除`mid`左边的所有元素（包含`mid`）。所以我们的新区间是`[mid + 1, right]`\n- 判断条件`nums[mid] > target`也是如此，条件成立时可以排除`mid`右边的元素（包含`mid`）。所以新区间时`[left, mid - 1]`\n\n**将以上代码拷贝到可视化调试区域调试一下。便可以理解。**\n\n\n&nbsp;\n\n尝试反面例子：\n> 用例：nums = [1, 2, 3, 4, 5, 6, 7, 8] target = 8\n> 将`for(left <= right)`改成`for(left < right)`进行调试\n\n> 用例：nums = [1, 2, 3, 4, 5, 6, 7, 8] target = 5\n> 将`left = mid + 1`改成`left = mid`进行调试\n\n> 用例：nums = [1, 2, 3, 4, 5, 6, 7, 8] target = 5\n> 将`left = mid + 1`改成`left = mid`进行调试\n\n结果你会发现，最后一个用例其实是可以通过的，大家可以去思考为什么。因为`mid = (left + right)`其实会的到一个偏左的值。无论`left = mid + 1`还是`right = mid`都会让目标区间不断缩小，直到找到`target`值。所以，左闭右闭写法可以做一个简化。\n~~~go\npackage main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left < right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] >= target) {\n			right = mid\n		}\n	}\n	return nums[right]\n}\n~~~\n\n\n### 左闭右开写法\n~~~go\npackage main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums)\n	for (left < right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid\n		} else {\n			return mid\n		}\n	}\n	return -1\n}\n~~~\n\n因为我们维护的区间是一个左闭右开的区间，目标元素在我们的`[left, right)`区间内\n- `right`初始值为`len(nums)`而不是`len(nums) - 1`，因为右边是开区间，只有`[0, len(nums))`才能包含所有元素\n- 循环条件是`for(left < right)`，因为当区间`left == right`的时候`[left, right)`区间是没有意义\n- 判断条件`nums[mid] > target`成立时，可以排除`mid`往右的元素（包含mid）。新区间为`[left, mid)`，所以`right = mid`\n\n**将以上代码拷贝到可视化调试区域调试一下。便可以理解。**\n\n\n&nbsp;\n\n尝试反面例子：\n> 用例：nums = [1, 2, 3, 4, 5, 6, 7, 8] target = 8\n> 将`right = len(nums)`改成`right = len(nums) - 1`进行调试\n\n> 用例：nums = [1, 2, 3, 4, 5, 6, 7, 8] target = 9\n> 将`for(left < right)`改成`for(left <= right)`进行调试', 1, 1, 1000000, 3);
INSERT INTO `visual_documents` VALUES (38, '2025-01-18 02:49:38.867', '2025-04-27 23:53:26.292', NULL, 0, '二叉树', '# 二叉树\n\n二叉树也是一种常用的数据结构， 下面是一棵二叉树：\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/3b65c07f-e709-11ef-8cce-00155dcf59da.image.png)\n\n\n## 二叉树存储方式\n二叉树有两种存储方式：链式存储、顺序存储\n### 链式存储\n链式存储时通过指针将内存中的各个节点连成一棵树\n~~~go\ntype TreeNode struct {\n	Val   int       //节点值\n	Left  *TreeNode //左子树\n	Right *TreeNode //右子树\n}\n~~~\n\n### 顺序存储\n顺序存储就是通过数组进行存储\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/38ff7632-e719-11ef-8cce-00155dcf59da.image.png)\n## 二叉树类型\n\n### 完全二叉树\n完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，**并且叶子节点都是从左到右依次排布**（堆为完全二叉树）\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/6908ceaf-e715-11ef-8cce-00155dcf59da.image.png)\n\n### 满二叉树\n满二叉树：在一棵二叉树中，所有的节点（非叶子节点）都存在左子树和右子树，并且所有的叶子节点都在同一层上\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/569d6b1e-e715-11ef-8cce-00155dcf59da.image.png)\n## 二叉搜索树\n二叉搜索树（Binary Search Tree，BST）：对于树中的每个节点，满足以下条件：\n- 左子树：该节点的左子树中的所有节点的值都小于该节点的值\n- 右子树：该节点的右子树中的所有节点的值都大于该节点的值\n- 递归性质：左子树和右子树也分别是二叉搜索树\n\n\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/9af6fb97-e715-11ef-8cce-00155dcf59da.image.png)\n第二棵不是二叉搜索树，因为5节点的左子树中有值为6的节点，比5要大\n### 平衡的二叉搜索树\n平衡的二叉搜索树（Adelson-Velsky and Landis，AVL）：二叉平衡树是一种特殊的二叉搜索树，对于任意一个节点，其左子树和右子树的高度差（平衡因子）的绝对值不超过 1。并且，它的左子树和右子树也分别是二叉平衡树\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/bbe1e212-e716-11ef-8cce-00155dcf59da.image.png)\n\n## 二叉树的遍历方式\n二叉树主要有两种遍历方式：\n\n- 深度优先遍历：先往深走，遇到叶子节点再往回走\n- 广度优先遍历：一层一层的进行遍历\n\n我们在这一篇先不对二叉树的遍历进行深究，下面列出基本的遍历方式，先混个眼熟\n### 深度优先遍历\n- **先序遍历**：先访问根节点，然后递归地遍历左子树，最后递归地遍历右子树，即根节点 - 左子树 - 右子树\n- **中序遍历**：先递归地遍历左子树，然后访问根节点，最后递归地遍历右子树，即左子树 - 根节点 - 右子树\n- **后序遍历**：先递归地遍历左子树，然后递归地遍历右子树，最后访问根节点，即左子树 - 右子树 - 根节点\n### 广度优先\n- **层次遍历**：按照从上到下、从左到右的顺序逐层访问二叉树的节点', 1, 1, 999985, 3);
INSERT INTO `visual_documents` VALUES (39, '2025-01-18 02:56:43.428', '2025-04-27 23:53:26.233', NULL, 0, '链表', '# 链表\n\n数组有很多优点，比如随机访问特别快。但是因为数组是有序的，对空间的连续性有要求，导致数组空间长度不可变\n\n&nbsp;\n\n虽然有可变长数组的方案，但是插入节点比较多的时候还需要进行扩容，扩容则需要将数据拷贝到一个新的空间，并释放旧空间，这个操作还是有不小的损耗\n\n&nbsp;\n\n所以这就引入了一个新的数据结构，链表\n\n## 单向链表\n\n单向链表的结构体如下：\n~~~go\ntype LinkNode struct {\n	Next *LinkNode  // 链表当前节点的下一个节点\n	Val  int        // 链表值\n}\n~~~\n使用`Val`存储链表的值，使用`Next`存储链表当前节点的下一个节点\n&nbsp;\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/74cbd59e-e6f4-11ef-8078-00155dcf59da.image.png)\n\n### 构建\n\n链表的构建非常简单，只需要使用一个`tail`指针始终指向链表的尾节点即可。有新结点添加，只需要让`tail.Next`指向新的节点，并更新`tail`节点即可\n~~~go\narr := []int{1, 7, 8, 5, 9}\nvar header *LinkNode\nvar tail *LinkNode\nfor _, v := range arr {\n	node := &LinkNode{\n		Val: v,\n	}\n	if header == nil {\n		header = node\n		tail = node\n	} else {\n		// 连接节点\n		tail.Next = node\n		// 更新tail节点\n		tail = tail.Next\n	}\n}\n~~~\n\n### 打印\n对于链表的打印，需要对整个链表进行遍历，并将每个节点的值打印出来\n~~~go\nfunc Print(header *LinkNode) {\n	// 使用node指向从链表头部开始遍历\n	node := header\n	for node != nil {\n		fmt.Println(node.Val)\n		node = node.Next\n	}\n}\n~~~\n\n\n### 删除\n链表节点的删除相对复杂，需要找到待删除节点的上一个节点。这里有两种情况：\n- 待删除节点为链表的头节点：只需要让`header = header.Next`，并释放待删除节点的空间\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/a266b809-e6f6-11ef-8078-00155dcf59da.image.png)\n- 待删除节点非链表头节点：需要找到待删除节点的上一个节点Pre节点，然后让`Pre.Next`指向待删除节点的下一个节点，并释放待删除节点即可完成删除动作\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/0d5fe6de-e6f7-11ef-8078-00155dcf59da.image.png)\n~~~go\nfunc Delete(header *LinkNode, target int) *LinkNode {\n	if header == nil {\n		return nil\n	}\n	var pre *LinkNode\n	node := header\n	for node != nil && node.Val != target {\n		pre = node\n		node = node.Next\n	}\n	// node节点不为空哦，说明找到目标节点\n	if node != nil {\n		if pre == nil {\n			// pre为空意味着目标节点为header节点，只需要更新header即可\n			header = header.Next\n		} else {\n			// pre不为空意味着目标节点不是header节点，pre节点指向目标节点的下一个节点\n			pre.Next = node.Next\n		}\n		// 释放目标节点，这一步go有自动垃圾回收，我们不需要操心\n	}\n	// 返回新的header节点\n	return header\n}\n~~~\n\n## 双向链表\n双向链表不仅有`Next`指向，还有一个`Pre`指针，指向当前节点的上一个节点\n~~~go\ntype LinkNode struct {\n	Val  int\n	Next *LinkNode\n	Prev *LinkNode\n}\n~~~\n\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/c226dfb0-e6fb-11ef-8078-00155dcf59da.image.png)\n这样能让链表的操作更加灵活，比如：\n- 删除链表尾节点的时候，单向链表需要从链表头部遍历到尾部，找到链表尾节点的上一个节点，才能对尾节点进行删除。但是双向链表不需要这么麻烦，只需要使用`tail.Prev`即可找到待删节点的上一个节点\n\n## 循环链表\n\n循环链表的`tail.Next`不是指向`NULL`，而是指向链表的头节点，形成一个闭环\n\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/738e7e2e-e6fc-11ef-8078-00155dcf59da.image.png)\n\n这种结构允许我们从链表的任意一个节点出发遍历整个链表', 1, 1, 999986, 3);
INSERT INTO `visual_documents` VALUES (40, '2025-01-27 00:26:52.621', '2025-02-11 00:36:06.605', NULL, 33, '长度最小的子数组', '# 长度最小的子数组\n\n[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n&nbsp;\n\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n## 解题思路\n定义两个指针 start 和 end 分别表示子数组（滑动窗口窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和（即从 nums[start] 到 nums[end] 的元素和）。\n&nbsp;\n初始状态下，start 和 end 都指向下标 0，sum 的值为 0。\n&nbsp;\n每一轮迭代，将 nums[end] 加到 sum，如果 sum≥s，则更新子数组的最小长度（此时子数组的长度是 end−start+1），然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum<s，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 end 右移。\n\n\n\n## 其他题目', 1, 0, 999999, 3);
INSERT INTO `visual_documents` VALUES (41, '2025-01-27 00:27:47.597', '2025-01-27 00:49:29.626', NULL, 33, '移除元素', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, 999998, 3);
INSERT INTO `visual_documents` VALUES (42, '2025-02-10 01:10:03.255', '2025-02-10 23:30:24.809', NULL, 38, '三种遍历方式', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, 999998, 3);
INSERT INTO `visual_documents` VALUES (43, '2025-02-10 23:30:10.150', '2025-02-11 00:30:47.834', NULL, 38, '链式存储', '# 链式存储\n\n链式存储时通过指针将内存中的各个节点连成一棵树\n~~~go\ntype TreeNode struct {\n	Val   int       //节点值\n	Left  *TreeNode //左子树\n	Right *TreeNode //右子树\n}\n~~~\n\n这里将使用链式存储的方式操作一棵二叉搜索树，当然你也可以尝试自己实现。二叉树接口如下：\n~~~go\n// 添加节点\nfunc Insert(tree *TreeNode, val int) *TreeNode {\n\n}\n\n// 删除节点\nfunc Delete(tree *TreeNode, val int) *TreeNode {\n\n}\n\n// 查找\nfunc Find(tree *TreeNode, val int) bool {\n\n}\n~~~\n\n## 实现\n~~~go\n', 1, 0, 1000000, 3);
INSERT INTO `visual_documents` VALUES (44, '2025-02-10 23:30:21.622', '2025-02-10 23:30:24.753', NULL, 38, '顺序存储', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, 999999, 3);
INSERT INTO `visual_documents` VALUES (45, '2025-03-02 14:39:37.995', '2025-03-08 20:45:58.869', NULL, 37, '红蓝二分法', '# 模版方法-红蓝二分法\n\n二分查找分为查找＜ 、≤ 、= 、≥ 、＞等目标元素以及符合各种自定义条件的结果，数组中可能还会有重复元素，大大增加了查找难度以及各种各样的边界条件处理复杂性，很容易让脑子乱成一团。\n那么接下来分享一套相对便于理解的二分模板来通杀二分查找题。\n\n## 写在前面\n本文模板非原创，核心内容均转自B站[【五点七边】](https://www.bilibili.com/video/BV1d54y1q7k7)。\n虽然蓝红二分法不是唯一的二分查找模板，但是它的二分建模思路非常值得学习，在深入理解二分查找的原理后，同学们甚至可以自创二分查找模板进行解题，模板只是思想的具象化体现，想要达到完全抛弃模板随心所欲的无招胜有招境界，掌握二分查找模板中蕴含的二分思想是第一步，下面就从学习蓝红二分法开始吧！\n\n## 核心要义\n利用红蓝色来体会**循环不变量**。\n\n## 模板方法\n将一个长度为n的数组分为蓝红两个部分，其中前k个元素是蓝色的，后n - 1 - k个元素是红色的，但是蓝红两部分的边界k是模糊的。\n现在，我们初始两个变量分别为l、r，其中l指向蓝色区域，r指向红色区域，循环让l、r快速向蓝红边界逼近，**保持l和r颜色不变**，最终l和r会处于蓝红边界。\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/2c6e24a9-fc1a-11ef-be95-0242ac110002.20250308203740.gif)\n\n## 细节讲解\n现在有一个数组[0, n-1]，以下是代码模板\n```go\nfunc redBlueSearch(){\n    left, right := -1, n\n    for left + 1 != right {\n        // 避免溢出，有时候可能需要改变下\n        mid := left + (right - left)>>1\n        if isBlue(mid) {\n            left = mid\n        } else {\n            right = mid\n        }\n    }\n    return left or right\n}\n```\n| 为什么left不从0开始，right不从n-1开始\n因为如果所有数组都是红色（一个颜色的），初始化的时候就已经错误了\n\n| 上下界能否保证mid一定处于[0, n)中\n最小：left=-1, right=1  因为如果right=0，会因为left+1==right直接退出循环\n最大：left=n-2, right=n 得出mid=(n-1)，在范围内\n\n| 是否会出现死循环\n- 当left, x, right 。x=0时会直接退出循环\n- 当x=1，mid=x。下一步会将left右移一位或right左移一位，回到第一种情况\n- 当x=2，mid=中间俩块的其中一个，下一步会回到上一种情况\n\n| 更新指针时为什么不用left=mid+1，right=mid-1\n容易造成错误，当left已经是蓝红边界时，下一步会将left更新为红色边界，导致错误。\n\n\n### 蓝红划分\n\n\n## 相关题解', 34, 0, 1, 3);
INSERT INTO `visual_documents` VALUES (46, '2025-04-02 00:11:47.345', '2025-04-27 23:53:26.115', NULL, 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2\n\n', 1, 0, 999988, 0);
INSERT INTO `visual_documents` VALUES (47, '2025-04-02 00:13:33.985', '2025-04-27 23:53:26.056', NULL, 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, 999989, 0);
INSERT INTO `visual_documents` VALUES (48, '2025-04-02 00:38:25.237', '2025-04-27 23:53:25.997', NULL, 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, 999990, 0);
INSERT INTO `visual_documents` VALUES (49, '2025-04-02 00:39:06.146', '2025-04-27 23:53:25.938', NULL, 0, '二分搜索', '# 二分查找\n\n<div style=\"border: 2px solid #FF9800; border-radius: 5px; background-color: #FFF3E0; padding: 15px; margin-top: 20px;\">   <i style=\"color: #FF9800; font-size: 24px; margin-bottom: 10px;\" class=\"fas fa-exclamation-circle\"></i><p style=\"color: #444;\">&#9997; 二分查找的思想非常简单，难在边界处理。很多人都是纯靠记忆，幸运的是我们有可视化算法，理解二分法会变得容易</p> </div>\n\n\n## 二分法思想\n\n> 二分查找的基本思想是将有序数组从中间分成两部分，然后将目标元素与中间元素进行比较。\n1.如果目标元素等于中间元素，则查找成功，返回中间元素的索引。\n2.如果目标元素小于中间元素，则在数组的左半部分继续进行二分查找。\n3.如果目标元素大于中间元素，则在数组的右半部分继续进行二分查找。\n重复上述步骤，直到找到目标元素或者确定目标元素不存在于数组中。\n\n\n二分查找思想非常简单，但是想要处理好边界条件并不简单，很多人写二分容易出现死循环\n\n&nbsp;\n\n因为查找的区间是不断迭代的，在迭代过程中需要保持查找的区间开闭是保证不变的，很多人没有注意到这点。常用的区间类型如下：\n- 左闭右闭[left, right]\n- 左闭右开[left, right)\n\n## 例题\n[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)\n\n&nbsp;\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n**示例 :**\n\n> 输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n\n\n&nbsp;\n\n\n### 左闭右闭写法\n~~~go\npackage main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left <= right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid - 1\n		} else {\n			return mid\n		}\n	}\n	return -1\n}\n~~~\n\n因为我们维护的区间是一个左闭右闭的区间，目标元素在我们的`[left, right]`区间内\n- 循环条件是：`for(left <= right)`，因为当区间`left == right`的时候`[left, right]`区间是有意义的，数组只有一个元素。需要进入循环继续查找\n- 判断条件`nums[mid] < target`的时候，可以排除`mid`左边的所有元素（包含`mid`）。所以我们的新区间是`[mid + 1, right]`\n- 判断条件`nums[mid] > target`也是如此，条件成立时可以排除`mid`右边的元素（包含`mid`）。所以新区间时`[left, mid - 1]`\n\n**将以上代码拷贝到可视化调试区域调试一下。便可以理解。**\n\n\n&nbsp;\n\n尝试反面例子：\n> 用例：nums = [1, 2, 3, 4, 5, 6, 7, 8] target = 8\n> 将`for(left <= right)`改成`for(left < right)`进行调试\n\n> 用例：nums = [1, 2, 3, 4, 5, 6, 7, 8] target = 5\n> 将`left = mid + 1`改成`left = mid`进行调试\n\n> 用例：nums = [1, 2, 3, 4, 5, 6, 7, 8] target = 5\n> 将`left = mid + 1`改成`left = mid`进行调试\n\n结果你会发现，最后一个用例其实是可以通过的，大家可以去思考为什么。因为`mid = (left + right)`其实会的到一个偏左的值。无论`left = mid + 1`还是`right = mid`都会让目标区间不断缩小，直到找到`target`值。所以，左闭右闭写法可以做一个简化。\n~~~go\npackage main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums) - 1\n	for (left < right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] >= target) {\n			right = mid\n		}\n	}\n	return nums[right]\n}\n~~~\n\n\n### 左闭右开写法\n~~~go\npackage main\nimport (\n	\"fmt\"\n)\nfunc main() {\n	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}\n	target := 7 \n	answer := search(nums, target)\n	fmt.Println(answer)\n}\nfunc search(nums []int, target int) int {\n	left := 0\n	right := len(nums)\n	for (left < right) {\n		mid := left + (right - left) / 2;\n		if (nums[mid] < target) {\n			left = mid + 1\n		} else if (nums[mid] > target) {\n			right = mid\n		} else {\n			return mid\n		}\n	}\n	return -1\n}\n~~~\n\n因为我们维护的区间是一个左闭右开的区间，目标元素在我们的`[left, right)`区间内\n- `right`初始值为`len(nums)`而不是`len(nums) - 1`，因为右边是开区间，只有`[0, len(nums))`才能包含所有元素\n- 循环条件是`for(left < right)`，因为当区间`left == right`的时候`[left, right)`区间是没有意义\n- 判断条件`nums[mid] > target`成立时，可以排除`mid`往右的元素（包含mid）。新区间为`[left, mid)`，所以`right = mid`\n\n**将以上代码拷贝到可视化调试区域调试一下。便可以理解。**\n\n\n&nbsp;\n\n尝试反面例子：\n> 用例：nums = [1, 2, 3, 4, 5, 6, 7, 8] target = 8\n> 将`right = len(nums)`改成`right = len(nums) - 1`进行调试\n\n> 用例：nums = [1, 2, 3, 4, 5, 6, 7, 8] target = 9\n> 将`for(left < right)`改成`for(left <= right)`进行调试', 1, 0, 999991, 1);
INSERT INTO `visual_documents` VALUES (50, '2025-04-02 00:39:17.349', '2025-04-02 00:39:30.750', '2025-04-03 00:35:04.052', 49, '测试2', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, 1000000, 1);
INSERT INTO `visual_documents` VALUES (51, '2025-04-04 17:41:01.603', '2025-04-06 23:35:09.118', '2025-04-06 23:36:04.999', 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, 999993, 1);
INSERT INTO `visual_documents` VALUES (52, '2025-04-05 21:15:48.385', '2025-08-16 20:38:56.949', NULL, 0, '基础语法', '# C语言介绍\n\n> C 语言是由美国计算机科学家丹尼斯・里奇（Dennis Ritchie）于 20 世纪 70 年代初在贝尔实验室开发的高级程序设计语言。该语言以 B 语言为基础发展而来，最初用于开发 UNIX 操作系统，凭借其强大的功能和高效性，逐渐成为应用最为广泛的编程语言之一，对后续众多编程语言的设计和发展产生了深远影响\n\n### 特点\n- **高效性**：它能直接操作硬件资源，执行效率高，接近汇编语言\n- **灵活性**：具备丰富的运算符和数据类型，支持指针操作，可对内存进行精准控制\n- **可移植性**：编写的程序在不同操作系统和硬件平台上，只需少量修改甚至无需修改就能运行\n- **功能强大**：既适合开发系统软件，也能开发应用软件\n\n### 应用场景\nC语言的应用场景广泛，涵盖操作系统、嵌入式系统、游戏开发、数据库管理系统等领域\n\n### 简单示例\n下面是一个经典的C语言程序，用于在屏幕上输出“Hello, World!”，也是程序学习开始的仪式：\n```c\n#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n```', 1, 1, 999996, 1);
INSERT INTO `visual_documents` VALUES (53, '2025-04-05 23:19:50.984', '2025-04-06 23:20:42.535', '2025-04-06 23:20:52.363', 0, '结构体', '# 结构体\n\n## 基本概念\n在 C 语言里，结构体属于用户自定义的数据类型，它能够把不同类型的数据组合成一个整体。这在处理复杂的数据结构时极为有用，比如描述一个人，可能会涉及姓名、年龄、性别等不同类型的信息，就可以用结构体把这些信息整合在一起。\n\n## 结构体的定义\n结构体的定义格式如下：\n```c\nstruct 结构体名 {\n    数据类型 成员名1;\n    数据类型 成员名2;\n    // 可以有更多成员\n};\n```\n以下是一个定义 “学生” 结构体的例子：\n```c\nstruct Student {\n    char name[50];\n    int age;\n    float score;\n};\n```\n在这个例子中，`struct Student`就是自定义的结构体类型，它包含三个成员：name（字符数组，用于存储姓名）、age（整数类型，用于存储年龄）和 score（浮点类型，用于存储分数）。\n\n## 声明与初始化\n定义好结构体后，就可以声明该结构体类型的变量，并且对其进行初始化。\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Student {\n    char name[50];\n    int age;\n    float score;\n};\n\nint main() {\n    // 声明结构体变量并初始化\n    struct Student stu1 = {\"张三\", 20, 85.5};\n\n    // 另一种初始化方式\n    struct Student stu2;\n    strcpy(stu2.name, \"李四\");\n    stu2.age = 21;\n    stu2.score = 90.0;\n\n    printf(\"学生1: 姓名 %s, 年龄 %d, 分数 %.2f\\n\", stu1.name, stu1.age, stu1.score);\n    printf(\"学生2: 姓名 %s, 年龄 %d, 分数 %.2f\\n\", stu2.name, stu2.age, stu2.score);\n\n    return 0;\n}\n```\n代码解释：\n- `struct Student stu1 = {\"张三\", 20, 85.5};`：这种方式是在声明结构体变量 stu1 的同时进行初始化，按照结构体成员的顺序依次赋值。\n- `struct Student stu2;`：先声明结构体变量 stu2，然后通过成员访问运算符 . 分别给每个成员赋值。对于字符数组 name，使用 strcpy 函数来复制字符串。\n\n## 结构体数组\n结构体数组就是由多个相同结构体类型的元素组成的数组。\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Student {\n    char name[50];\n    int age;\n    float score;\n};\n\nint main() {\n    // 声明结构体数组并初始化\n    struct Student students[2] = {\n        {\"张三\", 20, 85.5},\n        {\"李四\", 21, 90.0}\n    };\n\n    for (int i = 0; i < 2; i++) {\n        printf(\"学生%d: 姓名 %s, 年龄 %d, 分数 %.2f\\n\", i + 1, students[i].name, students[i].age, students[i].score);\n    }\n\n    return 0;\n}\n```\n代码解释：\n- `struct Student students[2]`：声明了一个包含两个 struct Student 类型元素的数组。\n通过 for 循环遍历结构体数组，使用成员访问运算符 . 访问每个结构体元素的成员并输出信息。\n\n## 结构体指针\n结构体指针就是指向结构体变量的指针。\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Student {\n    char name[50];\n    int age;\n    float score;\n};\n\nint main() {\n    struct Student stu = {\"张三\", 20, 85.5};\n    struct Student *p = &stu;\n\n    // 使用指针访问结构体成员\n    printf(\"学生: 姓名 %s, 年龄 %d, 分数 %.2f\\n\", p->name, p->age, p->score);\n\n    return 0;\n}\n```\n代码解释：\n- `struct Student *p = &stu;`：声明一个 struct Student 类型的指针 p，并让它指向结构体变量 stu。\n- 使用`->`运算符通过指针访问结构体成员。`p->name`等价于`(*p).name`。\n\n## 结构体作为函数参数\n结构体可以作为函数的参数传递，有值传递和地址传递两种方式。\n值传递\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Student {\n    char name[50];\n    int age;\n    float score;\n};\n\n// 函数接收结构体作为参数（值传递）\nvoid printStudent(struct Student s) {\n    printf(\"学生: 姓名 %s, 年龄 %d, 分数 %.2f\\n\", s.name, s.age, s.score);\n}\n\nint main() {\n    struct Student stu = {\"张三\", 20, 85.5};\n    printStudent(stu);\n\n    return 0;\n}\n```\n地址传递\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Student {\n    char name[50];\n    int age;\n    float score;\n};\n\n// 函数接收结构体指针作为参数（地址传递）\nvoid updateStudent(struct Student *p) {\n    strcpy(p->name, \"李四\");\n    p->age = 21;\n    p->score = 90.0;\n}\n\nint main() {\n    struct Student stu = {\"张三\", 20, 85.5};\n    updateStudent(&stu);\n    printf(\"学生: 姓名 %s, 年龄 %d, 分数 %.2f\\n\", stu.name, stu.age, stu.score);\n\n    return 0;\n}\n```\n\n代码解释：\n- 值传递时，函数接收的是结构体变量的副本，在函数内部对参数的修改不会影响到原结构体变量。\n- 地址传递时，函数接收的是结构体变量的地址，在函数内部通过指针修改结构体成员会影响到原结构体变量。', 1, 0, 999997, 1);
INSERT INTO `visual_documents` VALUES (54, '2025-04-06 14:25:52.139', '2025-04-27 23:53:25.820', NULL, 0, '排序算法', '# 排序算法\n', 1, 1, 999993, 1);
INSERT INTO `visual_documents` VALUES (55, '2025-04-06 14:26:07.645', '2025-04-06 16:33:07.538', NULL, 54, '冒泡排序', '# 冒泡排序\n\n## 1. 基本思想\n冒泡排序（Bubble Sort）是一种基础的排序算法。通过对待排序序列从前向后的元素进行两两比较，若发现顺序错误就交换，使值较大的元素逐渐从前面移向后面，就像是气泡一样逐渐向上冒。\n\n## 2. 算法原理\n冒泡排序具体步骤如下：\n- 从数组的第一个元素开始，比较相邻的两个元素。\n- 如果顺序错误（即前一个元素大于后一个元素），则交换它们的位置。\n- 对数组中的每一对相邻元素重复上述步骤，直到数组的最后一个元素。此时，最大的元素会被移动到数组的末尾。\n- 重复上述步骤，但是这次只需要比较到倒数第二个元素，因为最大的元素已经在正确的位置上了。\n- 不断重复这个过程，直到整个数组都被排序。\n\n<iframe  \n height=500\n width=90% \n src=\"https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/bubble-sort.html\"  \n frameborder=0  \n allowfullscreen>\n </iframe>\n\n## 3. 代码实现（C语言）\n\n\n```c\n#include <stdio.h>\n\n// 冒泡排序函数\nvoid bubbleSort(int arr[], int n) {\n    int i, j, temp;\n    for (i = n - 1; i > 0; i--) {\n        for (j = 0; j < i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换 arr[j] 和 arr[j+1]\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"排序后的数组: \\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n```\n\n## 4. 代码解释\n- **`bubbleSort` 函数**：\n  - 外层循环 `for (i = n - 1; i > 0; i--)` 控制排序的轮数，总共需要进行 `n - 1` 轮排序。\n  - 内层循环 `for (j = 0; j < i; j++)` 用于比较相邻的元素，并在需要时交换它们的位置。每一轮排序后，最大的元素会被移动到数组的末尾，因此下一轮排序时可以减少比较的次数。\n  - `if (arr[j] > arr[j + 1])` 条件判断如果前一个元素大于后一个元素，则交换它们的位置。\n\n## 5. 复杂度分析\n- **时间复杂度**：冒泡排序的时间复杂度是`O(n^2)`，其中`n`是数组的长度。这是因为需要进行两层嵌套的循环来比较和交换元素。\n- **空间复杂度**：冒泡排序只需要常数级的额外空间，因此空间复杂度是`O(1)`。\n\n#### 6. 优缺点\n- **优点**：\n  - 实现简单，易于理解。\n  - 适用于小规模数据的排序。\n\n- **缺点**：\n  - 时间复杂度较高，对于大规模数据的排序效率较低。\n\n## 7. 优化建议\n在冒泡排序的基础上，可以添加一个标志位来判断是否在某一轮排序中没有发生交换，如果没有发生交换，则说明数组已经有序，可以提前结束排序过程。以下是优化后的代码：\n```c\n#include <stdio.h>\n\n// 优化后的冒泡排序函数\nvoid optimizedBubbleSort(int arr[], int n) {\n    int i, j, temp;\n    int swapped;\n    for (i = n - 1; i > 0; i--) {\n        swapped = 0;\n        for (j = 0; j < i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换 arr[j] 和 arr[j+1]\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n                swapped = 1;\n            }\n        }\n        // 如果没有发生交换，说明数组已经有序，提前结束排序\n        if (swapped == 0) {\n            break;\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    optimizedBubbleSort(arr, n);\n    printf(\"排序后的数组: \\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n```\n\n通过添加 `swapped` 标志位，可以在数组已经有序的情况下提前结束排序，从而提高排序效率。', 1, 1, 1000000, 1);
INSERT INTO `visual_documents` VALUES (56, '2025-04-06 15:54:49.648', '2025-04-09 01:06:50.043', NULL, 54, '插入排序', '# 插入排序\n\n## 1. 基本思想\n插入排序和冒泡排序一样是一种简单直观的排序算法，插入排序的核心操作是在一个已经有序的序列中，嵌入一条新记录，以此构建出一个元素数量增加 1 且依旧有序的新序列。\n\n\n## 2. 算法原理\n插入排序将数组分为已排序和未排序两部分。初始时，已排序部分只有一个元素（通常是数组的第一个元素），未排序部分包含数组的其余元素。算法重复地从未排序部分取出一个元素，将其插入到已排序部分的正确位置，直到整个数组都被排序。\n\n1. **遍历数组**：从第二个元素开始，依次将每个元素插入到已排序部分的正确位置。\n2. **找到插入位置**：对于当前要插入的元素，从已排序部分的末尾开始向前比较，如果当前元素小于已排序部分的元素，则将已排序部分的元素向后移动一位，直到找到合适的插入位置。\n3. **插入元素**：将当前元素插入到找到的位置。\n\n### C语言代码实现\n```c\n#include <stdio.h>\n\n// 插入排序函数\nvoid insertionSort(int arr[], int n) {\n    int i, key, j;\n    for (i = 1; i < n; i++) {\n        key = arr[i];\n        j = i - 1;\n\n        // 将比 key 大的元素向后移动\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n// 打印数组函数\nvoid printArray(int arr[], int n) {\n    int i;\n    for (i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\n// 主函数\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"原始数组: \\n\");\n    printArray(arr, n);\n\n    insertionSort(arr, n);\n\n    printf(\"排序后的数组: \\n\");\n    printArray(arr, n);\n\n    return 0;\n}\n```\n\n### 代码解释\n1. **`insertionSort` 函数**：该函数实现了插入排序的核心逻辑。它接受一个整数数组 `arr` 和数组的长度 `n` 作为参数。\n2. **外层循环**：从第二个元素开始遍历数组，将每个元素作为要插入的元素。\n3. **内层循环**：将当前元素与已排序部分的元素进行比较，将比当前元素大的元素向后移动一位，直到找到合适的插入位置。\n4. **插入元素**：将当前元素插入到找到的位置。\n\n### 复杂度分析\n- **时间复杂度**：插入排序的平均时间复杂度为`O(n^2)`，其中`n`是数组的长度。在最坏情况下，即数组完全逆序时，需要进行`n(n - 1) / 2`次比较和交换。\n- **空间复杂度**：插入排序只需要常数级的额外空间，因此空间复杂度为`O(1)`。', 1, 1, 999998, 1);
INSERT INTO `visual_documents` VALUES (57, '2025-04-06 16:33:04.451', '2025-04-09 01:07:13.854', NULL, 54, '选择排序', '# 选择排序\n\n## 1. 基本思想\n选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到排序结束。\n\n## 2. 算法原理\n选择排序具体步骤如下：\n\n1. **初始化**：假设我们有一个长度为 `n` 的数组，我们将数组分为已排序部分和未排序部分，初始时已排序部分为空，未排序部分是整个数组。\n2. **寻找最小元素**：在未排序部分中找到最小的元素。\n3. **交换元素**：将找到的最小元素与未排序部分的第一个元素交换位置，这样这个最小元素就被放到了已排序部分的末尾。\n4. **重复步骤 2 和 3**：不断重复上述过程，直到未排序部分为空。\n<iframe  \n height=500\n width=90% \n src=\"https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/selection-sort.html\"  \n frameborder=0  \n allowfullscreen>\n </iframe>\n\n## 3. 代码示例\n```c\n#include <stdio.h>\n\n// 选择排序函数\nvoid selectionSort(int arr[], int n) {\n    int i, j, min_idx;\n\n    // 遍历数组\n    for (i = 0; i < n - 1; i++) {\n        // 找到未排序部分的最小元素的索引\n        min_idx = i;\n        for (j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n\n        // 将找到的最小元素与未排序部分的第一个元素交换位置\n        if (min_idx != i) {\n            int temp = arr[i];\n            arr[i] = arr[min_idx];\n            arr[min_idx] = temp;\n        }\n    }\n}\n\n// 打印数组的函数\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    // 打印排序前的数组\n    printf(\"排序前的数组: \\n\");\n    printArray(arr, n);\n\n    // 调用选择排序函数\n    selectionSort(arr, n);\n\n    // 打印排序后的数组\n    printf(\"排序后的数组: \\n\");\n    printArray(arr, n);\n\n    return 0;\n}\n```\n\n### 代码解释\n1. **`selectionSort` 函数**：\n    - 外层循环 `for (i = 0; i < n - 1; i++)` 控制已排序部分的边界，每次循环结束后，已排序部分的长度增加 1。\n    - 内层循环 `for (j = i + 1; j < n; j++)` 用于在未排序部分中寻找最小元素的索引。\n    - 如果找到的最小元素的索引 `min_idx` 不等于当前未排序部分的第一个元素的索引 `i`，则交换这两个元素的位置。\n\n\n### 复杂度分析\n- **时间复杂度**：选择排序的时间复杂度是`O(n^2)`，因为它需要两层嵌套循环来完成排序。\n- **空间复杂度**：选择排序的空间复杂度是`O(1)`，因为它只需要常数级的额外空间。\n\n通过以上的教程和代码示例，你应该对选择排序有了一个基本的了解，并且能够使用`C`语言实现选择排序算法。', 1, 1, 999999, 1);
INSERT INTO `visual_documents` VALUES (58, '2025-04-06 17:06:16.631', '2025-04-27 23:53:25.761', NULL, 0, '链表', '# 链表\n', 1, 1, 999994, 1);
INSERT INTO `visual_documents` VALUES (59, '2025-04-06 17:06:48.802', '2025-04-10 00:41:01.706', NULL, 58, '链表基础', '# 链表基础\n\n在C语言里，链表是一种常用的数据结构，由一系列节点构成，每个节点包含数据和指向下一个节点的指针。\n\n## 1. 链表节点的定义\n链表节点通常包含两部分：数据和指向下一个节点的指针。以下是定义链表节点的示例代码：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n```\n在这段代码中，借助`typedef`定义了一个名为`Node`的结构体，它包含一个整数`data`和一个指向下一个`Node`的指针`next`。\n\n## 2. 创建新节点\n创建新节点时，需要为节点分配内存并初始化其数据和指针。以下是创建新节点的示例代码：\n```c\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n```\n在这个函数里，使用`malloc`为新节点分配内存，接着初始化节点的数据和指针，最后返回新节点。\n\n## 3. 插入节点\n插入节点一般有在链表头部插入、在链表尾部插入和按位置插入三种方式。以下是相应的示例代码：\n\n### 3.1 在链表头部插入节点\n```c\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    newNode->next = head;\n    return newNode;\n}\n```\n此函数先创建一个新节点，然后让新节点的`next`指针指向原链表的头节点，最后返回新节点作为新的头节点。\n\n### 3.2 在链表尾部插入节点\n```c\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    return head;\n}\n```\n该函数先创建新节点，如果链表为空，新节点即为头节点；若链表不为空，遍历到链表尾部，将新节点接到尾节点之后，最后返回原头节点（若有）。\n\n### 3.3 按位置插入节点\n```c\n// 按位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"插入位置超出链表长度，插入失败\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    temp->next = newNode;\n    return head;\n}\n```\n此函数先判断插入位置是否为0，若是则调用在头部插入的函数。若不是，遍历到指定位置的前一个节点，将新节点插入到该位置，若位置超出链表长度则插入失败并释放新节点内存。\n\n## 4. 遍历链表\n遍历链表就是依次访问链表中的每个节点。以下是遍历链表的示例代码：\n```c\n// 遍历链表\nvoid traverseList(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n```\n在这个函数中，使用一个指针`current`来遍历链表，只要`current`不为`NULL`，就打印当前节点的数据并将`current`指向下一个节点。\n\n## 5. 删除节点\n删除节点时，通常要找到待删除节点的前一个节点，然后修改其`next`指针。以下是删除指定值节点和按位置删除节点的示例代码：\n\n### 5.1 删除指定值的节点\n```c\n// 删除指定值的节点\nNode* deleteNodeByValue(Node* head, int key) {\n    // 如果链表为空，直接返回\n    if (head == NULL) {\n        printf(\"链表为空，无法删除节点\\n\");\n        return head;\n    }\n\n    Node* temp = head;\n    Node* prev = NULL;\n\n    // 如果头节点就是要删除的节点\n    if (temp->data == key) {\n        head = temp->next;\n        free(temp);\n        return head;\n    }\n\n    // 查找要删除的节点\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    // 如果找到了要删除的节点\n    if (temp != NULL) {\n        prev->next = temp->next;\n        free(temp);\n    } else {\n        printf(\"未找到要删除的节点\\n\");\n    }\n\n    return head;\n}\n```\n这个函数会先检查头节点是否为要删除的节点，如果是就更新头节点并释放原头节点的内存。如果不是，就遍历链表找到要删除的节点，修改其前一个节点的`next`指针，最后释放该节点的内存。\n\n### 5.2 按位置删除节点\n```c\n// 按位置删除节点\nNode* deleteNodeByPosition(Node* head, int position) {\n    if (head == NULL) {\n        printf(\"链表为空，无法删除节点\\n\");\n        return head;\n    }\n    if (position == 0) {\n        Node* temp = head;\n        head = head->next;\n        free(temp);\n        return head;\n    }\n    Node* temp = head;\n    Node* prev = NULL;\n    int count = 0;\n    while (temp != NULL && count < position) {\n        prev = temp;\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"删除位置超出链表长度，删除失败\\n\");\n        return head;\n    }\n    prev->next = temp->next;\n    free(temp);\n    return head;\n}\n```\n该函数先判断链表是否为空，若头节点位置是要删除的位置则直接删除头节点。若不是，遍历到指定位置节点，修改其前一个节点的指针并释放该节点内存，若位置超出链表长度则删除失败。\n\n## 6. 示例代码\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    newNode->next = head;\n    return newNode;\n}\n\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    return head;\n}\n\n// 按位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"插入位置超出链表长度，插入失败\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    temp->next = newNode;\n    return head;\n}\n\n// 遍历链表\nvoid traverseList(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\n// 删除指定值的节点\nNode* deleteNodeByValue(Node* head, int key) {\n    // 如果链表为空，直接返回\n    if (head == NULL) {\n        printf(\"链表为空，无法删除节点\\n\");\n        return head;\n    }\n\n    Node* temp = head;\n    Node* prev = NULL;\n\n    // 如果头节点就是要删除的节点\n    if (temp->data == key) {\n        head = temp->next;\n        free(temp);\n        return head;\n    }\n\n    // 查找要删除的节点\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    // 如果找到了要删除的节点\n    if (temp != NULL) {\n        prev->next = temp->next;\n        free(temp);\n    } else {\n        printf(\"未找到要删除的节点\\n\");\n    }\n\n    return head;\n}\n\n// 按位置删除节点\nNode* deleteNodeByPosition(Node* head, int position) {\n    if (head == NULL) {\n        printf(\"链表为空，无法删除节点\\n\");\n        return head;\n    }\n    if (position == 0) {\n        Node* temp = head;\n        head = head->next;\n        free(temp);\n        return head;\n    }\n    Node* temp = head;\n    Node* prev = NULL;\n    int count = 0;\n    while (temp != NULL && count < position) {\n        prev = temp;\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"删除位置超出链表长度，删除失败\\n\");\n        return head;\n    }\n    prev->next = temp->next;\n    free(temp);\n    return head;\n}\n\nint main() {\n    Node* head = NULL;\n\n    // 插入节点\n    head = insertAtBeginning(head, 3);\n    head = insertAtEnd(head, 4);\n    head = insertAtPosition(head, 5, 1);\n\n    // 遍历链表\n    printf(\"插入节点后的链表元素: \");\n    traverseList(head);\n\n    // 删除指定值的节点\n    head = deleteNodeByValue(head, 5);\n    printf(\"删除值为 5 的节点后的链表元素: \");\n    traverseList(head);\n\n    // 按位置删除节点\n    head = deleteNodeByPosition(head, 0);\n    printf(\"删除位置为 0 的节点后的链表元素: \");\n    traverseList(head);\n\n    return 0;\n}\n```\n\n以上代码涵盖了链表的基本操作，包括节点的创建、不同方式的插入、不同方式的删除以及链表的遍历，希望对你理解链表这种数据结构有所帮助\n\n\n', 1, 1, 1000000, 1);
INSERT INTO `visual_documents` VALUES (60, '2025-04-06 23:17:25.585', '2025-07-06 00:53:39.448', NULL, 58, '双向链表', '# 双向链表\n双向链表是一种扩展的链表结构，在单链表的基础上，每个节点除了包含指向下一个节点的指针外，还包含指向前一个节点的指针。这使得双向链表在遍历和操作上更加灵活，不仅可以从前往后遍历，还能从后往前遍历。以下是关于双向链表的详细教程，包含节点定义、创建、插入、删除和遍历操作。\n\n### 1. 双向链表节点的定义\n双向链表的节点包含三部分：数据域、指向前一个节点的指针和指向下一个节点的指针。以下是定义双向链表节点的示例代码：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// 定义双向链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* prev;  // 指向前一个节点的指针\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n```\n在这段代码中，使用`typedef`定义了一个名为`Node`的结构体，它包含一个整数`data`、一个指向前一个`Node`的指针`prev`和一个指向下一个`Node`的指针`next`。\n\n### 2. 创建新节点\n创建新节点时，需要为节点分配内存并初始化其数据和指针。以下是创建新节点的示例代码：\n```c\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = NULL;\n    return newNode;\n}\n```\n在这个函数里，使用`malloc`为新节点分配内存，若分配失败则输出错误信息并退出程序。接着初始化节点的数据和指针，最后返回新节点。\n\n### 3. 插入节点\n插入节点有多种情况，这里介绍在链表头部插入、尾部插入和指定位置插入的操作。\n\n#### 在链表头部插入节点\n```c\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    newNode->next = head;\n    head->prev = newNode;\n    return newNode;\n}\n```\n此函数先创建一个新节点，若链表为空，则新节点就是链表的唯一节点；若链表不为空，让新节点的`next`指针指向原头节点，原头节点的`prev`指针指向新节点，最后返回新节点作为新的头节点。\n\n#### 在链表尾部插入节点\n```c\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n```\n该函数先创建新节点，若链表为空，新节点即为头节点；若链表不为空，遍历到链表尾部，让尾节点的`next`指针指向新节点，新节点的`prev`指针指向尾节点，最后返回原头节点。\n\n#### 在指定位置插入节点\n```c\n// 在指定位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"位置超出链表长度\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    if (temp->next != NULL) {\n        temp->next->prev = newNode;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n```\n此函数先判断插入位置是否为 0，若是则调用`insertAtBeginning`函数。若不是，遍历到指定位置的前一个节点，调整指针关系将新节点插入到该位置。\n\n### 4. 遍历链表\n遍历链表有从前往后和从后往前两种方式。\n\n#### 从前往后遍历链表\n```c\n// 从前往后遍历链表\nvoid traverseForward(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n```\n在这个函数中，使用一个指针`current`来遍历链表，只要`current`不为`NULL`，就打印当前节点的数据并将`current`指向下一个节点。\n\n#### 从后往前遍历链表\n```c\n// 从后往前遍历链表\nvoid traverseBackward(Node* head) {\n    if (head == NULL) return;\n    Node* current = head;\n    while (current->next != NULL) {\n        current = current->next;\n    }\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->prev;\n    }\n    printf(\"\\n\");\n}\n```\n该函数先遍历到链表尾部，然后从尾部开始往前遍历，依次打印节点的数据。\n\n### 5. 删除节点\n删除节点也有多种情况，这里介绍删除头节点、尾节点和指定值节点的操作。\n\n#### 删除头节点\n```c\n// 删除头节点\nNode* deleteAtBeginning(Node* head) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    head = head->next;\n    if (head != NULL) {\n        head->prev = NULL;\n    }\n    free(temp);\n    return head;\n}\n```\n此函数先判断链表是否为空，若不为空，保存原头节点，将头节点更新为原头节点的下一个节点，若新头节点存在则将其`prev`指针置为`NULL`，最后释放原头节点的内存。\n\n#### 删除尾节点\n```c\n// 删除尾节点\nNode* deleteAtEnd(Node* head) {\n    if (head == NULL) return NULL;\n    if (head->next == NULL) {\n        free(head);\n        return NULL;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->prev->next = NULL;\n    free(temp);\n    return head;\n}\n```\n该函数先判断链表是否为空或只有一个节点，若是则直接释放节点内存。若不是，遍历到链表尾部，调整尾节点前一个节点的`next`指针为`NULL`，释放尾节点的内存，最后返回原头节点。\n\n#### 删除指定值的节点\n```c\n// 删除指定值的节点\nNode* deleteNode(Node* head, int key) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    if (temp->data == key) {\n        return deleteAtBeginning(head);\n    }\n    while (temp != NULL && temp->data != key) {\n        temp = temp->next;\n    }\n    if (temp == NULL) {\n        printf(\"未找到该值的节点\\n\");\n        return head;\n    }\n    if (temp->next != NULL) {\n        temp->next->prev = temp->prev;\n    }\n    temp->prev->next = temp->next;\n    free(temp);\n    return head;\n}\n```\n这个函数先判断链表是否为空，若头节点的值就是要删除的值，则调用`deleteAtBeginning`函数。若不是，遍历链表找到要删除的节点，调整前后节点的指针关系，释放该节点的内存，最后返回原头节点。\n\n### 6. 示例代码\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// 定义双向链表节点结构\ntypedef struct Node {\n    int data;           // 数据域\n    struct Node* prev;  // 指向前一个节点的指针\n    struct Node* next;  // 指向下一个节点的指针\n} Node;\n\n// 创建新节点\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"内存分配失败\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 在链表头部插入节点\nNode* insertAtBeginning(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    newNode->next = head;\n    head->prev = newNode;\n    return newNode;\n}\n\n// 在链表尾部插入节点\nNode* insertAtEnd(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (head == NULL) {\n        return newNode;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n\n// 在指定位置插入节点\nNode* insertAtPosition(Node* head, int data, int position) {\n    if (position == 0) {\n        return insertAtBeginning(head, data);\n    }\n    Node* newNode = createNode(data);\n    Node* temp = head;\n    int count = 0;\n    while (temp != NULL && count < position - 1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        printf(\"位置超出链表长度\\n\");\n        free(newNode);\n        return head;\n    }\n    newNode->next = temp->next;\n    if (temp->next != NULL) {\n        temp->next->prev = newNode;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n\n// 从前往后遍历链表\nvoid traverseForward(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\n// 从后往前遍历链表\nvoid traverseBackward(Node* head) {\n    if (head == NULL) return;\n    Node* current = head;\n    while (current->next != NULL) {\n        current = current->next;\n    }\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->prev;\n    }\n    printf(\"\\n\");\n}\n\n// 删除头节点\nNode* deleteAtBeginning(Node* head) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    head = head->next;\n    if (head != NULL) {\n        head->prev = NULL;\n    }\n    free(temp);\n    return head;\n}\n\n// 删除尾节点\nNode* deleteAtEnd(Node* head) {\n    if (head == NULL) return NULL;\n    if (head->next == NULL) {\n        free(head);\n        return NULL;\n    }\n    Node* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->prev->next = NULL;\n    free(temp);\n    return head;\n}\n\n// 删除指定值的节点\nNode* deleteNode(Node* head, int key) {\n    if (head == NULL) return NULL;\n    Node* temp = head;\n    if (temp->data == key) {\n        return deleteAtBeginning(head);\n    }\n    while (temp != NULL && temp->data != key) {\n        temp = temp->next;\n    }\n    if (temp == NULL) {\n        printf(\"未找到该值的节点\\n\");\n        return head;\n    }\n    if (temp->next != NULL) {\n        temp->next->prev = temp->prev;\n    }\n    temp->prev->next = temp->next;\n    free(temp);\n    return head;\n}\n\nint main() {\n    Node* head = NULL;\n\n    // 插入节点\n    head = insertAtBeginning(head, 1);\n    head = insertAtEnd(head, 3);\n    head = insertAtPosition(head, 2, 1);\n\n    // 从前往后遍历链表\n    printf(\"从前往后遍历链表: \");\n    traverseForward(head);\n\n    // 从后往前遍历链表\n    printf(\"从后往前遍历链表: \");\n    traverseBackward(head);\n\n    // 删除节点\n    head = deleteNode(head, 2);\n\n    // 再次从前往后遍历链表\n    printf(\"删除节点 2 后从前往后遍历链表: \");\n    traverseForward(head);\n\n    return 0;\n}\n```', 1, 1, 999999, 1);
INSERT INTO `visual_documents` VALUES (61, '2025-04-06 23:21:13.949', '2025-04-27 23:53:25.879', NULL, 0, '递归', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, 999992, 1);
INSERT INTO `visual_documents` VALUES (62, '2025-04-06 23:30:13.205', '2025-08-24 17:52:32.583', NULL, 0, '数组(算法)', '# 数组', 1, 0, 999995, 1);
INSERT INTO `visual_documents` VALUES (63, '2025-04-06 23:30:44.919', '2025-04-10 01:34:12.216', '2025-04-26 20:57:19.542', 62, '数组基础', '# 数组\n\n## 1. 基本概念\n在 C 语言里，数组是一种用于存储相同类型元素的集合。这些元素在内存中是连续存放的，通过一个唯一的索引（下标）就能访问到数组中的每个元素。数组是一种简单且常用的数据结构，能帮助我们高效地管理和操作大量同类型的数据。\n\n## 2. 为何使用数组存储变量\n要是我们需要存储多个相同类型的数据，逐个声明变量会让代码变得冗长且难以维护。举个例子，要记录一个班级 50 个学生的成绩，若采用逐个声明变量的方式，就得写 50 个变量声明语句，像 `score1`、`score2` 一直到 `score50`。要是班级学生数量有变动，就得对代码进行修改。\n\n而数组就可以很好地解决这个问题。我们可以用一个数组来存储所有学生的成绩，通过索引就能方便地访问每个学生的成绩。这样一来，代码会更简洁，维护起来也更容易。\n\n## 3. 一维数组\n\n### 3.1 声明一维数组\n在使用数组之前，需要先声明它。声明数组时，要明确以下几个方面：\n- **数据类型**：表明数组要存储的数据类型，像 `int`（整数）、`float`（浮点数）、`char`（字符）等。\n- **数组名称**：用于标识数组的变量名，需遵循 C 语言标识符的命名规则。\n- **数组大小**：指定数组最多能存储的元素数量，它必须是一个常量表达式。\n\n示例：\n```c\n#include <stdio.h>\n\nint main() {\n    // 声明一个能存储 10 个整数的数组\n    int numbers[10];\n\n    // 声明一个能存储 20 个字符的数组\n    char letters[20];\n\n    return 0;\n}\n```\n\n### 3.2 为一维数组分配值\n\n#### 3.2.1 初始化时分配值\n在声明数组时就可以为其分配值。如果部分值没有明确给出，会被自动设为 0（对于数值类型）或者 `\'\\0\'`（对于字符类型）。\n\n示例：\n```c\n#include <stdio.h>\n\nint main() {\n    // 初始化一个包含 5 个整数的数组\n    int numbers[5] = {1, 2, 3, 4, 5};\n\n    // 部分初始化一个包含 10 个整数的数组，未初始化的元素会被设为 0\n    int scores[10] = {10, 20, 30};\n\n    return 0;\n}\n```\n\n#### 3.2.2 初始化后分配值\n要是在创建数组时没有对元素进行初始化，直接访问数组元素会得到一个随机值（垃圾值）。所以，若要对数组进行计算，建议先清空数组或者给它赋初始值。\n\n示例：\n```c\n#include <stdio.h>\n\nint main() {\n    int ages[10];\n\n    // 为数组元素赋值\n    for (int i = 0; i < 10; i++) {\n        ages[i] = i + 20;\n    }\n\n    // 打印数组元素\n    for (int i = 0; i < 10; i++) {\n        printf(\"ages[%d] = %d\\n\", i, ages[i]);\n    }\n\n    return 0;\n}\n```\n\n### 3.3 一维数组的遍历\n数组的索引通常是从 0 开始的，也就是数组的第一个元素索引为 0，最后一个元素的索引是 `数组大小 - 1`。借助 `for` 循环可以方便地遍历数组中的所有元素。\n\n示例：\n```c\n#include <stdio.h>\n\nint main() {\n    int numbers[5] = {1, 2, 3, 4, 5};\n\n    // 遍历数组并打印每个元素\n    for (int i = 0; i < 5; i++) {\n        printf(\"numbers[%d] = %d\\n\", i, numbers[i]);\n    }\n\n    return 0;\n}\n```\n\n### 3.4 一维数组的插入和删除操作\n\n#### 3.4.1 插入元素到一维数组\n- **插入到尾部**：当数组还有剩余空间时，在数组尾部插入元素很简单，只需找到数组最后一个元素的索引，然后将新元素放到索引 `数组大小` 的位置就行。\n- **插入到任意位置**：要在数组的任意位置插入元素，需要把该位置及之后的所有元素都向后移动一位，再将新元素插入到指定位置。\n\n示例：\n```c\n#include <stdio.h>\n\n#define MAX_SIZE 100\n\nvoid insertElement(int arr[], int *size, int pos, int value) {\n    if (*size >= MAX_SIZE) {\n        printf(\"数组已满，无法插入元素\\n\");\n        return;\n    }\n\n    if (pos < 0 || pos > *size) {\n        printf(\"插入位置不合法\\n\");\n        return;\n    }\n\n    // 将插入位置及之后的元素向后移动一位\n    for (int i = *size; i > pos; i--) {\n        arr[i] = arr[i - 1];\n    }\n\n    // 插入新元素\n    arr[pos] = value;\n    (*size)++;\n}\n\nint main() {\n    int arr[MAX_SIZE] = {1, 2, 3, 4, 5};\n    int size = 5;\n\n    // 在位置 2 插入元素 10\n    insertElement(arr, &size, 2, 10);\n\n    // 打印数组元素\n    for (int i = 0; i < size; i++) {\n        printf(\"arr[%d] = %d\\n\", i, arr[i]);\n    }\n\n    return 0;\n}\n```\n\n#### 3.4.2 从一维数组中删除元素\n- **删除尾部元素**：只要数组不为空，删除尾部元素很容易，直接把数组的大小减 1 就行。\n- **删除任意位置元素**：要删除数组中任意位置的元素，需要把该位置之后的所有元素都向前移动一位。\n\n示例：\n```c\n#include <stdio.h>\n\n#define MAX_SIZE 100\n\nvoid deleteElement(int arr[], int *size, int pos) {\n    if (*size <= 0) {\n        printf(\"数组为空，无法删除元素\\n\");\n        return;\n    }\n\n    if (pos < 0 || pos >= *size) {\n        printf(\"删除位置不合法\\n\");\n        return;\n    }\n\n    // 将删除位置之后的元素向前移动一位\n    for (int i = pos; i < *size - 1; i++) {\n        arr[i] = arr[i + 1];\n    }\n\n    (*size)--;\n}\n\nint main() {\n    int arr[MAX_SIZE] = {1, 2, 3, 4, 5};\n    int size = 5;\n\n    // 删除位置 2 的元素\n    deleteElement(arr, &size, 2);\n\n    // 打印数组元素\n    for (int i = 0; i < size; i++) {\n        printf(\"arr[%d] = %d\\n\", i, arr[i]);\n    }\n\n    return 0;\n}\n```\n\n## 4 二维数组\n二维数组可以看成是数组的数组，就像一个表格，有行和列。可以用两个索引来访问二维数组中的元素。\n\n### 4.1 声明二维数组\n声明二维数组的语法如下：\n```c\n数据类型 数组名[行数][列数];\n```\n\n示例：\n```c\n#include <stdio.h>\n\nint main() {\n    // 声明一个 3 行 4 列的二维整数数组\n    int matrix[3][4];\n\n    return 0;\n}\n```\n\n### 4.2 初始化二维数组\n二维数组也能在声明时进行初始化。\n\n示例：\n```c\n#include <stdio.h>\n\nint main() {\n    // 初始化一个 2 行 3 列的二维整数数组\n    int matrix[2][3] = {\n        {1, 2, 3},\n        {4, 5, 6}\n    };\n\n    return 0;\n}\n```\n\n### 4.3 访问二维数组元素\n通过行索引和列索引可以访问二维数组中的元素。\n\n示例：\n```c\n#include <stdio.h>\n\nint main() {\n    int matrix[2][3] = {\n        {1, 2, 3},\n        {4, 5, 6}\n    };\n\n    // 访问第 1 行第 2 列的元素\n    printf(\"matrix[0][1] = %d\\n\", matrix[0][1]);\n\n    return 0;\n}\n```\n\n### 4.4 遍历二维数组\n通常使用嵌套的 `for` 循环来遍历二维数组中的所有元素。\n\n示例：\n```c\n#include <stdio.h>\n\nint main() {\n    int matrix[2][3] = {\n        {1, 2, 3},\n        {4, 5, 6}\n    };\n\n    // 遍历二维数组并打印每个元素\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"matrix[%d][%d] = %d\\n\", i, j, matrix[i][j]);\n        }\n    }\n\n    return 0;\n}\n``` ', 1, 1, 1000000, 1);
INSERT INTO `visual_documents` VALUES (64, '2025-04-06 23:35:06.463', '2025-04-06 23:35:10.238', NULL, 58, '反转链表', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, 999998, 1);
INSERT INTO `visual_documents` VALUES (65, '2025-04-06 23:46:47.757', '2025-04-10 01:28:38.359', NULL, 62, '顺序表', '# 顺序表\n\n## 1. 基本概念\n顺序表是一种线性表，它采用一组连续的存储单元依次存储线性表中的数据元素。在 C 语言中，通常使用数组来实现顺序表。顺序表的特点是逻辑上相邻的元素在物理存储位置上也相邻，因此可以通过数组的下标直接访问表中的任意元素，具有随机访问的特性。\n\n## 2. 顺序表的结构体定义\n首先，我们需要定义一个结构体来表示顺序表，该结构体应包含两个主要部分：一个数组用于存储数据元素，以及一个变量用于记录当前顺序表中元素的数量。\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100  // 定义顺序表的最大容量\n\n// 定义顺序表的结构体\ntypedef struct {\n    int data[MAX_SIZE];  // 存储数据元素的数组\n    int length;          // 当前顺序表中元素的数量\n} SeqList;\n```\n\n## 3. 初始化\n在使用顺序表之前，需要对其进行初始化，将顺序表的长度初始化为 0。\n```c\n// 初始化顺序表\nvoid initList(SeqList *list) {\n    list->length = 0;\n}\n```\n\n## 4. 插入元素\n插入元素是顺序表的常见操作之一。插入操作可以在顺序表的任意位置进行，但需要考虑插入位置的合法性以及顺序表是否已满。\n```c\n// 在指定位置插入元素\nint insertElement(SeqList *list, int position, int element) {\n    // 检查插入位置是否合法\n    if (position < 1 || position > list->length + 1) {\n        printf(\"插入位置不合法\\n\");\n        return 0;\n    }\n    // 检查顺序表是否已满\n    if (list->length >= MAX_SIZE) {\n        printf(\"顺序表已满，无法插入\\n\");\n        return 0;\n    }\n    // 将插入位置及之后的元素后移\n    for (int i = list->length; i >= position; i--) {\n        list->data[i] = list->data[i - 1];\n    }\n    // 插入新元素\n    list->data[position - 1] = element;\n    // 顺序表长度加 1\n    list->length++;\n    return 1;\n}\n```\n\n## 5. 删除元素\n删除元素也是顺序表的常见操作之一。删除操作需要指定要删除元素的位置，并将该位置之后的元素前移。\n```c\n// 删除指定位置的元素\nint deleteElement(SeqList *list, int position) {\n    // 检查删除位置是否合法\n    if (position < 1 || position > list->length) {\n        printf(\"删除位置不合法\\n\");\n        return 0;\n    }\n    // 将删除位置之后的元素前移\n    for (int i = position; i < list->length; i++) {\n        list->data[i - 1] = list->data[i];\n    }\n    // 顺序表长度减 1\n    list->length--;\n    return 1;\n}\n```\n\n## 6. 查找元素\n查找元素可以根据元素的值或位置进行。这里我们实现根据元素的值进行查找。\n```c\n// 查找元素的位置\nint findElement(SeqList *list, int element) {\n    for (int i = 0; i < list->length; i++) {\n        if (list->data[i] == element) {\n            return i + 1;  // 返回元素的位置（从 1 开始）\n        }\n    }\n    return 0;  // 未找到元素\n}\n```\n\n## 7. 遍历顺序表\n遍历顺序表是指依次访问顺序表中的每个元素，并进行相应的操作。这里我们简单地将元素打印出来。\n```c\n// 遍历顺序表\nvoid traverseList(SeqList *list) {\n    for (int i = 0; i < list->length; i++) {\n        printf(\"%d \", list->data[i]);\n    }\n    printf(\"\\n\");\n}\n```\n\n## 8. 代码示例\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100  // 定义顺序表的最大容量\n\n// 定义顺序表的结构体\ntypedef struct {\n    int data[MAX_SIZE];  // 存储数据元素的数组\n    int length;          // 当前顺序表中元素的数量\n} SeqList;\n\n// 初始化顺序表\nvoid initList(SeqList *list) {\n    list->length = 0;\n}\n\n// 在指定位置插入元素\nint insertElement(SeqList *list, int position, int element) {\n    // 检查插入位置是否合法\n    if (position < 1 || position > list->length + 1) {\n        printf(\"插入位置不合法\\n\");\n        return 0;\n    }\n    // 检查顺序表是否已满\n    if (list->length >= MAX_SIZE) {\n        printf(\"顺序表已满，无法插入\\n\");\n        return 0;\n    }\n    // 将插入位置及之后的元素后移\n    for (int i = list->length; i >= position; i--) {\n        list->data[i] = list->data[i - 1];\n    }\n    // 插入新元素\n    list->data[position - 1] = element;\n    // 顺序表长度加 1\n    list->length++;\n    return 1;\n}\n\n// 删除指定位置的元素\nint deleteElement(SeqList *list, int position) {\n    // 检查删除位置是否合法\n    if (position < 1 || position > list->length) {\n        printf(\"删除位置不合法\\n\");\n        return 0;\n    }\n    // 将删除位置之后的元素前移\n    for (int i = position; i < list->length; i++) {\n        list->data[i - 1] = list->data[i];\n    }\n    // 顺序表长度减 1\n    list->length--;\n    return 1;\n}\n\n// 查找元素的位置\nint findElement(SeqList *list, int element) {\n    for (int i = 0; i < list->length; i++) {\n        if (list->data[i] == element) {\n            return i + 1;  // 返回元素的位置（从 1 开始）\n        }\n    }\n    return 0;  // 未找到元素\n}\n\n// 遍历顺序表\nvoid traverseList(SeqList *list) {\n    for (int i = 0; i < list->length; i++) {\n        printf(\"%d \", list->data[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    SeqList list;\n    initList(&list);\n\n    // 插入元素\n    insertElement(&list, 1, 10);\n    insertElement(&list, 2, 20);\n    insertElement(&list, 3, 30);\n\n    // 遍历顺序表\n    printf(\"插入元素后的顺序表: \");\n    traverseList(&list);\n\n    // 删除元素\n    deleteElement(&list, 2);\n\n    // 遍历顺序表\n    printf(\"删除元素后的顺序表: \");\n    traverseList(&list);\n\n    // 查找元素\n    int position = findElement(&list, 30);\n    if (position != 0) {\n        printf(\"元素 30 的位置是: %d\\n\", position);\n    } else {\n        printf(\"未找到元素 30\\n\");\n    }\n\n    return 0;\n}\n```', 1, 1, 999999, 1);
INSERT INTO `visual_documents` VALUES (66, '2025-04-11 00:24:47.243', '2025-05-14 01:24:14.514', NULL, 0, '反转链表', '# 反转链表\n\n## 题目\n[LCR 024. 反转链表](https://leetcode.cn/problems/UHnkqh/description/)\n\n给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。\n\n&nbsp;\n\n**示例 1：**\n<img src=\"https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/b3ebf714-1628-11f0-a4ce-00163e06661f.rev1ex1.jpg\" width=\"300\" alt=\"示例 1 图片\">\n> 输入：head = [1,2,3,4,5]\n  输出：[5,4,3,2,1]\n\n&nbsp;\n\n**示例 2：**\n<img src=\"https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/cd8d42b1-1628-11f0-a4ce-00163e06661f.rev1ex2.jpg\" width=\"100\" alt=\"示例 2 图片\">\n> 输入：head = [1,2]\n输出：[2,1]\n\n\n## 解题思路\n\n### 头插法\n\n- 设置两个指针：`newHead = None`作为反转后链表的初始头节点，`current = head`指向当前正在处理的节点。\n - 不断将`current`指向的节点通过头插法插入`newHead`为头节点的链表就能够实现反转链表\n\n#### 代码实现\n\n**Go语言**\n\n```go\npackage main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseList 反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    var newHead *ListNode\n    curr := head\n    for curr != nil {\n        nextNode := curr.Next\n        curr.Next = newHead\n        newHead = curr\n        curr = nextNode\n    }\n    return newHead\n}\n```\n**C语言**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode *next;\n} ListNode;\n\n// 反转链表\nListNode* reverseList(ListNode* head) {\n    ListNode *newHead = NULL;\n    ListNode *curr = head;\n    ListNode *nextNode;\n    while (curr != NULL) {\n        nextNode = curr->next;\n        curr->next = newHead;\n        newHead = curr;\n        curr = nextNode;\n    }\n    return newHead;\n}\n```\n\n#### 复杂度分析\n**时间复杂度**：迭代法反转链表需遍历链表一次，每个节点处理时间为常数，时间复杂度是`O(n)`\n**空间复杂度**：算法只用到几个固定的额外指针变量，不随链表长度增加而增多，所以空间复杂度是`O(1)`\n\n&nbsp;\n\n### 递归法\n递归法的思路也非常简单，比如我需要反转`n1 -> n2 -> n3 -> n4`。可以拆分为：\n1. 将`n2 -> n3 -> n4` 进行反转\n2. 将`n1`插入反转以后的`n4 -> n3 -> n2`尾部\n\n#### 代码实现\n\n**Go语言**\n```go\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseList 递归反转链表\nfunc reverseList(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    newHead := reverseList(head.Next)\n    head.Next.Next = head\n    head.Next = nil\n    return newHead\n}\n\n```\n**C语言**\n```c\n// 定义链表节点结构\nstruct ListNode {\n    int val;\n    struct ListNode *next;\n};\n\n// 递归反转链表\nstruct ListNode* reverseList(struct ListNode* head) {\n    if (head == NULL || head->next == NULL) {\n        return head;\n    }\n    struct ListNode* newHead = reverseList(head->next);\n    head->next->next = head;\n    head->next = NULL;\n    return newHead;\n}\n```\n#### 复杂度分析\n**时间复杂度**：递归法反转链表时，每个节点都要处理一次，每次处理操作时间是固定的。所以时间复杂度为 \n`O(n)`\n**空间复杂度**：递归调用会使用系统栈保存每一层的信息，递归深度最大为链表长度`n`\n，所以空间复杂度是`O(n)`', 1, 1, 999999, 4);
INSERT INTO `visual_documents` VALUES (67, '2025-04-20 22:24:28.161', '2025-05-14 01:21:34.818', NULL, 0, '反转链表 II', '# 反转链表 II\n[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/description/)\n\n# 题目\n给你单链表的头指针`head`和两个整数`left`和`right`，其中`left <= right`。请你反转从位置`left`到位置`right`的链表节点，返回 反转后的链表 。\n\n\n**示例 1：**\n![Description](https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/5be7347d-2069-11f0-901a-00163e06661f.image.png)\n\n> 输入：head = [1,2,3,4,5], left = 2, right = 4\n输出：[1,4,3,2,5]\n\n**示例 2：**\n\n\n> 输入：head = [5], left = 1, right = 1\n输出：[5]\n \n\n**提示：**\n\n- 链表中节点数目为 n\n- `1 <= n <= 500`\n- `500 <= Node.val <= 500`\n- `1 <= left <= right <= n`\n \n&nbsp;\n\n### 实现思路\n1. **找到第 `left - 1` 个节点**：这是反转部分的前一个节点，将其保存下来，后续需要重新连接反转后的部分。\n2. **反转从第 `left` 到第 `right` 个节点**：使用迭代的方法来反转这部分链表。\n3. **重新连接链表**：把反转后的部分与原链表剩余部分连接起来。\n\n### Go 语言实现\n\n```go\npackage main\n\nimport \"fmt\"\n\n// ListNode 定义链表节点结构\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// reverseBetween 反转从第 left 到第 right 个节点的部分\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummy := &ListNode{Next: head}\n    pre := dummy\n    // 找到第 left - 1 个节点\n    for i := 0; i < left-1; i++ {\n        pre = pre.Next\n    }\n    cur := pre.Next\n    for i := 0; i < right-left; i++ {\n        next := cur.Next\n        cur.Next = next.Next\n        next.Next = pre.Next\n        pre.Next = next\n    }\n    return dummy.Next\n}\n\n// 辅助函数：打印链表\nfunc printList(head *ListNode) {\n    for head != nil {\n        fmt.Print(head.Val, \" \")\n        head = head.Next\n    }\n    fmt.Println()\n}\n\nfunc main() {\n    // 创建链表 1 -> 2 -> 3 -> 4 -> 5\n    head := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5}}}}}\n    fmt.Println(\"Original list:\")\n    printList(head)\n    // 反转从第 2 到第 4 个节点的部分\n    newHead := reverseBetween(head, 2, 4)\n    fmt.Println(\"Reversed list:\")\n    printList(newHead)\n}\n\n\n```\n#### 代码解释\n1. **定义链表节点结构**：`ListNode` 结构体包含一个整数值 `Val` 和一个指向下一个节点的指针 `Next`。\n2. **创建虚拟头节点**：`dummy` 节点用于简化边界情况的处理。\n3. **找到第 `left - 1` 个节点**：通过循环遍历链表，将 `pre` 指针移动到第 `left - 1` 个节点。\n4. **反转链表**：使用迭代的方法反转从第 `left` 到第 `right` 个节点的部分。\n5. **打印链表**：`printList` 函数用于打印链表中的所有节点值。\n\n### C 语言实现\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// 定义链表节点结构\ntypedef struct ListNode {\n    int val;\n    struct ListNode* next;\n} ListNode;\n\n// 创建新节点\nListNode* createNode(int val) {\n    ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));\n    newNode->val = val;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 反转从第 left 到第 right 个节点的部分\nListNode* reverseBetween(ListNode* head, int left, int right) {\n    ListNode dummy;\n    dummy.next = head;\n    ListNode* pre = &dummy;\n    // 找到第 left - 1 个节点\n    for (int i = 0; i < left - 1; i++) {\n        pre = pre->next;\n    }\n    ListNode* cur = pre->next;\n    for (int i = 0; i < right - left; i++) {\n        ListNode* next = cur->next;\n        cur->next = next->next;\n        next->next = pre->next;\n        pre->next = next;\n    }\n    return dummy.next;\n}\n\n// 辅助函数：打印链表\nvoid printList(ListNode* head) {\n    while (head != NULL) {\n        printf(\"%d \", head->val);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    // 创建链表 1 -> 2 -> 3 -> 4 -> 5\n    ListNode* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n\n    printf(\"Original list:\\n\");\n    printList(head);\n\n    // 反转从第 2 到第 4 个节点的部分\n    ListNode* newHead = reverseBetween(head, 2, 4);\n\n    printf(\"Reversed list:\\n\");\n    printList(newHead);\n\n    return 0;\n}\n\n\n```\n#### 代码解释\n1. **定义链表节点结构**：`ListNode` 结构体包含一个整数值 `val` 和一个指向下一个节点的指针 `next`。\n2. **创建新节点**：`createNode` 函数用于创建一个新的链表节点。\n3. **创建虚拟头节点**：`dummy` 节点用于简化边界情况的处理。\n4. **找到第 `left - 1` 个节点**：通过循环遍历链表，将 `pre` 指针移动到第 `left - 1` 个节点。\n5. **反转链表**：使用迭代的方法反转从第 `left` 到第 `right` 个节点的部分。\n6. **打印链表**：`printList` 函数用于打印链表中的所有节点值。\n\n### 复杂度分析\n- **时间复杂度**：$O(n)$，其中 $n$ 是链表的长度。\n- **空间复杂度**：$O(1)$，只使用了常数级的额外空间。\n\n通过上述代码和解释，你应该能够理解如何使用 Go 语言和 C 语言来反转链表中指定范围的节点。 ', 1, 0, 999997, 4);
INSERT INTO `visual_documents` VALUES (68, '2025-04-26 18:14:30.267', '2025-08-16 22:14:57.065', NULL, 52, '基本结构', '# 基本结构\n\n## 示例代码\n下面是一个简单的 C 语言程序。\n\n```c\n#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n```\n\n## 代码解释\n\n### 1. 预处理指令\n```c\n#include <stdio.h>\n```\n这行代码属于预处理指令。在 C 语言里，以 `#` 开头的语句就是预处理指令。`#include` 指令的功能是把指定的头文件包含到当前代码里。`stdio.h` 是标准输入输出库的头文件，里面有像 `printf` 这类输入输出函数的声明。要是没有包含这个头文件，编译器就无法识别`printf` 函数，编译时就会报错\n\n### 2. `main` 函数\n```c\nint main() {\n    // 函数体\n}\n```\n`main` 函数是 C 语言程序的起始点，程序就是从这里开始执行的。`int` 表明 `main` 函数的返回值类型是整数。在 C 语言里，`main` 函数结束时要返回一个整数值给操作系统，一般返回 0 代表程序正常结束\n\n### 3. 函数体中的语句\n```c\nprintf(\"Hello, World!\\n\");\n```\n`printf` 是标准输入输出库中的函数，它的作用是把格式化的字符串输出到屏幕上。在这个例子中，它会把 `\"Hello, World!\"` 字符串输出，`\\n` 是换行符，输出后光标会移到下一行\n\n```c\nreturn 0;\n```\n这行代码的作用是返回整数 0 给操作系统，以此表示程序正常结束。要是程序在执行过程中出现了问题，就可以返回其他非零值来表明不同的错误情况\n\n## 编译和运行\n要让这个 C 语言程序运行起来，可按以下步骤操作：\n\n### 1. 编写代码\n用文本编辑器把上面的代码写好，然后保存成一个 `.c` 文件，比如 `hello.c`\n\n### 2. 编译代码\n使用 C 编译器（例如 `gcc`）对代码进行编译。在命令行输入以下命令：\n```sh\ngcc hello.c -o hello\n```\n这样就会生成一个名为 `hello` 的可执行文件\n\n### 3. 运行程序\n在命令行输入下面的命令来运行程序：\n```sh\n./hello\n```\n运行之后，屏幕上就会显示 `Hello, World!`', 1, 1, 1000000, 1);
INSERT INTO `visual_documents` VALUES (69, '2025-04-26 18:22:58.925', '2025-04-26 20:48:49.995', NULL, 52, '数据类型', '# 数据类型\n\n## 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    // 整数类型\n    int integer_num = 10;\n    short short_num = 20;\n    long long_num = 30;\n    long long long_long_num = 40LL;\n    unsigned int unsigned_num = 100;\n\n    // 浮点类型\n    float float_num = 3.14f;\n    double double_num = 3.14159;\n    long double long_double_num = 3.1415926L;\n\n    // 字符类型\n    char char_letter = \'A\';\n    signed char signed_char_letter = \'B\';\n    unsigned char unsigned_char_letter = \'C\';\n\n    // 布尔类型（C99 引入）\n    _Bool bool_value = 1;\n\n    // 输出整数类型的值\n    printf(\"整数类型的值: %d\\n\", integer_num);\n    printf(\"短整数类型的值: %hd\\n\", short_num);\n    printf(\"长整数类型的值: %ld\\n\", long_num);\n    printf(\"长长整数类型的值: %lld\\n\", long_long_num);\n    printf(\"无符号整数类型的值: %u\\n\", unsigned_num);\n\n    // 输出浮点类型的值\n    printf(\"单精度浮点类型的值: %f\\n\", float_num);\n    printf(\"双精度浮点类型的值: %lf\\n\", double_num);\n    printf(\"长双精度浮点类型的值: %Lf\\n\", long_double_num);\n\n    // 输出字符类型的值\n    printf(\"字符类型的值: %c\\n\", char_letter);\n    printf(\"有符号字符类型的值: %c\\n\", signed_char_letter);\n    printf(\"无符号字符类型的值: %c\\n\", unsigned_char_letter);\n\n    // 输出布尔类型的值\n    printf(\"布尔类型的值: %d\\n\", bool_value);\n\n    return 0;\n}\n```\n\n## 代码解释\n\n### （一）整数类型\n整数类型用于存储整数，不同的整数类型在内存中占用的字节数不同，所能表示的数值范围也不同\n\n1. **`int`**\n    - 这是最常用的整数类型，通常在 32 位系统上占用 4 个字节，在 16 位系统上占用 2 个字节。\n    - 可以表示正整数、负整数和零。例如 `int integer_num = 10;` 定义了一个 `int` 类型的变量 `integer_num` 并初始化为 10。在 `printf` 函数中使用 `%d` 来格式化输出 `int` 类型的值\n\n2. **`short`**\n    - 短整数类型，通常占用 2 个字节，能表示的数值范围比 `int` 小\n    - 如 `short short_num = 20;` ，使用 `%hd` 作为 `printf` 中的格式化占位符\n\n3. **`long`**\n    - 长整数类型，在 32 位系统上通常占用 4 个字节，在 64 位系统上通常占用 8 个字节，能表示更大范围的整数\n    - 例如 `long long_num = 30;` ，用 `%ld` 进行输出\n\n4. **`long long`**\n    - 长长整数类型，至少占用 8 个字节，能表示非常大的整数\n    - 定义时可以在常量后面加 `LL` 来明确是 `long long` 类型，如 `long long long_long_num = 40LL;` ，使用 `%lld` 输出\n\n5. **`unsigned int`**\n    - 无符号整数类型，只能表示非负整数，其表示的正数范围是有符号 `int` 的两倍\n    - 像 `unsigned int unsigned_num = 100;` ，用 `%u` 进行输出\n\n### （二）浮点类型\n浮点类型用于存储带有小数部分的数值。\n\n1. **`float`**\n    - 单精度浮点类型，通常占用 4 个字节，能提供大约 6 - 7 位的有效数字\n    - 定义时在常量后面加 `f` 来明确是 `float` 类型，如 `float float_num = 3.14f;` ，使用 `%f` 输出\n\n2. **`double`**\n    - 双精度浮点类型，通常占用 8 个字节，能提供大约 15 - 16 位的有效数字，精度比 `float` 高\n    - 例如 `double double_num = 3.14159;` ，用 `%lf` 输出\n\n3. **`long double`**\n    - 长双精度浮点类型，占用的字节数和精度因编译器和系统而异，通常比 `double` 更高\n    - 定义时在常量后面加 `L` ，如 `long double long_double_num = 3.1415926L;` ，使用 `%Lf` 输出\n\n### （三）字符类型\n字符类型用于存储单个字符，本质上存储的是字符对应的 ASCII 码值\n\n1. **`char`**\n    - 可以是有符号的也可以是无符号的，具体取决于编译器\n    - 例如 `char char_letter = \'A\';` ，使用 `%c` 输出字符本身\n\n2. **`signed char`**\n    - 明确表示有符号的字符类型，能表示的范围是 -128 到 127\n\n3. **`unsigned char`**\n    - 明确表示无符号的字符类型，能表示的范围是 0 到 255\n\n### （四）布尔类型\n在 C99 标准中引入了布尔类型 `_Bool` ，它只能存储 0 或 1，分别表示假和真\n例如 `_Bool bool_value = 1;` ，使用 `%d` 输出其值\n\n## 编程题\n\n### 1. 数据范围测试\n编写一个程序，分别定义不同整数类型（`int`、`short`、`long`、`long long`、`unsigned int`）的变量，将它们初始化为各自能表示的最大值和最小值，然后输出这些值，观察不同整数类型的取值范围\n\n### 2. 浮点精度测试\n编写一个程序，定义 `float` 和 `double` 类型的变量，分别对它们进行一些简单的数学运算（如加法、乘法），并输出运算结果，观察 `float` 和 `double` 在精度上的差异\n\n### 3. 字符与 ASCII 码转换\n编写一个程序，让用户输入一个字符，然后输出该字符对应的 ASCII 码值；再让用户输入一个 ASCII 码值，输出对应的字符', 1, 1, 999999, 1);
INSERT INTO `visual_documents` VALUES (70, '2025-04-26 18:36:25.472', '2025-04-26 20:33:00.896', NULL, 52, '运算符', '# 运算符\n\n## 算术运算符\n\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 10;\n    int b = 3;\n\n    int sum = a + b;\n    int difference = a - b;\n    int product = a * b;\n    int quotient = a / b;\n    int remainder = a % b;\n\n    printf(\"加法结果: %d\\n\", sum);\n    printf(\"减法结果: %d\\n\", difference);\n    printf(\"乘法结果: %d\\n\", product);\n    printf(\"除法结果: %d\\n\", quotient);\n    printf(\"取模结果: %d\\n\", remainder);\n\n    return 0;\n}\n```\n\n### 代码解释\n- **加法运算符（`+`）**：用于计算两个数的和。在代码里，`a + b` 算出 `a` 和 `b` 的总和，结果存于 `sum` 变量\n- **减法运算符（`-`）**：用来计算两个数的差。`a - b` 计算出 `a` 与 `b` 的差值，结果存于 `difference` 变量\n- **乘法运算符（`*`）**：用于计算两个数的乘积。`a * b` 算出 `a` 和 `b` 的积，结果存于 `product` 变量\n- **除法运算符（`/`）**：计算两个数的商。当两个操作数都是整数时，结果会截断小数部分，只保留整数部分。`a / b` 得出 `a` 除以 `b` 的商，结果存于 `quotient` 变量\n- **取模运算符（`%`）**：计算两个数相除后的余数。`a % b` 算出 `a` 除以 `b` 的余数，结果存于 `remainder` 变量\n\n### 编程题\n编写一个程序，要求用户输入两个整数，之后计算这两个数的和、差、积、商（商保留整数部分）以及余数，并且输出这些结果\n\n## 关系运算符\n\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 10;\n    int b = 3;\n\n    int greater = a > b;\n    int less = a < b;\n    int equal = a == b;\n    int not_equal = a != b;\n    int greater_equal = a >= b;\n    int less_equal = a <= b;\n\n    printf(\"a > b 的结果: %d\\n\", greater);\n    printf(\"a < b 的结果: %d\\n\", less);\n    printf(\"a == b 的结果: %d\\n\", equal);\n    printf(\"a != b 的结果: %d\\n\", not_equal);\n    printf(\"a >= b 的结果: %d\\n\", greater_equal);\n    printf(\"a <= b 的结果: %d\\n\", less_equal);\n\n    return 0;\n}\n```\n\n### 代码解释\n- **大于运算符（`>`）**：判断左边的值是否大于右边的值。若条件成立，结果为 1（真）；反之则为 0（假）。在代码中，`a > b` 的结果存于 `greater` 变量\n- **小于运算符（`<`）**：判断左边的值是否小于右边的值。结果同样是 1 或 0。`a < b` 的结果存于 `less` 变量\n- **等于运算符（`==`）**：判断两个值是否相等。`a == b` 的结果存于 `equal` 变量\n- **不等于运算符（`!=`）**：判断两个值是否不相等。`a != b` 的结果存于 `not_equal` 变量\n- **大于等于运算符（`>=`）**：判断左边的值是否大于或等于右边的值。`a >= b` 的结果存于 `greater_equal` 变量\n- **小于等于运算符（`<=`）**：判断左边的值是否小于或等于右边的值。`a <= b` 的结果存于 `less_equal` 变量\n\n### 编程题\n编写一个程序，让用户输入两个整数，判断第一个数是否大于第二个数，若成立则输出 `Yes`，否则输出 `No`\n\n## 逻辑运算符\n\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    int x = 1;\n    int y = 0;\n\n    int logical_and = x && y;\n    int logical_or = x || y;\n    int logical_not_x = !x;\n    int logical_not_y = !y;\n\n    printf(\"逻辑与结果: %d\\n\", logical_and);\n    printf(\"逻辑或结果: %d\\n\", logical_or);\n    printf(\"x 的逻辑非结果: %d\\n\", logical_not_x);\n    printf(\"y 的逻辑非结果: %d\\n\", logical_not_y);\n\n    return 0;\n}\n```\n\n### 代码解释\n- **逻辑与运算符（`&&`）**：只有当两个操作数都为真（非 0）时，结果才为真（1）；只要有一个操作数为假（0），结果就为假（0）。`x && y` 的结果存于 `logical_and` 变量\n- **逻辑或运算符（`||`）**：只要两个操作数中有一个为真，结果就为真；只有当两个操作数都为假时，结果才为假。`x || y` 的结果存于 `logical_or` 变量\n- **逻辑非运算符（`!`）**：对操作数取反。若操作数为真，结果为假；若操作数为假，结果为真。`!x` 和 `!y` 的结果分别存于 `logical_not_x` 和 `logical_not_y` 变量\n\n### 编程题\n编写一个程序，让用户输入两个整数，判断第一个数是否大于 10 并且第二个数是否小于 20，根据判断结果输出 `True` 或者 `False`\n\n## 赋值运算符\n\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 5;\n\n    num += 3;\n    num -= 2;\n    num *= 4;\n    num /= 2;\n    num %= 3;\n\n    printf(\"最终结果: %d\\n\", num);\n\n    return 0;\n}\n```\n\n### 代码解释\n- **基本赋值运算符（`=`）**：把右边的值赋给左边的变量。如 `num = 5` 把 5 赋值给 `num` 变量\n- **复合赋值运算符**：\n    - `+=`：`num += 3` 等同于 `num = num + 3`，将 `num` 的值加上 3 后再赋给 `num`\n    - `-=`：`num -= 2` 等同于 `num = num - 2`，将 `num` 的值减去 2 后再赋给 `num`\n    - `*=`：`num *= 4` 等同于 `num = num * 4`，将 `num` 的值乘以 4 后再赋给 `num`\n    - `/=`：`num /= 2` 等同于 `num = num / 2`，将 `num` 的值除以 2 后再赋给 `num`\n    - `%=`：`num %= 3` 等同于 `num = num % 3`，将 `num` 除以 3 的余数赋给 `num`\n\n### 编程题\n编写一个程序，定义一个整数变量并初始化为 10，然后使用复合赋值运算符将该变量依次加上 5、减去 3、乘以 2、除以 4，最后输出结果\n\n## 位运算符\n\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    int m = 5; // 二进制: 0101\n    int n = 3; // 二进制: 0011\n\n    int bitwise_and = m & n;\n    int bitwise_or = m | n;\n    int bitwise_xor = m ^ n;\n    int bitwise_not_m = ~m;\n    int left_shift = m << 1;\n    int right_shift = m >> 1;\n\n    printf(\"按位与结果: %d\\n\", bitwise_and);\n    printf(\"按位或结果: %d\\n\", bitwise_or);\n    printf(\"按位异或结果: %d\\n\", bitwise_xor);\n    printf(\"按位取反结果: %d\\n\", bitwise_not_m);\n    printf(\"左移结果: %d\\n\", left_shift);\n    printf(\"右移结果: %d\\n\", right_shift);\n\n    return 0;\n}\n```\n\n### 代码解释\n- **按位与运算符（`&`）**：对两个操作数的对应二进制位进行与运算，只有当对应位都为 1 时，结果位才为 1。`m & n` 的结果存于 `bitwise_and` 变量\n- **按位或运算符（`|`）**：对应位只要有一个为 1，结果位就为 1。`m | n` 的结果存于 `bitwise_or` 变量\n- **按位异或运算符（`^`）**：对应位不同时结果位为 1，相同时为 0。`m ^ n` 的结果存于 `bitwise_xor` 变量。\n- **按位取反运算符（`~`）**：将操作数的每一位取反。`~m` 的结果存于 `bitwise_not_m` 变量\n- **左移运算符（`<<`）**：将操作数的二进制位向左移动指定的位数，右边空出的位用 0 填充。`m << 1` 的结果存于 `left_shift` 变量\n- **右移运算符（`>>`）**：将操作数的二进制位向右移动指定的位数，左边空出的位根据符号位填充。`m >> 1` 的结果存于 `right_shift` 变量\n\n### 编程题\n编写一个程序，定义一个整数变量，使用位运算符将其第 2 位（从右往左数，最低位为第 0 位）置为 0，然后输出结果', 1, 1, 999998, 1);
INSERT INTO `visual_documents` VALUES (71, '2025-04-26 18:39:18.991', '2025-08-24 18:25:04.141', NULL, 52, '条件语句', '# 条件语句教程\n\n## `if`语句\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 12;\n    if (num > 10) {\n        printf(\"num大于10\\n\");\n    }\n    return 0;\n}\n```\n\n### 代码解释\n`if`语句通过判断`if`后的条件表达式真假决定是否执行大括号内代码。如`if (num > 10)`判断`num`是否大于10，为真则输出`num大于10`，为假则跳过该代码块\n\n### 编程题\n编写程序，输入一个字符，判断是否为大写字母，若是则输出“这是大写字母”\n\n## `if - else`语句\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 7;\n    if (num % 2 == 0) {\n        printf(\"num是偶数\\n\");\n    } else {\n        printf(\"num是奇数\\n\");\n    }\n    return 0;\n}\n```\n\n### 代码解释\n`if - else`语句针对条件真假分别执行不同代码。`if (num % 2 == 0)`判断`num`是否为偶数，真则执行`if`代码块，假则执行`else`代码块\n\n### 编程题\n编写程序，输入一个整数，判断其能否被3整除，能则输出“能被3整除”，否则输出“不能被3整除”\n\n## `if - else if - else`语句\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    int score = 78;\n    if (score >= 90) {\n        printf(\"成绩等级为A\\n\");\n    } else if (score >= 80) {\n        printf(\"成绩等级为B\\n\");\n    } else if (score >= 70) {\n        printf(\"成绩等级为C\\n\");\n    } else if (score >= 60) {\n        printf(\"成绩等级为D\\n\");\n    } else {\n        printf(\"成绩等级为F\\n\");\n    }\n    return 0;\n}\n```\n\n### 代码解释\n`if - else if - else`用于多条件分支。程序按顺序判断`if`和`else if`条件，满足第一个为真的条件即执行对应代码块并跳过后续分支，都不满足则执行`else`代码块\n\n### 编程题\n编写程序，输入一个年份，判断是否为闰年（能被4整除但不能被100整除，或能被400整除），输出“是闰年”或“不是闰年”\n\n## 嵌套`if`语句\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    int age = 22;\n    char level = \'A\';\n    if (age >= 18) {\n        if (level == \'A\') {\n            printf(\"成年且等级为A\\n\");\n        }\n    } else {\n        if (level == \'A\') {\n            printf(\"未成年且等级为A\\n\");\n        }\n    }\n    return 0;\n}\n```\n\n### 代码解释\n嵌套`if`语句是在`if`代码块内再嵌套`if`。先判断外层`if`条件，再根据结果判断内层`if`条件执行对应代码\n\n### 编程题\n编写程序，输入一个整数，先判断是否大于0，若是再判断是否小于10，根据结果输出相应信息\n\n## `switch`语句\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    int day = 4;\n    switch (day) {\n    case 1:\n        printf(\"周一\\n\");\n        break;\n    case 2:\n        printf(\"周二\\n\");\n        break;\n    case 3:\n        printf(\"周三\\n\");\n        break;\n    case 4:\n        printf(\"周四\\n\");\n        break;\n    case 5:\n        printf(\"周五\\n\");\n        break;\n    case 6:\n        printf(\"周六\\n\");\n        break;\n    case 7:\n        printf(\"周日\\n\");\n        break;\n    default:\n        printf(\"无效数字\\n\");\n    }\n    return 0;\n}\n```\n\n### 代码解释\n`switch`根据表达式值匹配`case`常量，执行对应代码，`break`防止穿透，无匹配则执行`default`代码\n\n### 编程题\n编写程序，输入一个1 - 12的整数代表月份，输出该月的天数（考虑2月平年28天、闰年29天）。 ', 1, 1, 999997, 1);
INSERT INTO `visual_documents` VALUES (72, '2025-04-26 18:40:54.449', '2025-04-26 20:50:18.227', NULL, 52, '循环语句', '# 循环语句\n\n## `for` 循环\n\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    // 使用 for 循环打印 1 到 5 的整数\n    for (int i = 1; i <= 5; i++) {\n        printf(\"%d \", i);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n### 代码解释\n- **`for` 循环的结构**：`for` 循环由三个部分组成，用分号分隔，被括号 `()` 包围，后面紧跟循环体（用大括号 `{}` 括起来）\n    - **初始化部分**：`int i = 1`，在循环开始前执行一次，用于初始化循环控制变量 `i`\n    - **条件判断部分**：`i <= 5`，在每次循环开始前进行判断。如果条件为真，则执行循环体；如果为假，则退出循环\n    - **迭代部分**：`i++`，在每次循环体执行完毕后执行，用于更新循环控制变量的值\n\n### 编程题\n编写一个程序，使用 `for` 循环计算 1 到 100 的整数之和。\n\n## `while` 循环\n\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    int i = 1;\n    // 使用 while 循环打印 1 到 5 的整数\n    while (i <= 5) {\n        printf(\"%d \", i);\n        i++;\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n### 代码解释\n- **`while` 循环的结构**：`while` 循环先判断条件，若条件为真，则执行循环体；执行完循环体后，再次判断条件，如此反复，直到条件为假时退出循环\n    - **条件判断**：`i <= 5` 是循环条件，每次循环开始前都会检查该条件\n    - **循环体**：`printf(\"%d \", i); i++;` 是循环体，包含了要重复执行的代码。需要注意的是，在循环体中必须有更新循环控制变量的语句，否则可能会导致无限循环\n\n### 编程题\n编写一个程序，使用 `while` 循环让用户输入整数，直到用户输入 0 为止，然后输出用户输入的非零整数的个数\n\n## `do - while` 循环\n\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    int i = 1;\n    // 使用 do - while 循环打印 1 到 5 的整数\n    do {\n        printf(\"%d \", i);\n        i++;\n    } while (i <= 5);\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n### 代码解释\n- **`do - while` 循环的结构**：`do - while` 循环先执行一次循环体，然后再判断条件。如果条件为真，则继续执行循环体；如果条件为假，则退出循环\n    - **循环体**：`printf(\"%d \", i); i++;` 是循环体，会先执行一次\n    - **条件判断**：`while (i <= 5);` 是在循环体执行完后进行条件判断\n\n### 编程题\n编写一个程序，使用 `do - while` 循环让用户输入一个整数，判断该整数是否为正数。如果不是正数，则提示用户重新输入，直到用户输入一个正数为止\n\n## 嵌套循环\n\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    // 使用嵌套 for 循环打印乘法口诀表\n    for (int i = 1; i <= 9; i++) {\n        for (int j = 1; j <= i; j++) {\n            printf(\"%d * %d = %d\\t\", j, i, i * j);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n### 代码解释\n- **嵌套循环的概念**：嵌套循环是指在一个循环体中包含另一个循环。外层循环控制行数，内层循环控制每行的元素个数\n    - **外层循环**：`for (int i = 1; i <= 9; i++)` 控制乘法口诀表的行数，从 1 到 9\n    - **内层循环**：`for (int j = 1; j <= i; j++)` 控制每行的乘法表达式个数，每行的表达式个数与当前行数相同\n\n### 编程题\n编写一个程序，使用嵌套循环打印一个由星号 `*` 组成的直角三角形，三角形的行数由用户输入。例如，用户输入 5，则输出如下图形：\n```\n*\n**\n***\n****\n*****\n``` ', 1, 1, 999996, 1);
INSERT INTO `visual_documents` VALUES (73, '2025-04-26 18:56:34.544', '2025-04-26 20:50:36.421', NULL, 52, '数组', '# 数组\n\n## 一维数组\n\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    // 定义一个包含 5 个整数的一维数组\n    int arr[5];\n\n    // 初始化数组元素\n    arr[0] = 10;\n    arr[1] = 20;\n    arr[2] = 30;\n    arr[3] = 40;\n    arr[4] = 50;\n\n    // 访问并输出数组元素\n    for (int i = 0; i < 5; i++) {\n        printf(\"arr[%d] = %d\\n\", i, arr[i]);\n    }\n\n    return 0;\n}\n```\n\n### 代码解释\n- **数组定义**：`int arr[5];` 定义了一个名为 `arr` 的一维数组，该数组可以存储 5 个整数。数组下标从 0 开始，所以有效的下标范围是 0 到 4\n- **数组元素初始化**：通过 `arr[0] = 10;` 等语句，为数组的每个元素赋初值\n- **数组元素访问**：使用 `for` 循环遍历数组，通过 `arr[i]` 访问数组的每个元素，并使用 `printf` 函数输出元素的值\n\n### 编程题\n编写一个程序，定义一个包含 10 个整数的一维数组，让用户输入这 10 个整数，然后计算并输出数组中所有元素的和\n\n## 一维数组初始化\n\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    // 方式一：逐个元素初始化\n    int arr1[5];\n    arr1[0] = 1;\n    arr1[1] = 2;\n    arr1[2] = 3;\n    arr1[3] = 4;\n    arr1[4] = 5;\n\n    // 方式二：初始化列表\n    int arr2[5] = {1, 2, 3, 4, 5};\n\n    // 方式三：部分初始化，未指定元素个数\n    int arr3[] = {1, 2, 3};\n\n    // 输出 arr1\n    printf(\"arr1: \");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", arr1[i]);\n    }\n    printf(\"\\n\");\n\n    // 输出 arr2\n    printf(\"arr2: \");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", arr2[i]);\n    }\n    printf(\"\\n\");\n\n    // 输出 arr3\n    printf(\"arr3: \");\n    for (int i = 0; i < 3; i++) {\n        printf(\"%d \", arr3[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n\n### 代码解释\n- **逐个元素初始化**：先定义数组，再通过下标逐个为元素赋值\n- **初始化列表**：在定义数组时，使用花括号 `{}` 包含一系列初始值，各值之间用逗号分隔。数组元素个数由初始值的个数决定\n- **部分初始化且未指定元素个数**：如果初始化列表中的元素个数少于数组声明的大小，剩余元素会被自动初始化为 0。若不指定数组大小，编译器会根据初始化列表中的元素个数来确定数组大小\n\n### 编程题\n编写一个程序，定义一个一维数组并使用初始化列表进行初始化，然后找出数组中的最大值并输出\n\n## 二维数组\n\n### 代码示例\n```c\n#include <stdio.h>\n\nint main() {\n    // 定义一个 3 行 4 列的二维数组\n    int arr[3][4];\n\n    // 初始化二维数组元素\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4; j++) {\n            arr[i][j] = i * 4 + j;\n        }\n    }\n\n    // 访问并输出二维数组元素\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf(\"arr[%d][%d] = %d\\t\", i, j, arr[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n```\n\n### 代码解释\n- **二维数组定义**：`int arr[3][4];` 定义了一个 3 行 4 列的二维数组。可以将其看作是一个由 3 个一维数组组成的数组，每个一维数组包含 4 个元素\n- **二维数组元素初始化**：使用嵌套的 `for` 循环为二维数组的每个元素赋值。外层循环控制行，内层循环控制列\n- **二维数组元素访问**：同样使用嵌套的 `for` 循环遍历二维数组的每个元素，并输出其值\n\n### 编程题\n编写一个程序，定义一个 2 行 3 列的二维数组，让用户输入数组的所有元素，然后计算并输出数组中所有元素的平均值\n\n## 字符数组与字符串\n\n### 代码示例\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    // 定义一个字符数组并初始化为字符串\n    char str1[10] = \"Hello\";\n\n    // 另一种初始化方式\n    char str2[] = {\'W\', \'o\', \'r\', \'l\', \'d\', \'\\0\'};\n\n    // 输出字符串\n    printf(\"str1: %s\\n\", str1);\n    printf(\"str2: %s\\n\", str2);\n\n    // 计算字符串长度\n    int len1 = strlen(str1);\n    int len2 = strlen(str2);\n    printf(\"str1 的长度: %d\\n\", len1);\n    printf(\"str2 的长度: %d\\n\", len2);\n\n    return 0;\n}\n```\n\n### 代码解释\n- **字符数组与字符串的关系**：在 C 语言中，字符串是由字符数组表示的，并且以空字符 `\'\\0\'` 结尾\n- **字符串初始化**：可以使用字符串字面量直接初始化字符数组，也可以逐个字符初始化，最后手动添加 `\'\\0\'`\n- **字符串输出**：使用 `%s` 格式说明符通过 `printf` 函数输出字符串\n- **字符串长度计算**：使用 `<string.h>` 头文件中的 `strlen` 函数计算字符串的长度，该长度不包括结尾的 `\'\\0\'`\n\n### 编程题\n编写一个程序，让用户输入一个字符串，然后统计该字符串中字母的个数并输出', 1, 1, 999995, 1);
INSERT INTO `visual_documents` VALUES (74, '2025-04-26 19:01:15.713', '2025-04-26 20:51:03.276', NULL, 52, '函数', '# 函数\n\n## 函数的定义与调用\n\n### 代码示例\n```c\n#include <stdio.h>\n\n// 函数定义：计算两个整数的和\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int num1 = 5, num2 = 3;\n    // 函数调用\n    int result = add(num1, num2);\n    printf(\"两数之和为: %d\\n\", result);\n    return 0;\n}\n```\n\n### 代码解释\n- **函数定义**：\n    - `int add(int a, int b)` 是函数的声明部分，`int` 表示函数的返回值类型，`add` 是函数名，`(int a, int b)` 是函数的参数列表，表明该函数接收两个 `int` 类型的参数\n    - `{ return a + b; }` 是函数体，包含了函数要执行的具体操作，这里是将两个参数相加并返回结果\n- **函数调用**：在 `main` 函数中，`int result = add(num1, num2);` 调用了 `add` 函数，将 `num1` 和 `num2` 的值传递给 `add` 函数，函数执行完毕后返回结果并赋值给 `result` 变量\n\n### 编程题\n编写一个函数，用于计算一个整数的平方，在 `main` 函数中调用该函数并输出结果\n\n## 函数参数传递\n\n### 代码示例\n```c\n#include <stdio.h>\n\n// 值传递函数：交换两个整数的值\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n    printf(\"swap 函数内: a = %d, b = %d\\n\", a, b);\n}\n\n// 地址传递函数：交换两个整数的值\nvoid swapByAddress(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n    printf(\"swapByAddress 函数内: a = %d, b = %d\\n\", *a, *b);\n}\n\nint main() {\n    int x = 10, y = 20;\n\n    // 值传递调用\n    printf(\"值传递前: x = %d, y = %d\\n\", x, y);\n    swap(x, y);\n    printf(\"值传递后: x = %d, y = %d\\n\", x, y);\n\n    // 地址传递调用\n    printf(\"\\n地址传递前: x = %d, y = %d\\n\", x, y);\n    swapByAddress(&x, &y);\n    printf(\"地址传递后: x = %d, y = %d\\n\", x, y);\n\n    return 0;\n}\n```\n\n### 代码解释\n- **值传递**：在 `swap` 函数中，参数 `a` 和 `b` 是 `x` 和 `y` 的副本，函数内部对 `a` 和 `b` 的修改不会影响到 `main` 函数中的 `x` 和 `y`\n- **地址传递**：在 `swapByAddress` 函数中，参数 `*a` 和 `*b` 是指向 `x` 和 `y` 的指针，通过指针可以直接修改 `x` 和 `y` 的值\n\n### 编程题\n编写一个函数，通过地址传递的方式将一个整数乘以 2，在 `main` 函数中调用该函数并输出结果。\n\n## 函数的返回值\n\n### 代码示例\n```c\n#include <stdio.h>\n\n// 函数返回一个整数\nint getMax(int a, int b) {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n// 函数不返回值\nvoid printMessage() {\n    printf(\"这是一个无返回值的函数。\\n\");\n}\n\nint main() {\n    int num1 = 15, num2 = 25;\n    int max = getMax(num1, num2);\n    printf(\"较大的数是: %d\\n\", max);\n\n    printMessage();\n\n    return 0;\n}\n```\n\n### 代码解释\n- **有返回值的函数**：`getMax` 函数返回两个整数中的最大值，使用 `return` 语句将结果返回给调用者\n- **无返回值的函数**：`printMessage` 函数的返回值类型是 `void`，表示不返回任何值，函数体中不需要使用 `return` 语句返回具体的值\n\n### 编程题\n编写一个函数，判断一个整数是否为素数，返回一个布尔值（可以用 1 表示是素数，0 表示不是素数），在 `main` 函数中调用该函数并输出结果\n\n## 函数的嵌套调用\n\n### 代码示例\n```c\n#include <stdio.h>\n\n// 计算平方的函数\nint square(int num) {\n    return num * num;\n}\n\n// 计算平方和的函数，嵌套调用 square 函数\nint sumOfSquares(int a, int b) {\n    return square(a) + square(b);\n}\n\nint main() {\n    int x = 3, y = 4;\n    int result = sumOfSquares(x, y);\n    printf(\"两数的平方和为: %d\\n\", result);\n    return 0;\n}\n```\n\n### 代码解释\n- **函数嵌套调用**：`sumOfSquares` 函数内部调用了 `square` 函数，先分别计算 `a` 和 `b` 的平方，然后将结果相加并返回\n\n### 编程题\n编写三个函数：一个函数用于计算一个整数的立方，一个函数用于计算两个整数的立方和，在 `main` 函数中调用计算立方和的函数并输出结果\n\n## 递归函数\n\n### 代码示例\n```c\n#include <stdio.h>\n\n// 递归函数：计算阶乘\nint factorial(int n) {\n    if (n == 0 || n == 1) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nint main() {\n    int num = 5;\n    int result = factorial(num);\n    printf(\"%d 的阶乘是: %d\\n\", num, result);\n    return 0;\n}\n```\n\n### 代码解释\n- **递归函数的概念**：递归函数是指在函数内部调用自身的函数。`factorial` 函数通过不断调用自身来计算阶乘，直到满足终止条件（`n == 0` 或 `n == 1`）\n', 1, 1, 999994, 1);
INSERT INTO `visual_documents` VALUES (75, '2025-04-26 19:04:15.217', '2025-04-26 20:51:44.638', NULL, 52, '结构体', '# 结构体\n\n## 结构体定义\n### 代码示例\n```c\n#include <stdio.h>\n#include <string.h>\n\n// 定义结构体\nstruct Student {\n    char name[20];\n    int age;\n    float score;\n};\n\nint main() {\n    // 定义结构体变量\n    struct Student stu;\n    // 给结构体成员赋值\n    strcpy(stu.name, \"Alice\");\n    stu.age = 20;\n    stu.score = 88.5;\n\n    // 输出结构体成员信息\n    printf(\"姓名: %s\\n\", stu.name);\n    printf(\"年龄: %d\\n\", stu.age);\n    printf(\"成绩: %.2f\\n\", stu.score);\n\n    return 0;\n}\n```\n### 代码解释\n- **结构体定义**：使用`struct`关键字定义了名为`Student`的结构体类型，其中包含`name`（字符数组，用于存储姓名）、`age`（整数，用于存储年龄）和`score`（浮点数，用于存储成绩）三个成员\n- **结构体变量定义**：在`main`函数中，使用`struct Student`类型定义了一个结构体变量`stu`\n- **成员赋值**：对于字符数组`name`，使用`strcpy`函数进行赋值；对于`age`和`score`，直接进行赋值操作\n- **成员访问**：通过点号（`.`）运算符访问结构体变量的成员，并使用`printf`函数输出成员信息\n\n## 结构体数组\n### 代码示例\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Book {\n    char title[50];\n    char author[30];\n    float price;\n};\n\nint main() {\n    // 定义结构体数组并初始化\n    struct Book books[3] = {\n        {\"C Primer Plus\", \"Stephen Prata\", 59.9},\n        {\"Effective C\", \"Scott Meyers\", 49.9},\n        {\"The C Programming Language\", \"Brian Kernighan\", 39.9}\n    };\n\n    // 遍历结构体数组并输出信息\n    for (int i = 0; i < 3; i++) {\n        printf(\"书名: %s\\n\", books[i].title);\n        printf(\"作者: %s\\n\", books[i].author);\n        printf(\"价格: %.2f\\n\", books[i].price);\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n```\n### 代码解释\n- **结构体定义**：定义了`struct Book`结构体类型，包含`title`（字符数组，存储书名）、`author`（字符数组，存储作者）和`price`（浮点数，存储价格）三个成员\n- **结构体数组定义与初始化**：定义了一个包含3个元素的`struct Book`类型的结构体数组`books`，并对其进行了初始化\n- **遍历数组**：使用`for`循环遍历结构体数组，通过点号（`.`）运算符访问每个元素的成员，并输出信息\n\n## 结构体指针\n### 代码示例\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    // 定义结构体变量\n    struct Point p = {3, 5};\n    // 定义结构体指针并指向结构体变量\n    struct Point *ptr = &p;\n\n    // 通过指针访问结构体成员\n    printf(\"x 坐标: %d\\n\", ptr->x);\n    printf(\"y 坐标: %d\\n\", ptr->y);\n\n    return 0;\n}\n```\n### 代码解释\n- **结构体定义**：定义了`struct Point`结构体类型，包含`x`和`y`两个整数成员，用于表示平面上的一个点的坐标\n- **结构体变量与指针定义**：定义了一个`struct Point`类型的结构体变量`p`并初始化，同时定义了一个指向`struct Point`类型的指针`ptr`，并将`p`的地址赋值给`ptr`\n- **指针访问成员**：使用箭头（`->`）运算符通过指针`ptr`访问结构体变量`p`的成员，并输出信息\n\n## 结构体作为函数参数\n### 代码示例\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Rectangle {\n    int length;\n    int width;\n};\n\n// 计算矩形面积的函数（值传递）\nint calculateArea(struct Rectangle r) {\n    return r.length * r.width;\n}\n\n// 修改矩形长的函数（地址传递）\nvoid modifyLength(struct Rectangle *r, int newLength) {\n    r->length = newLength;\n}\n\nint main() {\n    struct Rectangle rect = {5, 3};\n\n    // 调用值传递函数计算面积\n    int area = calculateArea(rect);\n    printf(\"原矩形面积: %d\\n\", area);\n\n    // 调用地址传递函数修改长\n    modifyLength(&rect, 7);\n    area = calculateArea(rect);\n    printf(\"修改后矩形面积: %d\\n\", area);\n\n    return 0;\n}\n```\n### 代码解释\n- **结构体定义**：定义了`struct Rectangle`结构体类型，包含`length`（整数，存储矩形的长）和`width`（整数，存储矩形的宽）两个成员\n- **值传递函数**：`calculateArea`函数接受一个`struct Rectangle`类型的参数，通过值传递的方式将结构体变量的副本传递给函数，函数内部计算并返回矩形的面积\n- **地址传递函数**：`modifyLength`函数接受一个指向`struct Rectangle`类型的指针和一个新的长度值，通过地址传递的方式，函数内部可以直接修改原结构体变量的`length`成员\n- **函数调用**：在`main`函数中，先调用`calculateArea`函数计算原矩形的面积，然后调用`modifyLength`函数修改矩形的长，再次调用`calculateArea`函数计算修改后矩形的面积并输出\n\n## 编程题\n### 简单结构体应用\n编写一个程序，定义一个表示三角形的结构体，包含三条边的长度。编写函数判断该三角形是否为等边三角形、等腰三角形或普通三角形，并在`main`函数中调用这些函数进行测试\n### 结构体数组排序\n定义一个表示员工的结构体，包含员工编号、姓名、工资三个成员。编写一个程序，创建一个包含多个员工信息的结构体数组，并按照工资从高到低对员工进行排序，最后输出排序后的员工信息\n### 结构体指针操作\n定义一个表示时间的结构体，包含小时、分钟、秒三个成员。编写一个函数，接受一个指向时间结构体的指针，将时间增加1秒，并处理好进位情况。在`main`函数中调用该函数进行测试', 1, 1, 999993, 1);
INSERT INTO `visual_documents` VALUES (76, '2025-04-26 19:06:13.170', '2025-04-26 20:55:36.962', NULL, 52, '指针', '# 基本概念\n在 C 语言里，指针是一种特殊的变量，其存储的是内存地址，而非普通的数据值。借助指针，你能够直接对内存进行操作，这能提升程序的效率，也可实现一些复杂的数据结构和算法\n\n# 指针的声明与初始化\n## 1. 声明指针\n指针的声明格式为：`数据类型 *指针变量名;`。这里的“数据类型”代表指针所指向变量的类型。例如：\n```c\nint *p;  // 声明一个指向整型变量的指针\nchar *ch; // 声明一个指向字符型变量的指针\n```\n\n## 2. 初始化指针\n在声明指针之后，需要让它指向一个具体的变量。可以使用取地址运算符 `&` 来获取变量的地址，然后将其赋值给指针。示例如下：\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 10;\n    int *p;  // 声明一个指向整型的指针\n    p = &num;  // 初始化指针，让它指向 num 变量\n    printf(\"num 的地址是: %p\\n\", p);\n    return 0;\n}\n```\n在上述代码中，`&num` 表示获取 `num` 变量的地址，接着把这个地址赋值给指针 `p`。`%p` 是用来输出指针地址的格式说明符\n\n# 指针的解引用\n指针的解引用指的是通过指针来访问它所指向的变量的值。使用解引用运算符 `*` 可以实现这一点。示例如下：\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 10;\n    int *p = &num;  // 声明并初始化指针\n    printf(\"num 的值是: %d\\n\", *p);  // 解引用指针，输出 num 的值\n    *p = 20;  // 通过指针修改 num 的值\n    printf(\"修改后 num 的值是: %d\\n\", num);\n    return 0;\n}\n```\n在这段代码中，`*p` 表示访问 `p` 所指向的变量的值。借助 `*p = 20;` 能够通过指针修改 `num` 的值\n\n# 指针与数组\n## 数组名作为指针\n在 C 语言里，数组名实际上就是一个指向数组首元素的常量指针。例如：\n```c\n#include <stdio.h>\n\nint main() {\n    int arr[5] = {1, 2, 3, 4, 5};\n    int *p = arr;  // 数组名 arr 是指向数组首元素的指针\n    printf(\"数组首元素的值是: %d\\n\", *p);\n    return 0;\n}\n```\n在上述代码中，`arr` 是数组名，它等同于 `&arr[0]`，也就是指向数组首元素的指针\n\n## 指针访问数组元素\n可以使用指针来遍历数组元素。示例如下：\n```c\n#include <stdio.h>\n\nint main() {\n    int arr[5] = {1, 2, 3, 4, 5};\n    int *p = arr;\n    for (int i = 0; i < 5; i++) {\n        printf(\"arr[%d] 的值是: %d\\n\", i, *(p + i));\n    }\n    return 0;\n}\n```\n在这个代码中，`p + i` 表示指向数组第 `i` 个元素的指针，`*(p + i)` 则是访问该元素的值\n\n# 指针与函数\n## 指针作为函数参数\n把指针作为函数参数传递时，函数能够直接修改实参的值。示例如下：\n```c\n#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 10, y = 20;\n    printf(\"交换前: x = %d, y = %d\\n\", x, y);\n    swap(&x, &y);\n    printf(\"交换后: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n```\n在这段代码中，`swap` 函数接收两个指针作为参数，通过指针交换了两个变量的值\n\n## 函数返回指针\n函数也可以返回指针。不过要注意，返回的指针所指向的内存必须是有效的。示例如下：\n```c\n#include <stdio.h>\n\nint* getMax(int *arr, int size) {\n    int *max = arr;\n    for (int i = 1; i < size; i++) {\n        if (*(arr + i) > *max) {\n            max = arr + i;\n        }\n    }\n    return max;\n}\n\nint main() {\n    int arr[5] = {1, 3, 2, 5, 4};\n    int *max = getMax(arr, 5);\n    printf(\"数组中的最大值是: %d\\n\", *max);\n    return 0;\n}\n```\n在上述代码中，`getMax` 函数返回一个指向数组中最大值的指针\n\n# 动态内存分配\nC 语言提供了一些函数用于动态内存分配，如 `malloc`、`calloc`、`realloc` 和 `free`。动态内存分配能够在程序运行时根据需要分配和释放内存示例如下：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n = 5;\n    int *arr = (int *)malloc(n * sizeof(int));  // 分配内存\n    if (arr == NULL) {\n        printf(\"内存分配失败\\n\");\n        return 1;\n    }\n    for (int i = 0; i < n; i++) {\n        arr[i] = i + 1;\n    }\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    free(arr);  // 释放内存\n    return 0;\n}\n```\n在这段代码中，`malloc` 函数用于分配 `n` 个整型变量大小的内存空间，`free` 函数用于释放分配的内存', 1, 1, 999992, 1);
INSERT INTO `visual_documents` VALUES (77, '2025-04-26 23:46:35.673', '2025-05-14 01:23:13.189', NULL, 0, '二分查找', '# 二分查找\n\n- 在数组中查找元素时，若数组无序，通常需从第 0 个位置开始遍历，平均时间复杂度为 O(n)。例如在数组`[31, 66, 17, 15, 28, 20, 59, 88, 45, 56]`中查找元素，就需逐个比对\n\n- 而对于有序数组，可使用二分查找算法，其时间复杂度为 O(logn) 。比如在有序数组`[15, 17, 20, 28, 31, 45, 56, 59, 66, 88]`中查找元素，能利用数组有序特性提高查找效率\n\n## 算法思路\n假设在`[left，right)`范围内搜索某个元素`target`，计算中间位置`mid = (left + right）/ 2` 。\n1. 若`target < arr[mid]`，则去`[left，mid)`范围内继续二分搜索。\n2. 若`target > arr[mid]`，则去`[mid + 1，right)`范围内继续二分搜索。\n3. 若`target == arr[mid]`，直接返回`mid`。这里`right`指的是数组的长度。\n<iframe  \n height=400\n width=90%\n src=\"https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/binary-search.html\"  \n frameborder=0  \n allowfullscreen>\n </iframe>\n\n## 算法实现\n**GO实现**\n\n```go\nfunc BinarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n```\n**C实现**\n```c\nint BinarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n```\n实现起来非常简单，但是大家会发现一个问题，“如果存在多个重复的值，返回的是哪一个？”。实际上，**通过以上二分算法得到的返回值是非常不确定的**\n\n\n\n## 优化：查找第一个大于等于目标值的元素位置\n\n\n当目标值不在数组中时，我们希望返回第一个大于目标值的元素位置；当目标值存在时，返回第一个等于目标值的元素位置。\n\n#### 思路\n在二分查找过程中，当 `target <= arr[mid]` 时，更新 `right = mid`，继续向左查找，直到找到第一个大于等于目标值的位置。\n\n#### Go 代码实现\n```go\nfunc BinarySearchFirstGE(arr []int, target int) int {\n    left, right := 0, len(arr)\n    for left < right {\n        mid := left + (right-left)/2\n        if target <= arr[mid] {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n    return left\n}\n```\n\n#### C 代码实现\n```c\n#include <stdio.h>\n\nint BinarySearchFirstGE(int arr[], int size, int target) {\n    int left = 0;\n    int right = size;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (target <= arr[mid]) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n', 1, 1, 1000000, 4);
INSERT INTO `visual_documents` VALUES (78, '2025-04-27 23:53:21.484', '2025-05-14 01:20:14.009', NULL, 0, '两数相加', '# 两数相加\n\n[LeetCode 两数相加](https://leetcode.cn/problems/add-two-numbers/description/)\n\n\n给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储**一位**数字\n<br/>\n\n请你将两个数相加，并以相同形式返回一个表示和的链表\n<br/>\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头\n\n<br/>\n\n**示例 1：**\n<img src=\"https://fan-code-image-1308043430.cos.ap-guangzhou.myqcloud.com/problem/file/367957d6-2380-11f0-901a-00163e06661f.addtwonumber1.jpg\" width=\"400\" alt=\"示例 2 图片\">\n> 输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n\n**示例 2：**\n\n> 输入：l1 = [0], l2 = [0]\n输出：[0]\n\n**示例 3：**\n> 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n\n## 解题思路\n最直观的思路是模拟我们在纸上进行加法运算的过程。从两个链表的头部（即个位）开始，逐位相加，并处理可能产生的进位 \n逐位相加：\n- 同时遍历两个输入链表，获取对应节点的值（若链表已遍历完，该位置值视为 0）。将两节点值与carry相加，得到当前位的和sum。\n- 计算新的进位：carry = sum / 10\n- 取sum % 10作为当前位的结果，创建新节点并添加到结果链表中，更新current指针指向下一个节点。\n- 将输入链表的指针分别后移一位。\n\n两个输入链表都遍历完后，如果carry仍为 1，在结果链表末尾添加一个值为 1 的节点\n\n**GO代码**\n\n```go\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    carry := 0\n    var head *ListNode\n    var tail *ListNode\n    for l1 != nil || l2 != nil {\n        sum := carry\n        if l1 != nil  {\n            sum += l1.Val\n            l1 = l1.Next\n        }\n        if l2 != nil {\n            sum += l2.Val\n            l2 = l2.Next\n        }\n        carry = sum / 10\n        node := &ListNode {\n            Val: sum % 10,\n        }\n        if head == nil {\n            head = node\n            tail = node\n        } else {\n            tail.Next = node\n            tail = tail.Next\n        }\n    }\n    if carry != 0 {\n        tail.Next = &ListNode {\n            Val: carry,\n        }\n    }\n    return head\n}\n```', 1, 1, 999998, 4);
INSERT INTO `visual_documents` VALUES (79, '2025-05-03 01:19:35.155', '2025-05-03 01:19:35.155', NULL, 0, '未命名', '# 未命名\n\n## 标题1\n\n## 标题2', 1, 0, 1000001, 4);
INSERT INTO `visual_documents` VALUES (80, '2025-05-04 13:52:13.588', '2025-08-16 22:14:02.030', NULL, 52, '环境准备', '# 环境准备\n搭建 C 语言编程环境，GCC 编译器搭配合适的编辑器是绝佳组合。接下来，为你详细介绍在 Windows 系统中安装 GCC 编译器与 Visual Studio Code 编辑器的方法。\n\n## 啥是编译器？\n编译器就像是一个 “翻译官”，它的主要工作是将我们用 C 语言等高级编程语言编写的源代码，翻译成计算机能够直接理解和执行的机器语言（二进制指令）\n我们用 C 语言写的代码，比如`printf(\"Hello World\");`，这种代码是由字母、符号等组成的，符合人类的阅读和书写习惯。但计算机的硬件（比如 CPU）只能识别由 0 和 1 组成的二进制指令，无法直接理解我们写的高级语言代码。这时候编译器就发挥作用了，它会对源代码进行一系列的处理，包括语法检查、语义分析、优化等，最终生成计算机能看懂的二进制文件\n\n## GCC 编译器安装\nGCC（GNU Compiler Collection）是一款应用广泛的开源编译器，在 Windows 系统中，我们可借助 MinGW 来安装 GCC。以下为具体安装步骤：\n- 下载 MinGW 安装程序：打开浏览器，访问 MinGW 的官方下载页面，你可以在 SourceForge 上找到 MinGW 的下载链接。在下载页面中，找到 MinGW-W64 Online Installer 一栏，点击对应的链接下载安装程序，文件名为 mingw-w64-install.exe。\n运行安装程序：下载完成后，双击运行 mingw-w64-install.exe。在安装向导界面，点击 “Next” 进入下一步。\n指定安装设置：\nVersion：选择 GCC 的版本，若无特殊需求，建议选择最新版本，以获取最新功能和性能优化。\nArchitechture：依据你的系统架构进行选择，64 位系统选择 x86_64，32 位系统选择 i686。\nThreads：对于 Windows 系统，选择 win32。\nException：通常保持默认设置即可。\nBuild revision：同样可保持默认。\n完成上述设置后，点击 “Next”。\n选择安装目录：安装程序会提示你选择安装目录，默认路径为 C:\\mingw-w64，你也可以根据自己的需求选择其他磁盘空间充足且路径不含中文和空格的目录，然后点击 “Next”。\n开始安装：安装程序会自动下载并安装所选版本的 GCC 及相关组件，此过程可能需要一些时间，请耐心等待，期间确保网络连接稳定。\n配置环境变量：安装完成后，需要将 GCC 的安装路径添加到系统环境变量中，以便在命令行中能够直接使用 GCC 命令。\n右键点击 “此电脑”，选择 “属性”。\n在弹出的窗口中，点击左侧的 “高级系统设置”。\n在 “系统属性” 窗口的 “高级” 选项卡下，点击 “环境变量” 按钮。\n在 “系统变量” 列表中，找到 “Path” 变量，双击进行编辑。\n在弹出的 “编辑环境变量” 窗口中，点击 “新建”，然后输入 GCC 安装目录下的 bin 文件夹路径，例如 C:\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\bin（请根据你实际的安装路径填写）。\n点击 “确定” 保存设置，关闭所有窗口。\n验证安装：打开命令提示符（CMD），在命令行中输入 “gcc --version”，然后按下回车键。如果安装成功，你将看到 GCC 的版本信息，这表明 GCC 编译器已成功安装在你的系统中。\nVisual Studio Code 编辑器安装与配置\nVisual Studio Code 是一款强大且轻量级的跨平台代码编辑器，安装 C/C++ 插件后，可完美支持 C 语言编程。安装步骤如下：\n下载 Visual Studio Code：打开浏览器，进入 Visual Studio Code 官方网站，在首页找到下载按钮，根据你的操作系统（Windows）选择对应的安装包进行下载。\n运行安装程序：下载完成后，双击运行安装程序，在安装向导界面，按照提示逐步进行安装，你可以选择安装路径等选项，通常保持默认设置即可，完成后点击 “安装”。安装过程可能需要几分钟，安装完成后点击 “完成”。\n安装 C/C++ 插件：打开 Visual Studio Code，在界面左侧的扩展栏中（图标为四个小方块），搜索 “C/C++” 插件，找到由 Microsoft 发布的官方 C/C++ 插件，点击 “安装” 按钮进行安装。安装完成后，点击 “重新加载” 以使插件生效。\n完成上述 GCC 编译器和 Visual Studio Code 编辑器的安装与配置后，你就拥有了一个功能完备的 C 语言编程环境，可以开始编写和运行 C 语言程序了。\n', 1, 0, 1000001, 1);

-- ----------------------------
-- Table structure for visual_settings
-- ----------------------------
DROP TABLE IF EXISTS `visual_settings`;
CREATE TABLE `visual_settings`  (
  `id` bigint UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) NULL DEFAULT NULL,
  `updated_at` datetime(3) NULL DEFAULT NULL,
  `deleted_at` datetime(3) NULL DEFAULT NULL,
  `problem_id` bigint UNSIGNED NULL DEFAULT NULL,
  `user_id` bigint UNSIGNED NULL DEFAULT NULL,
  `language` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `visual_description` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_visual_settings_deleted_at`(`deleted_at` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 18 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of visual_settings
-- ----------------------------
INSERT INTO `visual_settings` VALUES (1, '2024-10-27 20:45:29.116', '2024-11-24 14:52:07.841', NULL, 97, 1, 'go', '{\r\n    \"type\": \"binaryTree\",\r\n    \"treeNode\": \"TreeNode\",\r\n    \"data\": \"Val\",\r\n    \"left\": \"Left\",\r\n    \"right\": \"Right\"\r\n}');
INSERT INTO `visual_settings` VALUES (2, '2024-10-30 01:00:45.035', '2024-10-30 01:00:45.453', NULL, 97, 1, 'c', '{\r\n    \"type\": \"binaryTree\",\r\n    \"treeNode\": \"TreeNodeStruct\",\r\n    \"data\": \"data\",\r\n    \"left\": \"leftNode\",\r\n    \"right\": \"rightNode\"\r\n}');
INSERT INTO `visual_settings` VALUES (3, '2024-11-08 00:26:57.120', '2024-11-13 23:50:22.399', NULL, 98, 1, 'go', '{\r\n    \"type\": \"array\",\r\n    \"arrayName\": \"array\",\r\n    \"pointNames\": [\r\n        \"left\",\r\n        \"right\",\r\n        \"mid\"\r\n    ]\r\n}');
INSERT INTO `visual_settings` VALUES (4, '2024-11-08 00:26:57.177', '2024-11-08 00:26:57.177', NULL, 98, 1, 'go', '{\r\n    \"type\": \"array\",\r\n    \"arrayName\": \"array\",\r\n    \"pointNames\": [\r\n        \"left\",\r\n        \"right\",\r\n        \"mid\"\r\n    ]\r\n}');
INSERT INTO `visual_settings` VALUES (5, '2024-11-16 11:18:31.849', '2024-11-24 14:19:09.896', NULL, 99, 1, 'go', '{\r\n    \"type\": \"linkList\",\r\n    \"linkNode\": \"ListNode\",\r\n    \"data\": \"value\",\r\n    \"next\": \"next\",\r\n    \"prev\": \"prev\"\r\n}');
INSERT INTO `visual_settings` VALUES (6, '2024-11-23 22:27:35.154', '2024-11-23 22:27:35.154', NULL, 119, 1, 'go', '{\r\n    \"type\": \"array\",    \r\n    \"arrayName\": \"nums\",\r\n    \"pointNames\": [\r\n        \"left\",\r\n        \"right\",\r\n        \"mid\"\r\n    ]\r\n}');
INSERT INTO `visual_settings` VALUES (7, '2024-11-23 23:12:05.063', '2024-12-30 09:13:09.431', NULL, 130, 1, 'go', '{\r\n    \"type\": \"array\",    \r\n    \"arrayName\": \"nums\", \r\n    \"pointNames\": [\r\n        \"left\",        \r\n        \"right\",\r\n        \"mid\"\r\n    ]\r\n}');
INSERT INTO `visual_settings` VALUES (8, '2024-11-25 18:45:22.435', '2024-11-25 18:45:22.435', NULL, 130, 23, 'go', '{\n    \"type\": \"array\",    \n    \"arrayName\": \"nums\",\n    \"pointNames\": [\n        \"left\",        \n        \"right\",\n        \"mid\"\n    ]\n}');
INSERT INTO `visual_settings` VALUES (9, '2024-11-25 22:44:20.112', '2024-11-26 10:15:56.412', NULL, 130, 26, 'go', '{\n    \"type\": \"array\",\n    \"arrayName\": \"nums\",\n    \"pointNames\": [\n        \"left\",   \n        \"right\",\n        \"mid\"\n    ]\n}');
INSERT INTO `visual_settings` VALUES (10, '2024-11-26 00:47:12.435', '2024-11-26 00:47:12.435', NULL, 107, 24, 'go', '{\r\n    \"type\": \"graph\",\r\n    \"graphNode\": \"graph\",\r\n    \"data\": \"data\",\r\n    \"nexts\": []\r\n}');
INSERT INTO `visual_settings` VALUES (11, '2024-11-26 10:20:07.906', '2024-11-26 10:21:58.431', NULL, 132, 26, 'go', '{\n    \"type\": \"binaryTree\",  \n    \"treeNode\": \"TreeNode\",\n    \"data\": \"Val2\",         \n    \"left\": \"Left\",        \n    \"right\": \"Right\"       \n}');
INSERT INTO `visual_settings` VALUES (12, '2024-11-26 20:22:37.234', '2024-11-26 20:25:24.885', NULL, 130, 27, 'go', '{\n    \"type\": \"array\",     \n    \"arrayName\": \"nums\", \n    \"pointNames\": [\n        \"left\",        \n        \"right\",\n        \"mid\",\n        \"haha\",\n        \"ha\"\n    ]\n}');
INSERT INTO `visual_settings` VALUES (13, '2024-11-26 20:50:59.065', '2024-11-26 20:51:13.988', NULL, 102, 1, 'go', '{\r\n    \"type\": \"binaryTree\",\r\n    \"treeNode\": \"TreeNodeStruct\",\r\n    \"data\": \"data\",\r\n    \"left\": \"leftNode\",\r\n    \"right\": \"rightNode\"\r\n}');
INSERT INTO `visual_settings` VALUES (14, '2024-12-29 17:10:41.469', '2024-12-30 11:48:47.951', NULL, 131, 1, 'go', '{\r\n    \"type\": \"linkList\",\r\n    \"linkNode\": \"LinkNode\",\r\n    \"data\": \"Val\",\r\n    \"next\": \"Next\",\r\n    \"prev\": \"Prev\"\r\n}');
INSERT INTO `visual_settings` VALUES (15, '2024-12-30 11:49:36.076', '2024-12-30 11:49:36.076', NULL, 132, 1, 'go', '{\r\n    \"type\": \"binaryTree\",\r\n    \"treeNode\": \"TreeNode\",\r\n    \"data\": \"Val\",\r\n    \"left\": \"Left\",\r\n    \"right\": \"Right\"\r\n}');
INSERT INTO `visual_settings` VALUES (16, '2024-12-31 01:39:49.335', '2024-12-31 01:39:49.335', NULL, 100, 32, 'go', '{\r\n    \"type\": \"array\",\r\n    \"arrayName\": \"arr\",\r\n    \"pointNames\": [\r\n        \"point1\",\r\n        \"point2\"\r\n    ]\r\n}');
INSERT INTO `visual_settings` VALUES (17, '2025-01-01 12:32:27.507', '2025-01-01 12:32:27.507', NULL, 0, 32, 'go', '{\r\n    \"type\": \"array\",\r\n    \"arrayName\": \"arr\",\r\n    \"pointNames\": [\r\n        \"point1\",\r\n        \"point2\"\r\n    ]\r\n}');


SET FOREIGN_KEY_CHECKS = 1;
